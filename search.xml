<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>持续集成实践中的思考</title>
      <link href="2020/02/20/devops-practices-thinking/"/>
      <url>2020/02/20/devops-practices-thinking/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在看到ThoughtWorks的一篇技术文章提到“几项与持续集成相关的反模式”, 结合自己的实践体会特别有深切体会，所以记录下来</p></blockquote><h2 id="持续集成的反模式"><a href="#持续集成的反模式" class="headerlink" title="持续集成的反模式"></a>持续集成的反模式</h2><p>最需要被点名批评的现象莫过于“持续集成剧场”了：</p><blockquote><p>很多开发者只是简单的搭建了持续集成服务器就以为在做“持续集成”，但他们实际上会遗失持续集成的关键优点而导致失败。常见的失败模式包括：虽然在一个共享的主分支上运行持续集成，但是代码提交不频繁，所以集成并没有真正的“持续”。以及在一个测试覆盖率不足，甚至是长期状态为红的情况下进行构建；或者在功能分支上运行持续集成，这会导致持续隔离。</p></blockquote><p>简而言之，这些团队并没有真正体会到持续集成的好处，而是为了完成上级的任务而演一场“我们在持续集成”的戏——这也正是这个反模式的名字由来。过去十年中，我们在众多刚开始实施持续集成的企业见过这一幕。领导认识到持续集成的好处，<strong>但是推行成了个大问题：推轻了，下面团队不愿动，技术问题解决不了；推重了，下面团队来个上有政策下有对策，领导想看什么就给你演什么——持续集成剧场就此落成。比如说你见过一个表面看起来一直是绿色但是背后连编译都不敢跑的持续集成吗？</strong> 我见过。真是一场好戏。</p><p>为了解决持续集成演戏的问题，一些规模较大的企业开始建设持续集成中心。想法很符合直觉：既然团队自己做持续集成有技术困难、还有可能变成演戏，<strong>那么我就组建一支团队专门帮他们一个个把持续集成跑通、帮他们管理持续集成服务器，</strong>持续集成的运行和统计数据都在这个中央团队手里，下面的团队总没办法演戏了吧？于是，他们又遭遇了第二个持续集成反模式：“所有团队共用一个持续集成实例”。</p><blockquote><p>那些必须使用中心化持续集成服务器的交付团队，常常依赖中心的团队去完成小的配置任务，或者在共享的基础设置和工具中排查问题，这给他们在进度上带来长时间的滞后。</p></blockquote><p>这次是康威定律带来的困难：如果每个团队使用的技术栈配置不同、技术栈配置和管理的职责仍然在每个团队中，那么技术栈演进与持续集成的演进就难免出现节拍不一致。<strong>于是管理着持续集成中心的中央团队开始疲于奔命，帮一个个项目团队修持续集成，而项目团队还感到没有得到足够的支持。</strong></p><p>第三个反模式是“企业级集成测试环境”，这也是很多组织建设持续集成中心的初衷之一：由于能执行完整端到端测试的环境稀缺，各个团队的集成测试无论如何也必须在一个瓶颈处统一调度，所以中心化管理持续集成也就顺理成章。然而，</p><blockquote><p>这些企业集成测试环境通常称为 SIT 或预生产环境）是当下持续交付常见的瓶颈。环境本身很脆弱而且维护成本很高，而这些环境通常存在一些需要由单独的环境管理团队手动配置的组件。在预生产环境的测试给出的反馈慢且不可靠，而且会重复测试那些在隔离的组件上已经测过的功能。</p></blockquote><h2 id="我的体会"><a href="#我的体会" class="headerlink" title="我的体会"></a>我的体会</h2><ol><li><p>对于上面第一个情景，很多时候我们以为有了工具就是持续集成，但是往往那些持续集成并不是那么完美，至少在我看到都是“hardcode”, 可移植性差，不能复用，维护成本高，下一个接手的人需要花时间了解上一个人做的“CI/CD”；因为在一些团队里，并不是很重视这个，认为CI/CD仅仅是个辅助的东西，当然这样跟国内项目的开发周期有关，有时候项目很小，客户催的很急，哪有时间去优化那么好，能用起来再说。当下一个项目来的时候，同样的技术栈的项目还要重新来过一次。</p></li><li><p>毕竟对于开发团队来说，CI/CD是另外一个领域的东西，虽然入门简单（按照网上的教程一个很简单demo就搞定了），但是里面的思想和业务场景需要一个个业务场景的积累，如何优化，如何标准化复用，这并不是简单的事情，其实这也是DevOps要解决的一个个痛点。</p></li><li><p>那么我们建个专业的团队做这个事情吧，就是第二个场景提到的事情，其实这也是我目前正在进行中的场景，但是随着业务开展，严格意义上还没有人用，我们就发现你搞出来了，不见得有人会用，不同的业务，不同的技术栈，你需要和Dev团队密切沟通，需要DevOps团队有广阔的技术视野，如果服务众多个不同业务团队，你可能会发现自己被动的成为了“那个业务项目的一员”；另外沟通的成本其实也不低，想法是好的有个专业的团队，但是落地不是那么容易，这不是一个人，一个团队能解决的问题。</p></li><li><p>那么如何解决这个困境？ 我认为需要企业自上而下，推广这种文化，可以从一个项目开始做推广，小步快跑，将“标准化规则”慢慢建立起来，比如分支的管理，依赖管理，CI/CD与不同技术栈的集成标准化，环境问题（内部环境,线上环境），最后衍生出来一个标准化的CI/CD平台。最后的场景是，Dev团队只关注于业务，他们只需要基于一个CI/CD模板，填写必要的环境参数等，剩下的事情不需要他们管，对于他们是透明的，他们只需要产出是什么，比如仓库，邮件通知等等。</p></li><li><p>所有的”快速复用，持续交付”都是基于大家形成的一个标准流程，没有标准，就没有”复用”，就没有快速的迭代，最后还是”半人工”的低效工作。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进化-读后感-1</title>
      <link href="2019/11/16/jin-hua-du-hou-gan-1/"/>
      <url>2019/11/16/jin-hua-du-hou-gan-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>最近在看这本《进化-运维技术变革与实践探索》，结合自己的一些实践，有些心得体会，并且摘录了我认为重要的或者有同感的内容。</p><ul><li><a href="https://time.geekbang.org/column/intro/63">https://time.geekbang.org/column/intro/63</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续交付看似一个简单的工具链打通，却需要突破诸多障碍-组织上，工具上，文化上</p><pre><code>- 组织上，必须打破部门墙，否则工具链肯定连不起来- 工具平台能力上，涉及多个方面：项目管理，需求管理，环境管理，配置管理，部署管理，测试管理，监控管理，服务治理</code></pre><p><strong>IT及运维的成熟度分为几个阶段:</strong></p><pre><code>1. 职能阶段: IT和运维作为独立的成本中心存在，其职能在于高效地交付一系列相对有限的核心运维能力2. 内部赋能阶段：IT 和运维专注于实现流畅的内部流程和操作规范，并持续改进，同时被动响应从业务线来的各种需求。这个阶段的运维团队追求的是以IT为中心的由内到外、自下而上的价值趋向，表现和结果3. 贡献阶段：IT 和运维团队在完成自身的营运常态化之后，可以致力于解决业务问题，积极引导IT和运维资源及服务朝着业务目标前进，成为专注于业务的运维团队。这个阶段的运维视角也发生了根本的转变，变成了以业务为导向的由外到内，自上而下的视角4. 差异化阶段：IT和运维团队同其他不同领域的业务团队积极合作，相互融合来持续交付新的产品，服务以及差异化的运营，团队能够敏捷完成产品和服务创新。这这个阶段，IT 和运维已经成为业务本身5. 转型阶段：IT 和运维团队成为持续业务改造的核心，甚至可以被用来重新定义市场和竞争规则。在这个阶段，IT和运维将成为企业的核心竞争优势</code></pre><p>运维能力是整体技术架构能力的体现，运维层面爆发的问题或故障一定是因为整体技术架构中存在问题，割裂两者，单纯看技术架构或运维都是毫无意义的</p><p>跳出运维看运维，从架构角度看运维，这种运维思路上的转变，远比单纯提升运维技术更有价值。从全局角度来看运维，考虑如何打造和体现整个技术架构的运维能力，而不是”运维”的运维能力</p><p>软件架构的目的，是将构建和维护所需的人力资源见到最低    - From 《架构整洁之道》</p><p><strong>运维接触更多的是软件生命周期中的运行维护阶段:</strong></p><ul><li><p>持续交付</p><ul><li>持续集成</li><li>持续部署</li><li>持续发布</li></ul></li><li><p>持续运维</p><ul><li>运行数据分析</li><li>体验数据分析</li><li>预案演练</li><li>故障复查</li></ul></li><li><p>持续反馈和改进</p><ul><li>效率提升</li><li>性能优化</li><li>稳定性提升</li><li>体验提升</li><li>成本控制</li></ul></li><li><p>架构优化</p><ul><li>更加高效稳定地支持业务快速发展</li></ul></li></ul><h2 id="1-运维的本质"><a href="#1-运维的本质" class="headerlink" title="1. 运维的本质"></a>1. 运维的本质</h2><p>规划以<strong>应用</strong>为核心的运维体系</p><pre><code>1. 应用业务模型  -从运维角度，属于业务范畴，不用关注太多2. 应用管理模型- 应用自身属性：应用名，功能信息，责任人，Git地址，部署结构（代码路径，日志路径，以及各类配置文件路径），启停方式，健康检测方式3. 应用运行时所依赖的基础设施和组件- 资源层面： 物理机，虚拟机，容器，HTTP服务（IP,DNS服务）- 基础组件：数据库，缓存，消息队列，存储</code></pre><p>1） 建立各个基础设施和组件的数据模型，同时识别出它们的唯一标识  （以缓存为例，namespace，容量，分区）</p><p>2） 设别出基础设施及组件可以与应用名AppName建立关联关系的属性</p><ul><li>场景1： 资源没有生命周期管理，没有建立和应用之间的关系</li><li>场景2：没有同意应用名，使得各个平台之间形成孤岛</li></ul><h2 id="2-运维体系建设"><a href="#2-运维体系建设" class="headerlink" title="2. 运维体系建设"></a>2. 运维体系建设</h2><p><strong>标准先行！！！</strong></p><p>标准化的过程实际山就是对象的识别和建模过程。形成统一的对象模型之后，各方在统一的认识下展开有效协同，然后针对不同的运维对象，抽取出它们对应的运维场景，接下来才是运维场景的自动化实现。</p><p>运维脱离对象，就没有任何意义。同样，没有理清楚对象，运维自然不得章法。</p><p><strong>标准化步骤：</strong></p><pre><code>1) 识别对象2) 识别对象属性3) 识别对象关系4) 识别对象场景a) 基础设施标准化    1) 识别对象：服务器，网络，IDC，机柜，存储，配件等    2) 识别对象属性：服务器（SN序列号，IP,厂商）；硬件配置（CPU,内存，硬盘，网卡，PCIE, BIOS）; 网络设备(厂商，型号，参数等)    3) 识别对象关系：服务器所在机柜； 虚拟机所在宿主机；机柜所在IDC 等。。拓扑结构    4) 识别对象场景： 服务器为例，日常操作：采购，入库，安装，配置，上线，下线，维修。。可视化/查询/拓扑/动态展示/级联关系/健康状态b) 应用层面的标准化    1) 识别对象：微服务在“设计阶段”被识别和确认    2) 识别对象属性：一个应用是业务逻辑的抽象    ○ 业务属性    ○ 运维属性        i. 应用元数据属性：应用名，Owner，所属业务，功能说明等        ii. 应用代码属性：语言，版本，GitLab地址        iii. 应用的部署模式： 软件包/容器        iv. 应用的目录信息，日志目录/运维脚本目录/安装目录等        v. 应用的运行脚本，如启停，监控检测脚本        vi. 应用运行时的配置参数，如端口，JVM 参数等    3) 识别对象关系        i. 应用与基础设施        ii. 应用与应用之间关系 -e.g. API依赖        iii. 应用与中间件关系    4) 识别应用场景：持续集成，持续发布，扩容，缩容，监控，容量评估，压测，限流降级  </code></pre><p><strong>运维职责：</strong></p><pre><code>- 基础架构标准化    --&gt;-选型- 基础架构服务标准化       - 基于基础架构工具原生能力进行“封装”，e.g. 创建/申请容量，扩容/缩容，服务发现/访问路由配置，监控指标，主备切换能力1. 参与制定基础架构标准并对标准进行强制约束2. 基础架构的服务化平台开发    - 平台自主化，让开发人员依赖平台能力自助完成对基础组件的需求，二不是依赖运维人员    - 如果不朝着“服务化”方向发展，运维将始终被拖累在基础组件的运维操作上</code></pre><p>应用运维体系建设： 从应用的生命周期的视角看</p><pre><code>1. 应用的创建阶段：应用需要用到哪些基础服务，在架构设计和编码阶段就要确定下来2. 应用的研发阶段：应用的持续集成体系3. 应用的上线阶段：申请应用所需服务器资源，发布软件包使其上线4. 应用的运行阶段（最核心，最重要）： 各项运行指标 -监控/报警体系      - 业务需求不断变化，需要不断“迭代更新”线上应用，依然依赖研发阶段的持续集成，并最终与线上发布形成持续交付这样的闭环体系      - 应用之间的依赖管理和链路追踪的场景      - 外部业务量的各种异常变化 （双11， 热点事件，服务器/IDC/数据库 故障） -线上稳定性保障5. 应用的销毁阶段： 清理资源，取决于最前面应用与基础服务关系模型分析和建设是否到位</code></pre><h2 id="3-配置管理数据库（CMDB）"><a href="#3-配置管理数据库（CMDB）" class="headerlink" title="3. 配置管理数据库（CMDB）"></a>3. 配置管理数据库（CMDB）</h2><p>当识别出运维对象之间的关系，并形成了统一的标准之后，就需要通过某个信息管理平台“固化”，这就是CMDB (Configuration Management DataBase).</p><p>CMDB源于20世纪80年代末的ITIL，源于传统IT运维阶段，但发扬光大确实新兴的互联网行业。</p><p>CMDB 是一个”高度定制化”的体系, 没有统一的标准。</p><p>传统运维阶段，更多是以“设备”为核心进行管理；但是到了互联网技术阶段，核心变成了“应用”</p><pre><code>- 应用名---应用配置信息- IP--资源信息 </code></pre><p>二者通过“应用名-IP”的对应关系联系在一起</p><p>CMDB是运维的基石，但是需要把精力放在运维的核心“应用”上来 - CMDB是面向“资源”的管理，应用配置是面向“应用”的管理</p><p>CMDB中如何落地应用，以及如何建立应用集群分组<br>    - 产品线 -业务团队-应用<br>    - 多环境/多IDC/多服务分组</p><p>应用-集群服务分组-资源</p><h2 id="4-运维组织架构与模式"><a href="#4-运维组织架构与模式" class="headerlink" title="4. 运维组织架构与模式"></a>4. 运维组织架构与模式</h2><pre><code>1. 运维基础平台体系建设 -CMDB,DNS管理，资源管理，偏运维自身体系建设2. 分布式中间件的服务化建设3. 持续交付体系建设 -依赖于上面两个基础体系的建设4. 稳定性体系建设 -快速定位/快付故障恢复/评估扩容5. 技术运营体系建设 -标准，指标，规则和流程  -意识</code></pre><p>跨团队协作 -1. 运维团队主动出击，沟通推进； 2. 上层支持`</p><p>Google SRE 运维模式</p><p>对SRE职责定义-负责可用性，时延，性能，效率，变更管理，监控，应急响应和容量管理等相关工作。—-&gt;”效率” 和“稳定”</p><p>CRE/云计算/AI -新的挑战 -应用运维的转型</p><h2 id="5-持续交付"><a href="#5-持续交付" class="headerlink" title="5. 持续交付"></a>5. 持续交付</h2><p>配置管理</p><pre><code>- 版本控制- 依赖管理    ○ Mavn/Ant/Gradle  建立本地Maven 源，构建时候优先从本地获取依赖包，本地源没有对应依赖时，从公网下载，同时缓存到本地- 软件配置    ○ 代码配置 -与代码运行时业务逻辑有关    ○ 应用配置 -与环境有关 （部署环境/不同机房：平台类为主；私有部署到不同客户）        § 构建配置：编程语言，构建方式。。        § 部署配置：日志目录，脚本目录。。        § 运行配置：应用启停，服务上下线，健康监测方式等        § 应用运行时与基础组件关系：依赖的数据库，缓存，消息队列等。- 环境配置 -持续交付的重中之重，最复杂的部分</code></pre><p>多环境配置管理</p><pre><code>- 开发环境- 集成环境- 预发环境- Beta环境（灰度，金丝雀）- 线上环境</code></pre><p>环境配置管理主要时针对应用对于基础设施和基础服务依赖关系的配置管理</p><p>解决方案</p><pre><code>1. 多个配置文件，构建时替换    a. 开发环境： dev_config.properties    b. 预发环境：pre_config.properties    c. 线上环境：online_cofnig.properties    这三个配置文件里的“配置项”时相同的，根据不同环境，值时不同的。 构建时，根据选定的环境对配置文件进行替换- 优点：简单直接，适合配置项变化不大情况- 缺点：没多出一个环境，就要加一个配置文件，如果配置项不断变化，管理很麻烦； 不同环境单独构建，多次打包2. 占位符（Placeholder）模板模式- 配置项的值用“变量”替换- 只保留一个config.properties；但是变量的值可能要多份- 没有解决只打包一次问题3. AutoConfig 方案- 阿里巴巴开发的Webx框架中的一个工具包，继承了Maven的配置管理方式，同时可以作为插件直接与Maven配合工作    ○ 配置校验：对与替换的值做校验，提前发现问题    ○ 只打包一次    ○ 需要基于AutroConfig 做二次开发</code></pre><p>比较敏感的配置信息（如用户名，Token，密码等）不允许放在配置文件，跟不允许明文方式</p><p>多环境建设</p><pre><code>- 1. 线下环境分类建设    ○ 不必建设多个相同的，尽量最小化    ○ 开发/测试使用环境冲突，同一应用不同版本/项目团队冲突集成测试环境- 最大程度与线上版本同步，也为开发测试环境和项目环境提供部分依赖服务开发测试环境- 偏向日常的需求开发，联调和功能验证，以最小化原则进行建设项目环境- 适用于多团队多个项目，遵循最小化原则，项目启动分配资源，结束时回收资源技术点： 网段规划（每个环境独立网段）；服务化框架的单元化调用；DNS访问策略；自动化管理- 2. 线上环境建设    ○ 生产环境- 无法百分之百模拟真实的用户场景    ○ Beta环境    ○ 预发环境    ○ 办公室生产环境</code></pre><p>持续交付流水线</p><pre><code>- 持续交付建立在上面多环节以及配置管理的基础上1. 项目需求分解- 确定多个应用的联调，测试和最终发布的计划和协同，依赖关系2. 代码提交方式 -分支策略选择3. 应用的构建  - 静态语言/动态语言    ○ 配置文件如何打包？构建时，确认部署的环境    ○ 使用docker作为编译环境</code></pre><p>发布策略- 蓝绿发布，灰度发布（金丝雀），滚动发布</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello DevOps</title>
      <link href="2019/11/16/hello-devops/"/>
      <url>2019/11/16/hello-devops/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会有这个博客"><a href="#为什么会有这个博客" class="headerlink" title="为什么会有这个博客"></a>为什么会有这个博客</h2><p>工作很多年了，一直从事与持续交付，版本上线发布相关的工作，从最初连什么是“daily build”都不知道，到慢慢接触到持续集成，devops等，随着经验的积累，对devops有了一定的理解，也确定了自己今后的专注的方向。随之而来，SRE，运维慢慢进入我的视野，对于产品上线后的保障监控，我还是新手，也在慢慢学习。近几年云计算和容器的发展，促进了运维的发展，这些都是我看好的方向。</p><p>所以希望对过去的经验和知识进行总结，分享出来，这些都来自于平时在OneNote，有道笔记的积累，算是对过去知识体系的重新梳理。</p><p>搭建这个博客- <a href="https://pages.github.com/">GitHub Pages</a> + <a href="http://jekyllrb.com/">Jekyll</a> 快速 Building Blog 的技术方案</p><h2 id="后面会写点什么"><a href="#后面会写点什么" class="headerlink" title="后面会写点什么"></a>后面会写点什么</h2><p>主要会围绕devops/运维相关话题展开，也会涉及其他技术栈，毕竟运维和业务不是割裂的，好的运维需要知道业务的技术栈</p>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps-Tools</title>
      <link href="2019/10/02/devops-tools/"/>
      <url>2019/10/02/devops-tools/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2504773-796984a907e0a8f1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="devops-tools.jpg"></p><h2 id="版本控制-amp-协作开发"><a href="#版本控制-amp-协作开发" class="headerlink" title="版本控制&amp;协作开发"></a>版本控制&amp;协作开发</h2><ul><li><p>版本控制系统 Git</p><p>  Git 是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。开源中国 Git 代码托管平台：<a href="http://git.oschina.net/">http://git.oschina.net/</a></p></li><li><p>代码托管平台 GitLab</p><p>  GitLab 是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。开源中国代码托管平台 git.oschina.net 就是基于 GitLab 项目搭建。</p></li><li><p>代码评审工具 Gerrit</p><p>  Gerrit 是一个免费、开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件程序员，可以相互审阅彼此修改后的程序代码，决定是否能够提交，退回或者继续修改。它使用 Git 作为底层版本控制系统。</p></li><li><p>版本控制系统 Mercurial</p><p>  Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。</p></li><li><p>版本控制系统 Subversion</p><p>  Subversion 是一个版本控制系统，相对于的 RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上免费的版本控制服务多基于Subversion。</p></li><li><p>版本控制系统 Bazaar</p><p>  Bazaar 是一个分布式的版本控制系统，它发布在 GPL 许可协议之下，并可用于 Windows、GNU/Linux、UNIX 以及 Mac OS 系统。</p></li></ul><h2 id="包-amp-产品管理工具"><a href="#包-amp-产品管理工具" class="headerlink" title="包&amp;产品管理工具"></a>包&amp;产品管理工具</h2><ul><li><p>Chocolatey：Chocolatey是Windows下一款开源的命令行包管理软件 ，简单说这就是Windows的apt-get；</p></li><li><p>WiX Toolset：提供一组最强大的工具集来帮助你创建Windows安装包。该工具集从XML源代码构建你的Windows安装程序包，可以无缝集成到构建过程；</p></li></ul><h2 id="自动化构建和测试"><a href="#自动化构建和测试" class="headerlink" title="自动化构建和测试"></a>自动化构建和测试</h2><ul><li><p>Apache Ant<br>  Apache Ant是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。</p></li><li><p>Maven<br>  Maven 除了以程序构建能力为特色之外，还提供 Ant 所缺少的高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目，而使用 Ant 则需要十几行。<br>  事实上，由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目现在使用 Maven，而且公司项目采用 Maven 的比例在持续增长。开源中国的 Maven 库 <a href="http://maven.oschina.net/">http://maven.oschina.net</a></p></li><li><p>Selenium<br>Selenium (SeleniumHQ) 是 thoughtworks公司的一个集成测试的强大工具。</p></li><li><p>PyUnit<br>Python单元测试框架（The Python unit testing framework），简称为PyUnit， 是Kent Beck和Erich Gamma这两位聪明的家伙所设计的 JUnit 的Python版本。</p></li><li><p>QUnit<br>QUnit 是 jQuery 的单元测试框架。</p></li><li><p>JMeter<br>JMeter 是 Apache 组织的开放源代码项目，它是功能和性能测试的工具，100% 的用 java 实现。</p></li><li><p>Gradle<br>Gradle 就是可以使用 Groovy 来书写构建脚本的构建系统，支持依赖管理和多项目，类似 Maven，但比之简单轻便。</p></li><li><p>PHPUnit<br>PHPUnit 是一个轻量级的PHP测试框架。它是在PHP5下面对JUnit3系列版本的完整移植，是xUnit测试框架家族的一员(它们都基于模式先锋Kent Beck的设计)。</p></li></ul><h2 id="持续集成-amp-交付"><a href="#持续集成-amp-交付" class="headerlink" title="持续集成&amp;交付"></a>持续集成&amp;交付</h2><ul><li><p>Jenkins<br>  Jenkins 是一个开源的持续集成工具，使用 Java 编程语言编写的。它有助于实时检测和报告较大代码库中的单一更改。该软件可帮助开发人员快速查找和解决代码库中的问题并自动测试其构建。</p></li><li><p>Travis CI<br>  Travis 是一款流行的 CI 工具，可免费用于开源项目。在托管时，不必依赖任何平台。此 CI 工具为许多构建配置和语言提供支持，如 Node，PHP，Python，Java，Perl 等。</p></li><li><p>GoCD<br>  GoCD 是一个开源的持续集成服务器。它可轻松模拟和可视化复杂的工作流程。此 CI 工具允许持续交付，并为构建 CD Pipeline 提供直观的界面。</p></li><li><p>Bamboo<br>  Bamboo 是一个持续集成的构建服务器，可以自动构建、测试和发布，并可与 JIRA 和 Bitbucket 无缝协作。Bamboo 支持多语言和平台，如 CodeDeply、Ducker、Git，SVN、Mercurial、AWS 及 Amazon S3 bucket</p></li><li><p>GitLab CI<br>  GitLab CI 是 GitLab 的一部分。它是一个提供 API 的 Web 应用程序，可将其状态存储在数据库中。GitLab CI 可以管理项目并提供友好的用户界面，并充分利用 GitLab 所有功能</p></li></ul><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><ul><li><p>Chef<br>  Chef 是一个系统集成框架，为整个架构提供配置管理功能。</p></li><li><p>Puppet<br>  Puppet，您可以集中管理每一个重要方面，您的系统使用的是跨平台的规范语言，管理所有的单独的元素通常聚集在不同的文件，如用户， CRON作业，和主机一起显然离散元素，如包装，服务和文件。</p></li><li><p>RunDeck<br>  RunDeck 是用 Java/Grails 写的开源工具，帮助用户在数据中心或者云环境中自动化各种操作和流程。通过命令行或者web界面，用户可以对任意数量的服务器进行操作，大大降低了对服务器自动化的门槛。</p></li><li><p>Saltstack<br>  Saltstack 可以看做是func的增强版+Puppet的弱化版。使用Python编写。非常好用,快速可以基于EPEL部署。Salt 是一个开源的工具用来管理你的基础架构，可轻松管理成千上万台服务器。</p></li><li><p>Ansible<br>  Ansible 提供一种最简单的方式用于发布、管理和编排计算机系统的工具，你可在数分钟内搞定。Ansible 是一个模型驱动的配置管理器，支持多节点发布、远程任务执行。默认使用 SSH 进行远程连接。无需在被管理节点上安装附加软件，可使用各种编程语言进行扩展。</p></li></ul><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><ul><li><p>Logstash<br>Logstash 是一个应用程序日志、事件的传输、处理、管理和搜索的平台。你可以用它来统一对应用程序日志进行收集管理，提供 Web 接口用于查询和统计。</p></li><li><p>CollectD<br>Collectd 是一个守护(daemon)进程，用来收集系统性能和提供各种存储方式来存储不同值的机制。比如以RRD 文件形式。</p></li><li><p>StatsD<br>StatsD 是一个简单的网络守护进程，基于 Node.js 平台，通过 UDP 或者 TCP 方式侦听各种统计信息，包括计数器和定时器，并发送聚合信息到后端服务，例如 Graphite。</p></li><li><p>Nagios<br>Nagios 是一个监视系统运行状态和网络信息的监视系统。Nagios能监视所指定的本地或远程主机以及服务，同时提供异常通知功能等。</p></li><li><p>Ganglia<br>Ganglia 是一个跨平台可扩展的，高 性能计算系统下的分布式监控系统，如集群和网格。它是基于分层设计，它使用广泛的技术，如XML数据代表，便携数据传输，RRDtool用于数据存储和可视化。</p></li><li><p>Sensu<br>Sensu 是开源的监控框架。主要特性：高度可组合；提供一个监控代理，一个事件处理器和文档 APIs；为云而设计；Sensu 的现代化架构允许监控大规模的动态基础设施，能够通过复杂的公共网络监控几千个全球分布式的机器和服务；热情的社区。</p></li><li><p>Zabbix<br>Zabbix 是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。</p></li><li><p>ICINGA<br>ICINGA 项目是 由Michael Luebben、HendrikB?cker和JoergLinge等人发起的，他们都是现有的Nagios项目社区委员会的成员，他们承诺，新的开源项 目将完全兼容以前的Nagios应用程序及扩展功能。</p></li><li><p>Graphite<br>Graphite 是一个用于采集网站实时信息并进行统计的开源项目，可用于采集多种网站服务运行状态信息。Graphite服务平均每分钟有4800次更新操作。</p></li><li><p>Kibana<br>Kibana 是一个为 Logstash 和 ElasticSearch 提供的日志分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作</p></li></ul><h2 id="微服务-容器平台"><a href="#微服务-容器平台" class="headerlink" title="微服务/容器平台"></a>微服务/容器平台</h2><ul><li><p>OpenShift<br>OpenShift 是由红帽推出的一款面向开源开发人员开放的平台即服务(PaaS)。 OpenShift通过为开发人员提供在语言、框架和云上的更多的选择，使开发人员可以构建、测试、运行和管理他们的应用。</p></li><li><p>Cloud Foundry<br>Cloud Foundry 是VMware于2011年4月12日推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发 人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</p></li><li><p>Kubernetes<br>Kubernetes 是来自 Google 云平台的开源容器集群管理系统。基于 Docker 构建一个容器的调度服务。该系统可以自动在一个容器集群中选择一个工作容器供使用。其核心概念是 Container Pod。</p></li><li><p>Mesosphere<br>Apache Mesos 是一个集群管理器，提供了有效的、跨分布式应用或框架的资源隔离和共享，可以运行Hadoop、MPI、Hypertable、Spark。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Example Post using Keynote Layout</title>
      <link href="2015/07/09/js-module-7day/"/>
      <url>2015/07/09/js-module-7day/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下滑这里查看更多内容</p></blockquote><p>7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。</p><p>于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验</p><h3 id="Watch-Slides-→"><a href="#Watch-Slides-→" class="headerlink" title="Watch Slides →"></a><a href="http://huangxuan.me/js-module-7day">Watch Slides →</a></h3><img src="http://huangxuan.me/js-module-7day/attach/qrcode.png" width="350" height="350"/><p><small class="img-hint">你也可以通过扫描二维码在手机上观看</small></p><p>这个 Web Slides 开源在<a href="https://github.com/Huxpro/js-module-7day">我的 Github 上</a>，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目</p><h3 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h3><ul><li>第一日 上古时期 <strong><em>Module?</em></strong> 从设计模式说起</li><li>第二日 石器时代 <strong><em>Script Loader</em></strong> 只有封装性可不够，我们还需要加载</li><li>第三日 蒸汽朋克 <strong><em>Module Loader</em></strong> 模块化架构的工业革命</li><li>第四日 号角吹响 <strong><em>CommonJS</em></strong> 征服世界的第一步是跳出浏览器</li><li>第五日 双塔奇兵 <strong><em>AMD/CMD</em></strong> 浏览器环境模块化方案</li><li>第六日 精灵宝钻 <strong><em>Browserify/Webpack</em></strong> 大势所趋，去掉这层包裹！</li><li>第七日 王者归来 <strong><em>ES6 Module</em></strong> 最后的战役</li></ul><h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h3><p><a href="http://lab.hakim.se/reveal-js">Reveal.js</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Example Post With Default Header Image</title>
      <link href="2015/04/14/unix-linux-note/"/>
      <url>2015/04/14/unix-linux-note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>This document is not completed and will be updated anytime.</p></blockquote><h2 id="Catagory"><a href="#Catagory" class="headerlink" title="Catagory"></a>Catagory</h2><ol><li><a href="#unix">Unix</a><ol><li><a href="#bell-labs">Bell Labs</a></li><li><a href="#xenix">Xenix</a></li><li><a href="#bsd">BSD</a></li><li><a href="#freebsd--apple">FreeBSD &amp; Apple</a></li><li><a href="#nextstep">NeXTStep</a></li><li><a href="#darwin">Darwin</a></li><li><a href="#posix">POSIX</a></li></ol></li><li><a href="#unix-like">Unix-like</a><ol><li><a href="#single-unix-specification">Single Unix Specification</a></li><li><a href="#apple-ios">Apple iOS</a></li><li><a href="#xnu-kernel">XNU Kernel</a></li></ol></li><li><a href="#linux">Linux</a><ol><li><a href="#linux-kernel">Linux Kernel</a></li><li><a href="#gnu-project">GNU Project</a></li><li><a href="#android">Android</a></li><li><a href="#android-kernel">Android Kernel</a></li><li><a href="#android-rom">Android ROM</a></li><li><a href="#chrome-os">Chrome OS</a></li><li><a href="#chromium-os">Chromium OS</a></li></ol></li></ol><hr><h2 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h2><blockquote><p>Unix is a <strong>family</strong> of multitasking, multiuser computer OS.</p></blockquote><p>Derive from the original <strong>AT&amp;T Unix</strong>, Developed in the 1970s at <strong>Bell Labs</strong> (贝尔实验室), initially intended for use inside the <strong>Bell System</strong>.</p><ul><li><h4 id="Bell-Labs"><a href="#Bell-Labs" class="headerlink" title="Bell Labs"></a>Bell Labs</h4>Bell 和 AT&amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。</li></ul><p><strong>C 语言也是 Bell Labs 的产物</strong>，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。</p><p>AT&amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both <strong>academic</strong> (最有有名的 BSD ) and <strong>commercial</strong> (Microsoft Xenix, IBM AIX, SunOS Solaris)</p><ul><li><h4 id="Xenix"><a href="#Xenix" class="headerlink" title="Xenix"></a>Xenix</h4><p>微软 1979 年从 AT&amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 <strong>Windows NT</strong>。</p></li><li><h4 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h4></li></ul><p><strong>Barkeley Software Distribution</strong>, also called Berkeley Unix. Today the term “BSD” is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)<br>    - <strong>BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议</strong>，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple’s OS X and iOS ）<br>    - BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。</p><ul><li><h4 id="FreeBSD-amp-Apple"><a href="#FreeBSD-amp-Apple" class="headerlink" title="FreeBSD &amp; Apple"></a>FreeBSD &amp; Apple</h4><p>FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 <strong>Darwin</strong> ，这个“达尔文”居然还是个开源系统，而且是 the Core of <strong>Mac OS X</strong> and <strong>iOS</strong>.</p></li><li><h4 id="NeXTSTEP"><a href="#NeXTSTEP" class="headerlink" title="NeXTSTEP"></a>NeXTSTEP</h4><p>An <strong>object-oriented</strong>, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an <strong>OO aplication layer</strong> and including several “kits”.<br>大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 <strong>NeXTSTEP 绝对是证明 Jobs 实力的作品。</strong></p></li><li><h4 id="Darwin"><a href="#Darwin" class="headerlink" title="Darwin"></a>Darwin</h4><p><a href="http://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a>, the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of <strong>POSIX</strong>. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)  </p></li></ul><p><strong>所以说 Mac OS X 算是很正统 Unix 的了</strong></p><ul><li><h4 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h4>可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.<ul><li>Fully POSIX compliant:<ul><li>OS X</li><li>QNX OS (BlackBerry)</li></ul></li><li>Mostly complicant:<ul><li>Linux</li><li>OpenBSD/FreeBSD</li><li>Darwin (Core of <strong>iOS</strong> &amp; OS X)</li><li><strong>Android</strong></li></ul></li><li>Complicant via compatibility feature （通过兼容功能实现兼容）<ul><li>Windows NT Kernel<ul><li>Windows Server 2000, 2003, 2008, 2008 R2, 2012</li></ul></li><li>Symbian OS (with PIPS)<ul><li>Symbian was a closed-source OS.</li></ul></li></ul></li></ul></li></ul><hr><h2 id="Unix-like"><a href="#Unix-like" class="headerlink" title="Unix-like"></a>Unix-like</h2><blockquote><p>A Unix-like (sometimes referred to as UN<em>X or *nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the *</em>Single UNIX Specification**.</p></blockquote><p>There is no standard for defining the term.<br>其实 Unix-like 是个相对模糊的概念：</p><ul><li>最狭义的 Unix 单指 Bell Labs’s Unix</li><li>稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X</li><li>最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等</li></ul><h4 id="Single-UNIX-Specification"><a href="#Single-UNIX-Specification" class="headerlink" title="Single UNIX Specification"></a>Single UNIX Specification</h4><p>The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to <strong>qualify for the name “Unix”</strong>, like <strong>POSIX</strong>.</p><h4 id="Apple-iOS"><a href="#Apple-iOS" class="headerlink" title="Apple iOS"></a>Apple iOS</h4><p>iOS is a <strong>Unix-like OS based on Darwin(BSD)</strong> and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, <strong>making iOS not fully Unix-compatible either.</strong></p><p>The iOS kernal is <strong>XNU</strong>, the kernal of Darwin.</p><h4 id="XNU-Kernel"><a href="#XNU-Kernel" class="headerlink" title="XNU Kernel"></a>XNU Kernel</h4><p>XNU, the acronym(首字母缩写) for <strong><em>X is Not Unix</em></strong>, which is the <strong>Computer OS Kernel</strong> developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.</p><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><blockquote><p>Linux is a Unix-like and mostly POSIX-compliant computer OS.</p></blockquote><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png" alt="Unix_timeline"></p><h4 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h4><p>严格来讲，术语 Linux 只表示 <a href="http://en.wikipedia.org/wiki/Linux_kernel">Linux Kernel</a> 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。</p><p>但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）</p><p>这类操作系统也被称为 <strong>GNU/Linux</strong></p><h4 id="GNU-Project"><a href="#GNU-Project" class="headerlink" title="GNU Project"></a>GNU Project</h4><p>The GNU Project is a <strong>free software, mass collaboration</strong> project, which based on the following freedom rights:</p><ul><li>Users are free to run the software, share (copy, distribute), study and modify it.</li><li>GNU software guarantees these freedom-rights legally (via its license).</li><li>So it is not only FREE but, more important, FREEDOM.</li></ul><p>In order to ensure that the <em>entire</em> software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, <strong>the operating system</strong>, needed to be written.</p><p>This OS is decided to called <strong>GNU (a recursive acronym meaning “GNU is not Unix”)</strong>. By 1992, the GNU Project had completed all of the major OS components except for their kernel, <em>GNU Hurd</em>.</p><p>With the release of the third-party <strong>Linux Kernel</strong>, started independently by <em>Linus Torvalds</em> in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS <strong>composed completely of free software</strong>.</p><p>Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.</p><p>Anyway, there eventually comes to the <strong>GNU/Linux</strong></p><ul><li><strong>GPL</strong>: GNU General Public License</li><li><strong>GCC</strong>: GNU Compiler Collection</li></ul><p>其他与 GPL 相关的自由/开源软件公共许可证：</p><ul><li><a href="http://en.wikipedia.org/wiki/Mozilla_Public_License">Mozilla Public License</a></li><li><a href="http://en.wikipedia.org/wiki/MIT_License">MIT License</a></li><li><a href="http://en.wikipedia.org/wiki/BSD_licenses">BSD Public License</a><ul><li>GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭</li></ul></li><li><a href="http://en.wikipedia.org/wiki/Apache_License">Apache License</a></li></ul><p><img src="http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png" alt="Public License"></p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>Android is a mobile OS based on <strong>Linux Kernel</strong>, so it’s definitely <strong>Unix-like</strong>.  </p><p><strong>Linux is under GPL so Android has to be open source</strong>.<br>Android’s source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google <em>(GMS are all proprietary)</em>  </p><h4 id="Android-Kernel"><a href="#Android-Kernel" class="headerlink" title="Android Kernel"></a>Android Kernel</h4><p>Android’s kernel is based on one of the Linux kernel’s long-term support (LTS) branches.   </p><p><strong>Android’s variant of the Linux kernel</strong> has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.</p><p>Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。</p><h4 id="Android-ROM"><a href="#Android-ROM" class="headerlink" title="Android ROM"></a>Android ROM</h4><p>既然提到 Android 就不得不提提 Android ROM</p><p>ROM 的本义实际上是只读内存：  </p><p><strong>Read-only memory</strong> (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is <strong>mainly used to distribute firmware (固件)</strong> (software that is very closely tied to specific hardware, and unlikely to need frequent updates).</p><p>ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash  </p><ul><li>PROM (Programmable read-only memory)</li><li>EPROM (Erasable programmable read-only memory)</li><li>EEPROM (Electrically erasable programmable read-only memory)<ul><li>Flash memory (闪存)</li></ul></li></ul><p>Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。</p><p>所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。</p><p>所以在 wiki 里是没有 Android ROM 这个词条的，只有 <a href="http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares">List of custom Android firmwares</a></p><blockquote><p>A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.</p></blockquote><p>各类 Android ROM 在 Android 词类下也都是属于 <strong>Forks and distributions</strong> 一类的。</p><p>所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……<strong>其实 ROM 和 Distribution OS 的界限是很模糊的</strong>，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？</p><h4 id="Chrome-OS"><a href="#Chrome-OS" class="headerlink" title="Chrome OS"></a>Chrome OS</h4><p>Chrome OS is an operating system based on the <strong>Linux kernel</strong> and designed by Google to work with web applications and installed applications.</p><p>虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……</p><ul><li><strong>Chrome Packaged Application</strong> (Support working offline and installed)</li><li><strong>Android App Runtime</strong> (run Android applications natively…fxxking awesome)</li></ul><p>平复一下激动的心情，还是回到正题来：</p><h4 id="Chromium-OS"><a href="#Chromium-OS" class="headerlink" title="Chromium OS"></a>Chromium OS</h4><p>Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a <strong>Linux distribution</strong> designed by Google.</p><p>For Detail, Chromium OS based on <a href="http://en.wikipedia.org/wiki/Gentoo_Linux">Gentoo Linux</a>, emm…</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Example Post</title>
      <link href="2014/09/22/js-version/"/>
      <url>2014/09/22/js-version/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 有着很奇怪的命名史。</p><p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p><p><img src="javascript-java.jpg" alt="java-javascript"><br><small class="img-hint">歪果仁的笑话怎么一点都不好笑</small></p><blockquote><p>译者注：<a href="https://en.wikipedia.org/wiki/JavaScript#History">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p></blockquote><p>1996 年，网景将 JavaScript 提交给 <a href="http://www.ecma-international.org/">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p><blockquote><p>术语（译者注）：</p><ul><li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li><li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li></ul></blockquote><p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p><blockquote><p>译者注：<a href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href="https://en.wikipedia.org/wiki/ActionScript">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p></blockquote><p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p><p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href="https://github.com/wycats/javascript-decorators">decorators（装饰者）</a>，<a href="https://github.com/lukehoban/ecmascript-asyncawait">async-await（async-await 异步编程模型）</a> 和 <a href="https://github.com/jeffmo/es-class-properties">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href="https://babeljs.io/docs/usage/experimental/">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p><p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p><ul><li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li><li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li><li>**ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li><li>**ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href="http://kangax.github.io/compat-table/es6/">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li><li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li><li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li></ul><p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p><h4 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h4><ul><li>TC39 的 <a href="https://github.com/tc39/ecma262">Github 仓库</a>上可以看到所有目前公开的提案</li><li>如果你还不熟悉 ES6，Babel 有一个<a href="https://babeljs.io/docs/learn-es2015/">很不错的特性概览</a></li><li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href="http://exploringjs.com/">Exploring ES6</a>和 Nicholas Zakas 的 <a href="https://leanpub.com/understandinges6">Understanding ECMAScript 6</a>。Axel 的博客 <a href="http://www.2ality.com/">2ality</a> 也是很不错的 ES6 资源</li></ul><img class="shadow" width="320" src="keep-calm-and-learn-javascript.png" /><small class="img-hint">来学 JavaScript 吧！</small><h4 id="著作权声明"><a href="#著作权声明" class="headerlink" title="著作权声明"></a>著作权声明</h4><p>本文译自 <a href="http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href="http://weibo.com/huxpro">黄玄</a>，首次发布于 <a href="http://huangxuan.me/">Hux Blog</a>，转载请保留以上链接</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Hux Blog</title>
      <link href="2014/01/29/hello-2015/"/>
      <url>2014/01/29/hello-2015/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“Yeah It’s on. ”</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hux 的 Blog 就这么开通了。</p><p><a href="#build">跳过废话，直接看技术实现 </a></p><p>2015 年，Hux 总算有个地方可以好好写点东西了。</p><p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p><p>在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的<a href="http://huangxuan.me/portfolio">个人网站</a>是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！</p><p id = "build"></p>---<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p><p>正好之前就有关注过 <a href="https://pages.github.com/">GitHub Pages</a> + <a href="http://jekyllrb.com/">Jekyll</a> 快速 Building Blog 的技术方案，非常轻松时尚。</p><p>其优点非常明显：</p><ul><li><strong>Markdown</strong> 带来的优雅写作体验</li><li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li><li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul><li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li></ul></li><li>Jekyll 的自定制非常容易，基本就是个模版引擎</li></ul><p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href="http://huxpro.gitcafe.io/">镜像</a>出来，结果还是巨慢。</p><p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。</p><hr><p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手</p><p>大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）</p><p>本地调试环境需要 <code>gem install jekyll</code>，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功</p><p>Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），<strong>不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……</strong>所以为了体验，也补了不少 CSS 进去</p><p>最后就进入了耗时反而最长的<strong>做图、写字</strong>阶段，也算是进入了<strong>写博客</strong>的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。</p><p>第二天考虑中文字体的渲染，fork 了 <a href="http://www.typeisbeautiful.com/">Type is Beautiful</a> 的 <code>font</code> CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。</p><p>在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。</p><p>如果你恰好逛到了这里，希望你也能喜欢这个博客主题。</p><p>—— Hux 后记于 2015.10</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Example Post with Code Highlight</title>
      <link href="2013/05/25/js-module-loader/"/>
      <url>2013/05/25/js-module-loader/</url>
      
        <content type="html"><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><blockquote><p>Here comes Module!</p></blockquote><p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p><p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p><hr><h2 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h2><ol><li><a href="#commonjs--node">CommonJS &amp; Node</a></li><li><a href="#history">History</a></li><li><a href="#requirejs--amd">RequireJS &amp; AMD</a></li><li><a href="#seajs--cmd">SeaJS &amp; CMD</a></li><li><a href="#amd-vs-cmd">AMD vs CMD</a></li><li><a href="#webpack">WebPack</a></li></ol><pre><code>function autoDetect()&#123;    console.log(&#39;ye, it is written in JavaScript!&#39;)&#125;</code></pre><h2 id="CommonJS-amp-Node"><a href="#CommonJS-amp-Node" class="headerlink" title="CommonJS &amp; Node"></a>CommonJS &amp; Node</h2><blockquote><p>Javascript: not just for browsers any more! —— CommonJS Slogen</p></blockquote><p>前端模块化的事实标准之一，2009 年 8 月，<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a> 诞生。</p><p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p><p>让我们看看 Node 中的实现：</p><pre><code>&#x2F;&#x2F; 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper&#x2F;&#x2F; &quot;as though the module was wrapped in a function&quot;var a &#x3D; require(&#39;.&#x2F;a&#39;)  &#x2F;&#x2F; 加载模块（同步加载）a.doSomething()         &#x2F;&#x2F; 等上一句执行完才会执行exports.b &#x3D; function(){ &#x2F;&#x2F; 暴露 b 函数接口  &#x2F;&#x2F; do something}</code></pre><p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p><p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p><p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p><ul><li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li><li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li><li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li></ul><p>本文接下来要讨论的典例是：</p><ul><li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li><li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li></ul><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><!--<h2 id="history"> History </h2>--><blockquote><p>此段落参考自玉伯的 <a href="https://github.com/seajs/seajs/issues/588">前端模块化开发那点历史</a></p></blockquote><p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href="http://wiki.commonjs.org/wiki/Modules">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p><p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p><ol><li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href="http://wiki.commonjs.org/wiki/Modules/Transport">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li><li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">AMD</a> 规范及其实现 <a href="http://requirejs.org/">RequireJS</a>。这个稍后再细说。</li><li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li></ol><p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p><h2 id="RequireJS-amp-AMD"><a href="#RequireJS-amp-AMD" class="headerlink" title="RequireJS &amp; AMD"></a>RequireJS &amp; AMD</h2><p><a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p><blockquote><p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p></blockquote><p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p><script src="//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php"></script><blockquote><p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p></blockquote><p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p><iframe scrolling="no" width="[width]" height="[height]" src="https://jsfiddle.net/shorttag/embedded/[tabs]/[skin]" frameborder="0" loading="lazy" allowfullscreen></iframe><p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>require<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> dependency1 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'dependency1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        dependency2 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'dependency2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'require'</span><span class="token punctuation">,</span> <span class="token string">'dependency1'</span><span class="token punctuation">,</span> <span class="token string">'dependency2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>require<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> dependency1 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'dependency1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        dependency2 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'dependency2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p><p>AMD 和 CommonJS 的核心争议如下：</p><h3 id="1-执行时机"><a href="#1-执行时机" class="headerlink" title="1. 执行时机"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./a"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行到此时，a.js 才同步下载并执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>AMD: （使用 require 的语法糖时）</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"require"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在这里，a.js 已经下载并且执行好了</span>    <span class="token comment" spellcheck="true">// 使用 require() 并不是 AMD 的推荐写法</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./a"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 此处仅仅是取模块 a 的 exports</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p><p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p><h3 id="2-书写风格"><a href="#2-书写风格" class="headerlink" title="2. 书写风格"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提前申明了并初始化了所有模块</span>    <span class="token boolean">true</span> <span class="token operator">||</span> b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//即便根本没用到模块 b，但 b 还是提前执行了。</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p><p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 函数体内：</span><span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SeaJS-amp-CMD"><a href="#SeaJS-amp-CMD" class="headerlink" title="SeaJS &amp; CMD"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href="http://seajs.org/docs/">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p><p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p><ul><li>CMD Specification<ul><li><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md">English (CMDJS-repo)</a></li><li><a href="https://github.com/seajs/seajs/issues/242">Chinese (SeaJS-repo)</a></li></ul></li></ul><p>CMD 主要有 define, factory, require, export 这么几个东西</p><ul><li>define <code>define(id?, deps?, factory)</code></li><li>factory <code>factory(require, exports, module)</code></li><li>require <code>require(id)</code></li><li>exports <code>Object</code></li></ul><p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p><ul><li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span> exports<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取模块 a 的接口</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用模块 a 的方法</span>    a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对外提供 foo 属性</span>    exports<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对外提供 doSomething 方法</span>    exports<span class="token punctuation">.</span>doSomething <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'jquery'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 模块代码...</span>    <span class="token comment" spellcheck="true">// 直接通过 return 暴露接口</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        foo<span class="token punctuation">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span>        doSomething<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p><h2 id="AMD-vs-CMD"><a href="#AMD-vs-CMD" class="headerlink" title="AMD vs CMD"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li></ol><ul><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。   </li></ul><p>看代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// AMD 默认推荐</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./a'</span><span class="token punctuation">,</span> <span class="token string">'./b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 依赖前置，提前执行</span>    a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// CMD</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span>    a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 依赖就近，延迟执行</span>    b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="WebPack"><a href="#WebPack" class="headerlink" title="WebPack"></a>WebPack</h2><blockquote><p>working…</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
