<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown快速入门</title>
      <link href="2022/07/30/yuque/dgegwt/"/>
      <url>2022/07/30/yuque/dgegwt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。</p><p>Markdown 具有很多优点：</p><ul><li>写作中添加简单符号即完成排版，所见即所得。让你专注于文字而不是排版。</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf 等。</li><li>可以保存称纯文本</li></ul></blockquote><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>标题能显示出文章的结构。行首插入 1-6 个# ，每增加一个#表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p><p>注：标准语法一般在#后跟个空格再写文字</p><p><strong>示例：</strong></p><pre class="line-numbers language-latex"><code class="language-latex">Atx风格# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，Markdown 还支持另外一种标题展示形式，使用下划线进行文本大小的控制</p><pre class="line-numbers language-latex"><code class="language-latex">SetText风格这是一级标题===这是二级标题---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题</p><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h2><h3 id="2-1-基本样式"><a href="#2-1-基本样式" class="headerlink" title="2.1 基本样式"></a>2.1 基本样式</h3><p>要加粗的文字左右分别用两个*号包起来<br><strong>加粗</strong></p><p>要倾斜的文字左右分别用一个*号包起来<br><em>斜体\</em></p><p>要倾斜和加粗的文字左右分别用三个*号包起来<br><strong><em>斜体加粗</em></strong></p><p>要加删除线的文字左右分别用两个<del>号包起来<br>~</del>删除线~~</p><p>要加删除线的文字左右分别用两个==号包起来<br>==高亮==</p><p><strong>示例：</strong><br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del><br>这是加粗的文字</p><h3 id="2-2-常用转义字符"><a href="#2-2-常用转义字符" class="headerlink" title="2.2 常用转义字符"></a>2.2 常用转义字符</h3><p>MarkDown 利用了很多特殊符号标识语法，但在需要输入这些符号就需要利用转义字符来控制，避免 MarkDown 语法解析。</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\\</span> 反斜杠<span class="token function selector">\`</span> 反引号<span class="token function selector">\*</span> 星号<span class="token function selector">\_</span> 下划线<span class="token function selector">\&amp;</span>#123;<span class="token function selector">\&amp;</span>#125; 大括号<span class="token equation string">\[\]</span> 中括号<span class="token equation string">\(\)</span> 小括号<span class="token function selector">\#</span> 井号<span class="token function selector">\+</span> 加号<span class="token function selector">\-</span> 减号<span class="token function selector">\.</span> 英文句号<span class="token function selector">\!</span> 感叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-添加空格"><a href="#2-3-添加空格" class="headerlink" title="2.3 添加空格"></a>2.3 添加空格</h3><p>跟 word 等其他编辑器不同，Markdown 只能识别一个空格（在半角输入状态下）, 有下面两个解决方案。</p><ul><li>手动输入空格 （ ；）。<strong>注意！</strong>此时的分号为英文分号，但是不推荐使用此方法，太麻烦！</li><li>使用全角空格。即：在全角输入状态下直接使用空格键就 ok 了</li></ul><h3 id="2-4-字体颜色"><a href="#2-4-字体颜色" class="headerlink" title="2.4 字体颜色"></a>2.4 字体颜色</h3><p>使用 Markdown 的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown 的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用 Markdown 设置文字颜色已经做不到了。但你可以这样做：</p><p><strong>示例：</strong><br>字体颜色</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p><strong>语法：</strong></p><p><strong>单行代码</strong>：代码之间分别用一个反引号包起来<br><code>代码内容</code></p><p><strong>代码块</strong>：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><pre><code>代码...代码...代码...</code></pre><p><strong>示例：</strong></p><p>单行代码<br><code>create database hero;</code></p><p>代码块</p><pre class="line-numbers language-shell"><code class="language-shell">    function fun()&#123;         echo "这是一句非常牛逼的代码";    &#125;    fun();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">@requires_authorization<span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># A comment</span>    <span class="token keyword">print</span> <span class="token string">'hello world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-段落-amp-引用"><a href="#4-段落-amp-引用" class="headerlink" title="4. 段落&amp;引用"></a>4. 段落&amp;引用</h2><h2 id="4-1-段落"><a href="#4-1-段落" class="headerlink" title="4.1 段落"></a>4.1 段落</h2><ul><li>换行是在行尾加两个空格 [空格 + 空格 + 回车]</li></ul><h2 id="4-2-引用"><a href="#4-2-引用" class="headerlink" title="4.2 引用"></a>4.2 引用</h2><p>Markdown 提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示</p><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;，三个&gt;&gt;&gt;，n 个…</p><p><strong>示例：</strong></p><blockquote><p>这是引用的内容</p></blockquote><blockquote><p>这是引用的内容</p></blockquote><blockquote></blockquote><blockquote><p>这是引用的内容</p></blockquote><h3 id="4-3-分割线"><a href="#4-3-分割线" class="headerlink" title="4.3 分割线"></a>4.3 分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><h2 id="5-插入图片-amp-链接"><a href="#5-插入图片-amp-链接" class="headerlink" title="5.   插入图片&amp;链接"></a>5.   插入图片&amp;链接</h2><h3 id="5-1-插入图片"><a href="#5-1-插入图片" class="headerlink" title="5.1 插入图片"></a>5.1 插入图片</h3><p><strong>语法：</strong></p><p><strong>Inline</strong> (titles are optional):</p><p><code>![alt text](/path/img.jpg &quot;Title&quot;)</code></p><p><strong>Reference-style:</strong></p><p><code>![alt text][id]</code></p><ul><li>alt- 就是显示在图片下面的文字，相当于对图片内容的解释。</li><li>title- 是图片的标题，当鼠标移到图片上时显示的内容。title 可加可不加</li></ul><p><strong>示例：</strong><br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&fm=27&gp=0.jpg#crop=0&crop=0&crop=1&crop=1&id=xhJCM&originHeight=300&originWidth=550&originalType=binary%E2%88%B6=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%8C%BA%E5%9D%97%E9%93%BE" alt="区块链" title="区块链"></p><p><img src="https://www.zybuluo.com/static/img/logo.png#crop=0&crop=0&crop=1&crop=1&id=Bqrb1&originHeight=256&originWidth=256&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928231653.JPG#crop=0&crop=0&crop=1&crop=1&id=Ms6LO&originHeight=297&originWidth=299&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。</strong></p><h3 id="5-2-插入链接"><a href="#5-2-插入链接" class="headerlink" title="5.2 插入链接"></a>5.2 插入链接</h3><p><strong>Inline:</strong><br><code>An [example](http://url.com/ &quot;Title&quot;)</code></p><p><a href="http://www.baidu.com/">点击跳转至百度</a></p><h4 id="点击跳转至必应"><a href="#点击跳转至必应" class="headerlink" title="点击跳转至必应"></a><a href="http://www.bing.com/">点击跳转至必应</a></h4><p><strong>Reference-style labels</strong> (titles are optional):</p><p><code>An [example][id]. Then, anywhere else in the doc, define the link: [id]: http://example.com/ &quot;Title&quot;</code></p><p>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].</p><p><strong>Email:</strong><br>&lt;&gt;包括的 URL 或邮箱地址会被自动转换成为超链接</p><p><code>An email &lt;example@example.com&gt; link.</code></p><p><a href="mailto:xxxxxx@126.com">xxxxxx@126.com</a></p><h2 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h2><h2 id="6-1-无序列表"><a href="#6-1-无序列表" class="headerlink" title="6.1 无序列表"></a>6.1 无序列表</h2><p><strong>语法:</strong><br>无序列表用 - + * 任何一种都可以</p><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想<ul><li>撰写发布技术文稿（无序列表内嵌列表空二个空格）</li><li>撰写发布学术论文</li></ul></li></ul><p>注意：- + *跟内容之间都要有一个空格;<strong>整篇文档无序列表符号必须一致</strong></p><h3 id="6-2-有序列表"><a href="#6-2-有序列表" class="headerlink" title="6.2 有序列表"></a>6.2 有序列表</h3><p><strong>语法：</strong><br>数字加点</p><ol><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ol><p>注意：序号跟内容之间要有空格</p><h3 id="6-3-列表嵌套"><a href="#6-3-列表嵌套" class="headerlink" title="6.3 列表嵌套"></a>6.3 列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><ol><li>Fruit<ol><li>Apple</li><li>Orange</li><li>Peach</li><li>Banana</li></ol></li><li>Vegetable</li></ol><h3 id="6-4-列表-引用"><a href="#6-4-列表-引用" class="headerlink" title="6.4 列表+引用"></a>6.4 列表+引用</h3><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><ul><li><p><input disabled="" type="checkbox">  支持以 PDF 格式导出文稿</p></li><li><p><input disabled="" type="checkbox">  改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</p></li><li><p><input checked="" disabled="" type="checkbox">  新增 Todo 列表功能</p></li><li><p><input checked="" disabled="" type="checkbox">  修复 LaTex 公式渲染问题</p></li><li><p><input checked="" disabled="" type="checkbox">  新增 LaTex 公式编号功能</p></li><li><p>段落一</p><blockquote><p>This module implements a number of iterator building blocks inspired by constructs from APL, Haskell, and SML. Each has been recast in a form suitable for Python.</p></blockquote></li><li><p>段落二</p><blockquote><p>区块标记二</p></blockquote></li></ul><h2 id="7-表格"><a href="#7-表格" class="headerlink" title="7. 表格"></a>7. 表格</h2><p><strong>语法：</strong></p><pre class="line-numbers language-latex"><code class="language-latex">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注：三个短横杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p><p>示例：</p><pre class="line-numbers language-latex"><code class="language-latex">姓名|技能|排行:--|:--|:--刘备|哭|大哥关羽|打|二哥张飞|骂|三弟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-latex"><code class="language-latex">| 项目        | 价格   |  数量  || --------   | -----:  | :----:  || 计算机     | \<span class="token equation string">$1600 |   5     || 手机        |   <span class="token equation-command regex">\$</span>12   |   12   || 管线        |    <span class="token equation-command regex">\$</span></span>1    |  234  |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkdownLint错误问题解释</title>
      <link href="2022/07/30/yuque/ig16if/"/>
      <url>2022/07/30/yuque/ig16if/</url>
      
        <content type="html"><![CDATA[<p>使用 VSCode 编写 Markdown 文件时，建议安装插件<code>markdownlint</code>，它可以帮助自己更加规范的写文章.</p><p>下面是所有的 markdown 语法错误信息以便纠错。</p><h2 id="MD001-Heading-levels-should-only-increment-by-one-level-at-a-time"><a href="#MD001-Heading-levels-should-only-increment-by-one-level-at-a-time" class="headerlink" title="MD001 - Heading levels should only increment by one level at a time"></a>MD001 - Heading levels should only increment by one level at a time</h2><p>标题级数只能每次扩大一个，也就是说不能隔级创建标题，必须 h1-h2-h3…这样</p><h2 id="MD002-First-heading-should-be-a-top-level-heading"><a href="#MD002-First-heading-should-be-a-top-level-heading" class="headerlink" title="MD002 - First heading should be a top level heading"></a>MD002 - First heading should be a top level heading</h2><p>文档的第一个标题必须是最高级的标题（标题等级 1 级到 6 级逐渐降低）</p><p>参数： <code>&quot;level&quot;：指定最高级标题的级数，默认是1</code></p><h2 id="MD003-Heading-style"><a href="#MD003-Heading-style" class="headerlink" title="MD003 - Heading style"></a>MD003 - Heading style</h2><p>整篇文档要采用一致的标题格式</p><pre class="line-numbers language-latex"><code class="language-latex">参数："style"：字符串，指定文档标题的格式，有("consistent", "atx", "atx_closed", "setext", "setext_with_atx", "setext_with_atx_closed")五种，默认是"consistent"，也就是整篇文档一致标题格式必须统一，一般不能混用，但"setext_with_atx", "setext_with_atx_closed"格式可以在"setext"格式二级标题后接着使用"atx"或"atx_closed"格式的标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD004-Unordered-list-style"><a href="#MD004-Unordered-list-style" class="headerlink" title="MD004 - Unordered list style"></a>MD004 - Unordered list style</h2><p>整篇文档的无序列表的格式要一致</p><pre class="line-numbers language-latex"><code class="language-latex">参数："style"：字符串，指定无序列表的定义格式，有("consistent", "asterisk", "plus", "dash", "sublist")五种，分别表示“定义时符号前后一致”，“用星号定义”，“用加号定义”，“用减号定义”，“定义多重列表时用不同的符号定义”，默认是"consistent"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD005-Inconsistent-indentation-for-list-items-at-the-same-level"><a href="#MD005-Inconsistent-indentation-for-list-items-at-the-same-level" class="headerlink" title="MD005 - Inconsistent indentation for list items at the same level"></a>MD005 - Inconsistent indentation for list items at the same level</h2><p>同一个等级的列表的缩进要一致;在有序列表中，前面的数字序号可以左对齐，也可以右对齐</p><h2 id="MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line"><a href="#MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line" class="headerlink" title="MD006 - Consider starting bulleted lists at the beginning of the line"></a>MD006 - Consider starting bulleted lists at the beginning of the line</h2><p>一级标题不能够缩进</p><h2 id="MD007-Unordered-list-indentation"><a href="#MD007-Unordered-list-indentation" class="headerlink" title="MD007 - Unordered list indentation"></a>MD007 - Unordered list indentation</h2><p>无序列表嵌套的时候默认采取两个空格的缩进方式</p><pre class="line-numbers language-latex"><code class="language-latex">参数："ident"：指定无序列表嵌套时缩进的空格数，默认是2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD008-无"><a href="#MD008-无" class="headerlink" title="MD008 - 无"></a>MD008 - 无</h2><h2 id="MD009-Trailing-spaces"><a href="#MD009-Trailing-spaces" class="headerlink" title="MD009 - Trailing spaces"></a>MD009 - Trailing spaces</h2><p>行尾最多可以添加两个空格，超出之后会有警告，最好每次都是两个空格因为两个空格刚好可以用来换行</p><pre class="line-numbers language-latex"><code class="language-latex">参数："br_spaces"：指定在行尾可以添加的空格数目，空格数目建议大于等于2，如果小于2，会默认为0，也就是不允许任何行尾的空格"list_item_empty_lines"：字符串，指定在列表中是否(true or false)用默认的空格数缩进空行，有的解释器会要求列表中的空行要缩进<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="MD010-Hard-tabs"><a href="#MD010-Hard-tabs" class="headerlink" title="MD010 - Hard tabs"></a>MD010 - Hard tabs</h2><p>不能使用 tab 来进行缩进，要使用空格</p><pre class="line-numbers language-latex"><code class="language-latex">参数："code_blocks"：指定本条规则在代码块里是否(true or false)生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD011-Reversed-link-syntax"><a href="#MD011-Reversed-link-syntax" class="headerlink" title="MD011 - Reversed link syntax"></a>MD011 - Reversed link syntax</h2><p>内联形式的链接和创建方式是否错误，中括号和圆括号是否使用正确</p><h2 id="MD012-Multiple-consecutive-blank-lines"><a href="#MD012-Multiple-consecutive-blank-lines" class="headerlink" title="MD012 - Multiple consecutive blank lines"></a>MD012 - Multiple consecutive blank lines</h2><p>文档中不能有连续的空行（文档末可以有一个空行），在代码块中这个规则不会生效</p><pre class="line-numbers language-latex"><code class="language-latex">参数："maximum"：指定文档中可以连续的最多空行数，默认值是1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD013-Line-length"><a href="#MD013-Line-length" class="headerlink" title="MD013 - Line length"></a>MD013 - Line length</h2><p>默认行的最大长度是 80，此规则对代码块、表格、标题也生效</p><pre class="line-numbers language-latex"><code class="language-latex">参数："line_length"：指定行的最大长度，默认是80"heading_line_length"：指定标题行的最大长度，默认是80"code_blocks"：指定规则是否(true or false)对代码块生效，默认true"tables"：指定规则是否(true or false)对表格生效，默认true"hesdings"：指定规则是否(true or false)对标题生效，默认true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD014-Dollar-signs-used-before-commands-without-showing-output"><a href="#MD014-Dollar-signs-used-before-commands-without-showing-output" class="headerlink" title="MD014 - Dollar signs used before commands without showing output"></a>MD014 - Dollar signs used before commands without showing output</h2><p>在代码块中，终端命令前不需要有美元符号(<img src="https://g.yuque.com/gr/latex">%0A%E5%A6%82%E6%9E%9C%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD%E6%97%A2%E6%9C%89%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E6%9C%89%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BE%93%E5%87%BA%EF%BC%8C%E5%88%99%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%89%8D%E5%8F%AF%E4%BB%A5%E6%9C%89%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7(#card=math&amp;code=%29%0A%E5%A6%82%E6%9E%9C%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD%E6%97%A2%E6%9C%89%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E6%9C%89%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BE%93%E5%87%BA%EF%BC%8C%E5%88%99%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%89%8D%E5%8F%AF%E4%BB%A5%E6%9C%89%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%28&amp;id=FHhPp))，如：</p><pre class="line-numbers language-shell"><code class="language-shell">$ lsfoo bar$ cat foohello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD018-No-space-after-hash-on-atx-style-heading"><a href="#MD018-No-space-after-hash-on-atx-style-heading" class="headerlink" title="MD018 - No space after hash on atx style heading"></a>MD018 - No space after hash on atx style heading</h2><p>标题格式如果是”atx”的话，#号和文字之间需要一个空格隔开</p><h2 id="MD019-Multiple-spaces-after-hash-on-atx-style-heading"><a href="#MD019-Multiple-spaces-after-hash-on-atx-style-heading" class="headerlink" title="MD019 - Multiple spaces after hash on atx style heading"></a>MD019 - Multiple spaces after hash on atx style heading</h2><p>标题格式如果是”atx”的话，#号和文字之间只需要一个空格隔开，不需要多个</p><h2 id="MD020-No-space-inside-hashes-on-closed-atx-style-heading"><a href="#MD020-No-space-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD020 - No space inside hashes on closed atx style heading"></a>MD020 - No space inside hashes on closed atx style heading</h2><p>在 closed_atx 格式的标题中，文字和前后的#号之间都需要一个空格隔开</p><h2 id="MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading"><a href="#MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD021 - Multiple spaces inside hashes on closed atx style heading"></a>MD021 - Multiple spaces inside hashes on closed atx style heading</h2><p>在 closed_atx 格式的标题中，文字和前后的#号之间只需要一个空格隔开，不能有多余的</p><h2 id="MD022-Headings-should-be-surrounded-by-blank-lines"><a href="#MD022-Headings-should-be-surrounded-by-blank-lines" class="headerlink" title="MD022 - Headings should be surrounded by blank lines"></a>MD022 - Headings should be surrounded by blank lines</h2><p>标题的上下行必须都是空格</p><pre class="line-numbers language-latex"><code class="language-latex">参数："lines_above"：指定标题行上方的空行数，默认为1，可以设为更大或0"lines_below"：指定标题行下方的空行数，默认为1，可以设为更大或0注意当此处的空行设为比1大的数时，规则MD012的设置也要改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD023-Headings-must-start-at-the-beginning-of-the-line"><a href="#MD023-Headings-must-start-at-the-beginning-of-the-line" class="headerlink" title="MD023 - Headings must start at the beginning of the line"></a>MD023 - Headings must start at the beginning of the line</h2><p>标题行不能缩进</p><h2 id="MD024-Multiple-headings-with-the-same-content"><a href="#MD024-Multiple-headings-with-the-same-content" class="headerlink" title="MD024 - Multiple headings with the same content"></a>MD024 - Multiple headings with the same content</h2><p>在文档中不能有重复性的标题</p><pre class="line-numbers language-latex"><code class="language-latex">参数："siblings_only"：默认为false，设为true时，不同标题下的子标题内容可以重复<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD025-Multiple-top-level-headings-in-the-same-document"><a href="#MD025-Multiple-top-level-headings-in-the-same-document" class="headerlink" title="MD025 - Multiple top level headings in the same document"></a>MD025 - Multiple top level headings in the same document</h2><p>同一个文档中，只能有一个最高级的标题，默认也只能有一个一级标题</p><pre class="line-numbers language-latex"><code class="language-latex">参数："level"：指定文档最高级的标题，默认是1"front_matter_title"：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，如果文档中再次出现最高级标题，将会给出警告，另外，如果不想在front matter中指定标题，就把本参数的值设置为""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="MD026-Trailing-punctuation-in-heading"><a href="#MD026-Trailing-punctuation-in-heading" class="headerlink" title="MD026 - Trailing punctuation in heading"></a>MD026 - Trailing punctuation in heading</h2><p>标题的末尾不能有”. , ; : ! ? “这些符号</p><pre class="line-numbers language-latex"><code class="language-latex">参数："punctuation"：字符串，指定标题行尾不能有的标点符号，默认是".,;:!?"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此规则默认的是英文的标点符号，中文标点符号不在规则之内</p><h2 id="MD027-Multiple-spaces-after-blockquote-symbol"><a href="#MD027-Multiple-spaces-after-blockquote-symbol" class="headerlink" title="MD027 - Multiple spaces after blockquote symbol"></a>MD027 - Multiple spaces after blockquote symbol</h2><p>创建引用区块时，右尖括号 ( &gt; ) 和文字之间有且只能有一个空格</p><h2 id="MD028-Blank-line-inside-blockquote"><a href="#MD028-Blank-line-inside-blockquote" class="headerlink" title="MD028 - Blank line inside blockquote"></a>MD028 - Blank line inside blockquote</h2><p>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头</p><h2 id="MD029-Ordered-list-item-prefix"><a href="#MD029-Ordered-list-item-prefix" class="headerlink" title="MD029 - Ordered list item prefix"></a>MD029 - Ordered list item prefix</h2><p>有序列表的前缀序号格式必须只用 1 或者从 1 开始的加 1 递增数字(“one_or_ordered”)</p><pre class="line-numbers language-latex"><code class="language-latex">参数："style"：字符串，指定前缀序号的格式，("one","ordered","one_or_ordered","zero")，分别表示只用1做前缀，用从1开始的加1递增数字做前缀，只用1或者从1开始的加1递增数字做前缀，只用0做前缀，默认值是"one_or_ordered"本条规则支持在前缀序号中补0，以实现对齐，如：...08.  one09.  two10.  three...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD030-Spaces-after-list-markers"><a href="#MD030-Spaces-after-list-markers" class="headerlink" title="MD030 - Spaces after list markers"></a>MD030 - Spaces after list markers</h2><p>列表（有序、无序）的前缀符号和文字之间用 1 个空格隔开，在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进 3 个空格</p><pre class="line-numbers language-latex"><code class="language-latex">参数："ul_single","ol_single","ul_multi","ol_multi"：分别规定无序列表单个段落，有序列表单个段落，无序列表多个段落，有序列表多个段落的前缀符号和文字之间的空格数，默认是1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines"><a href="#MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines" class="headerlink" title="MD031 - Fenced code blocks should be surrounded by blank lines"></a>MD031 - Fenced code blocks should be surrounded by blank lines</h2><p>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p><h2 id="MD032-Lists-should-be-surrounded-by-blank-lines"><a href="#MD032-Lists-should-be-surrounded-by-blank-lines" class="headerlink" title="MD032 - Lists should be surrounded by blank lines"></a>MD032 - Lists should be surrounded by blank lines</h2><p>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表，列表的缩进必须一致，否则会警告</p><h2 id="MD033-Inline-HTML"><a href="#MD033-Inline-HTML" class="headerlink" title="MD033 - Inline HTML"></a>MD033 - Inline HTML</h2><p>文档中不允许使用 html 语句</p><pre class="line-numbers language-latex"><code class="language-latex">参数："allowed_elements"：自定义允许的元素，是一个字符串数组，默认是空(empty)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD034-Bare-URL-used"><a href="#MD034-Bare-URL-used" class="headerlink" title="MD034 - Bare URL used"></a>MD034 - Bare URL used</h2><p>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p><h2 id="MD035-Horizontal-rule-style"><a href="#MD035-Horizontal-rule-style" class="headerlink" title="MD035 - Horizontal rule style"></a>MD035 - Horizontal rule style</h2><p>创建水平线时整篇文档要统一，要和文档中第一次创建水平线使用的符号一致</p><pre class="line-numbers language-latex"><code class="language-latex">参数："style"：字符串，指定创建水平线的方式，值有：("consistent","***","---","___")，默认是"consistent"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD036-Emphasis-used-instead-of-a-heading"><a href="#MD036-Emphasis-used-instead-of-a-heading" class="headerlink" title="MD036 - Emphasis used instead of a heading"></a>MD036 - Emphasis used instead of a heading</h2><p>不能用强调来代替标题</p><pre class="line-numbers language-latex"><code class="language-latex">参数："punctuation"：字符串，指定用于结尾的标点符号，以此符号结尾的强调不会被视为以强调代替标题，默认值是".,;:!?"此规则会检查只包含强调的单行段落，如果这种段落不是以指定的标点符号结尾，则会被视为以强调代替标题，会给出警告<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD037-Spaces-inside-emphasis-markers"><a href="#MD037-Spaces-inside-emphasis-markers" class="headerlink" title="MD037 - Spaces inside emphasis markers"></a>MD037 - Spaces inside emphasis markers</h2><p>用于创建强调的符号和强调的的文字之间不能有空格</p><h2 id="MD038-Spaces-inside-code-span-elements"><a href="#MD038-Spaces-inside-code-span-elements" class="headerlink" title="MD038 - Spaces inside code span elements"></a>MD038 - Spaces inside code span elements</h2><p>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格，如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p><h2 id="MD039-Spaces-inside-link-text"><a href="#MD039-Spaces-inside-link-text" class="headerlink" title="MD039 - Spaces inside link text"></a>MD039 - Spaces inside link text</h2><p>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格</p><h2 id="MD040-Fenced-code-blocks-should-have-a-language-specified"><a href="#MD040-Fenced-code-blocks-should-have-a-language-specified" class="headerlink" title="MD040 - Fenced code blocks should have a language specified"></a>MD040 - Fenced code blocks should have a language specified</h2><p>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p><h2 id="MD041-First-line-in-file-should-be-a-top-level-heading"><a href="#MD041-First-line-in-file-should-be-a-top-level-heading" class="headerlink" title="MD041 - First line in file should be a top level heading"></a>MD041 - First line in file should be a top level heading</h2><p>文档的第一个非空行应该是文档最高级的标题，默认是 1 级标题</p><pre class="line-numbers language-latex"><code class="language-latex">参数："level"：指定文档最高级的标题，默认是1"front_matter_title"：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，另外，如果不想在front matter中指定标题，就把本参数的值设置为""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="MD042-No-empty-links"><a href="#MD042-No-empty-links" class="headerlink" title="MD042 - No empty links"></a>MD042 - No empty links</h2><p>链接的地址不能为空</p><h2 id="MD043-Required-heading-structure"><a href="#MD043-Required-heading-structure" class="headerlink" title="MD043 - Required heading structure"></a>MD043 - Required heading structure</h2><p>要求标题遵循一定的结构，默认是没有规定的结构</p><pre class="line-numbers language-latex"><code class="language-latex">参数："headings"：字符串数组，指定标题需要遵循的结构，默认是"null"，可以自行指定结构，如；<span class="token punctuation">[</span>    "# head",    "## item",    "## detail",    "*"<span class="token punctuation">]</span>星号(*)表示对应的标题是可选的，没有强制要求，本条具体可以参照MD043<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD044-Proper-names-should-have-the-correct-capitalization"><a href="#MD044-Proper-names-should-have-the-correct-capitalization" class="headerlink" title="MD044 - Proper names should have the correct capitalization"></a>MD044 - Proper names should have the correct capitalization</h2><p>指定一些名称，会检查它是否有正确的大写</p><pre class="line-numbers language-latex"><code class="language-latex">参数："names"：字符串数组，指定要检查需要大写的名称，默认是空("null")"code_blocks"：指定本规则是否(true or false)对代码块生效，默认是true一些经常使用的名称可以使用本规则防止其拼写错误，比如JavaScript中字母J和S需要大写，就可以写到参数"names"中，防止写错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MD045-Images-should-have-alternate-text-alt-text"><a href="#MD045-Images-should-have-alternate-text-alt-text" class="headerlink" title="MD045 - Images should have alternate text (alt text)"></a>MD045 - Images should have alternate text (alt text)</h2><p>图片链接必须包含描述文本 all 文本</p><h2 id="MD046-Code-block-style"><a href="#MD046-Code-block-style" class="headerlink" title="MD046 - Code block style"></a>MD046 - Code block style</h2><p>整篇文档采用一致的代码格式</p><pre class="line-numbers language-latex"><code class="language-latex">参数："style": 字符串，指定代码块定义格式，有（"consistent","fenced","indented"）三种，分别代表：文档上下文一致，使用三个反引号隔开，使用缩进，默认是上下文一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MD047-Files-should-end-with-a-single-newline-character"><a href="#MD047-Files-should-end-with-a-single-newline-character" class="headerlink" title="MD047 - Files should end with a single newline character"></a>MD047 - Files should end with a single newline character</h2><p>文档末尾需要一个空行结尾</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>静态博客搭建工具汇总</title>
      <link href="2022/07/26/yuque/ay63w4/"/>
      <url>2022/07/26/yuque/ay63w4/</url>
      
        <content type="html"><![CDATA[<p>Jekyll、Hugo、Hexo 是简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown 以及 Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll、Hugo、Hexo 也可以运行在 码云（Gitee.com） Pages 上，也就是说，你可以使用码云的服务来搭建你的仓库页面、博客或者网站，而且是完全免费的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1658848358448-b43bf29d-483e-4141-b33d-e37db8d3572f.png#clientId=u8bfa6167-8f05-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=u08aa7f03&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=649&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=7047&status=done&style=none&taskId=ufaa91d18-f82d-4699-8e43-09c4e98f45f&title=&width=536" alt="image.png"><br><a href="https://zhuanlan.zhihu.com/p/79515327">https://zhuanlan.zhihu.com/p/79515327</a></p><h2 id="1-Hexo"><a href="#1-Hexo" class="headerlink" title="1) Hexo"></a>1) Hexo</h2><p>Hexo 是一个基于 node.js 的静态博客生成系统，它使用 markdown 语法来写作，同时支持丰富的自定义标签系统。<br>用户在本地安装 Hexo 系统并进行写作，通过一条命令，Hexo 可以自动生成静态页面，并发布到多个平台上。<br>与传统的博客相比，Hexo 可以说是一个本地运行远程发布的博客程序。<br><a href="https://hexo.io/docs/">Hexo 使用文档：https://hexo.io/docs/</a><br><a href="https://hexo.io/themes/">hexo 主题：https://hexo.io/themes/</a><br>优点：</p><ul><li>1、搭建的博客平台，速度快，免费，可以搭建在 Github 上。</li><li>2、操作比 Jekyll 简单，命令少，易于记忆。</li><li>3.支持 markdown，Hexo 最终生成的是一个静态博客，这就意味着它拥有其他博客系统无法比拟的低负载与高速度的特性。</li></ul><p>缺点：</p><ul><li>1、每次在一台新电脑或者别人电脑首次使用时，都要重新安装和配置编译环境，不适合随时随地愉快的写博客。（</li><li>2、相对 Wordpress 而言，没有强大的后台和插件支持，学习成本较高，需要一些网页基础。</li></ul><p><strong>安装</strong><br>安装使用 hexo 之前需要先安装 Node.js 和 Git，当已经安装了 Node.js 和 npm(npm 是 node.js 的包管理工具)，可以通过以下命令安装 hexo<br><code>$ npm install -g hexo-cli</code></p><h2 id="2-Nuxt"><a href="#2-Nuxt" class="headerlink" title="2) Nuxt"></a>2) Nuxt</h2><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。Nuxt.js 的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。<br>Nuxt 更像是为构建应用程序而生的，而不是独立的内容静态网站。<br><a href="https://zh.nuxtjs.org/guide">Nuxt.js 官网</a></p><h2 id="3-Docsify"><a href="#3-Docsify" class="headerlink" title="3) Docsify"></a>3) Docsify</h2><p>Docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。<br>Docsify 是基于 Vue，完全的运行时驱动，不需要渲染 html，所以对 SEO 不够友好。如果不关注 SEO，安装简单化不想有大量依赖，他是比较好的选择，比如公司或这团队内部的文档系统。<br><a href="https://docsify.js.org/#/">docsify 官网</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1658849275439-1f7abac2-8158-4564-9b37-e774f4616d66.png#clientId=u8bfa6167-8f05-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=u6a513101&margin=%5Bobject%20Object%5D&name=image.png&originHeight=427&originWidth=678&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=110757&status=done&style=none&taskId=uff9bbc4f-79cc-41c0-98fe-868ce4bdf95&title=&width=568" alt="image.png"></p><h2 id="4-Docute"><a href="#4-Docute" class="headerlink" title="4 Docute"></a>4 Docute</h2><p>Docute 本质上就是一个 JavaScript 文件，它可以获取 Markdown 文件并将它们呈现为单页面应用。它完全由运行时驱动，因此并不涉及服务端组件，这就意味着没有构建过程。你只需创建一个 HTML 文件和一堆 Markdown 文档，你的网站就差不多完成了！<br>Docute 与 Docsify 基本一样，只是在文件大小和 UI 及不同的使用方式，Docute 网站有其差异介绍。<br><a href="https://docute.org/zh/">Docute 官网</a></p><h2 id="5-GitBook"><a href="#5-GitBook" class="headerlink" title="5 GitBook"></a>5 GitBook</h2><p>GitBook 是一个现代的文档平台，团队或个人可以在其上编写产品、API 接口文档以及团队内部知识库。<br>GitBook 改版之后，感觉的团队更专注于商业产品而不是开源工具，同时 CLI 工具不再提供了，所以无法实现个性化部署，所以不做介绍，有兴趣的可以看其官网。<br><a href="https://docs.gitbook.com/">GitBook 官网</a></p><h2 id="6-VuePress"><a href="#6-VuePress" class="headerlink" title="6 VuePress"></a>6 VuePress</h2><p>VuePress 是基于 Vue 开发的平台，功能上实现了 GitBook 功能。VuePress 展示页面与 Docsify 类似，但是与 Docsify 不同的是，预先渲染 html。<br><a href="https://vuepress.vuejs.org/zh/">VuePress 官网</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1658849319712-19cabb78-7313-4c71-8486-844a9d78c98f.png#clientId=u8bfa6167-8f05-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=372&id=u266c89ce&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=1003&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=46677&status=done&style=none&taskId=ufda8001b-1baa-48a8-93ed-44f5048e2b5&title=&width=826" alt="image.png"></p><h2 id="7-Jekeyll"><a href="#7-Jekeyll" class="headerlink" title="7) Jekeyll"></a>7) Jekeyll</h2><p>jekyll 是一个简单的免费的 Blog 生成工具，类似 WordPress。但是和 WordPress 又有很大的不同，原因是 jekyll 只是一个生成静态网页的工具，<br>不需要数据库支持。但是可以配合第三方服务,例如 Disqus。最关键的是 jekyll 可以免费部署在 Github 上，而且可以绑定自己的域名。<br><a href="http://jekyllrb.com/">官网：http://jekyllrb.com</a><br>优点：</p><ul><li>1、jekyll 是一个静态文件生成器，网站不需要数据库，只要把自己的博客放到对应的目录即可。</li><li>2、能部署到 github 或者 gitcafe 上，不需要自己的 vps，因为是静态的，迁移起来非常方便。</li><li>3、原生支持 markdown。现在 github 默认支持 jekyll, 所以原生的文件如果放到 github 上，它会自动帮你生成静态网站。</li><li>4、相对 hexo 而言，可以直接在 github 网页版上编辑和发布博客，PC 间切换和同步非常方便。（这点本人非常喜欢）</li></ul><p>缺点：</p><ul><li>1、jekyll 用的 liquid 语法确实不是对程序员友好的，。不过 jekyll 功能比 hexo 强大很多，有时间折腾的可以选它。</li><li>2、相对 Wordpress 而言，没有强大的后台和插件支持，学习成本较高，需要一些网页基础。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1658849402716-8aa24f73-6054-43be-aeb0-517c254e7318.png#clientId=u8bfa6167-8f05-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=369&id=u452ca24f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=981&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=95017&status=done&style=none&taskId=ud9e82543-9921-4d27-bd17-1484dbbbe6b&title=&width=603" alt="image.png"></p><h2 id="8）Hugo"><a href="#8）Hugo" class="headerlink" title="8）Hugo"></a>8）Hugo</h2><p><strong>Hugo 使用文档：</strong><a href="https://gohugo.io/documentation/">https://gohugo.io/documentation/</a></p><h2 id="9）WordPress"><a href="#9）WordPress" class="headerlink" title="9）WordPress"></a>9）WordPress</h2><p><a href="https://link.jianshu.com/?t=https://www.wpdaxue.com/themes/">https://www.wpdaxue.com/themes/</a><br>WordPress 是一种使用 PHP 语言开发的博客平台，用户可以在支持 PHP 和 MySQL 数据库的服务器上架设属于自己的网站。<br>用户可以在支持 PHP 和 MySQL 数据库的服务器上使用自己的博客。</p><p>WordPress 有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。<br>比如你至少要懂的标准通用标记语言下的一个应用 HTML 代码、CSS、PHP 等相关知识。<br>优点：</p><ul><li>1、安装简单方便，甚至很多虚拟主机供应商都提供了 Wordpress 的一键式安装工具。用户连上传文件的步骤都省了。</li><li>2、功能强大，可扩展性高，丰富的插件使用起来更加方便。</li><li>3、wordpress 搭建的博客对 seo 搜索引擎友好，收录也快，排名靠前。</li></ul><p>缺点：</p><ul><li>1、对域名空间要求，wp 需要自己购买虚拟主机，低配版大概两百多块。</li><li>2、迁移成本高，且插件装多了会变慢。</li><li>3、Wordpress 对于中小型网站应该是不错的选择，但对于大型的门户网站，数据库、用户管理、内容的分类管理等方面的限制，还是会让 Wordpress 会有些力不从心的吧。</li></ul><h2 id="10-ReadtheDocs"><a href="#10-ReadtheDocs" class="headerlink" title="10) ReadtheDocs"></a>10) ReadtheDocs</h2><p><a href="https://readthedocs.org/">Read the Docs</a>是一个在线文档托管服务， 你可以从各种版本控制系统中导入文档，如果你使用<a href="http://docs.readthedocs.io/en/latest/webhooks.html">webhooks</a>， 那么每次提交代码后可以自动构建并上传至 readthedocs 网站，非常方便。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1658849776250-e3144338-33cd-45ca-8d85-4d31487b49c4.png#clientId=u8bfa6167-8f05-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=200&id=u071157c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=261&originWidth=1084&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31566&status=done&style=none&taskId=ue5244bc3-da0e-4fb9-9e27-9ad485b0d0f&title=&width=830" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据流图</title>
      <link href="2022/07/15/yuque/gy7cen/"/>
      <url>2022/07/15/yuque/gy7cen/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据流图概念"><a href="#一、数据流图概念" class="headerlink" title="一、数据流图概念"></a>一、数据流图概念</h1><p><strong>数据流图</strong>（Data Flow Diagram，DFD）是从数据传递和加工的角度，以图形的方式来描述逻辑输入经过系统加工处理后转化为逻辑输出的结构化系统分析工具<br><strong>重点理解</strong>：系统的输入和输出分别是什么、数据从何处来又去向何方、数据存储在何处</p><p>数据流图描述的是系统的逻辑模型，图中没有任何具体的物理元素，只是描绘信息在系统中流动和处理的情况。因为数据流图是逻辑系统的图形表示，即使不是专业的计算机技术人员也能容易理解。不要将数据流图（DFD）与系统流程图、程序流程图相混淆。</p><h1 id="二、-数据流图元素"><a href="#二、-数据流图元素" class="headerlink" title="二、 数据流图元素"></a>二、 数据流图元素</h1><ul><li><strong>数据流</strong>：一组固定成分的数据组成，表示数据的流向。除了流向数据存储和流出数据存储的数据流不需命名外，其余数据流都要命名</li><li><strong>加工</strong>：输入数据流到输出数据流之间的转换。每个加工都有编号(看出是哪个加工分解出的子加工)和名字</li><li><strong>数据存储</strong>：每个数据存储都有一个名字</li><li><strong>数据源</strong>：数据的发源地、归属地</li></ul><h1 id="三、数据流图步骤"><a href="#三、数据流图步骤" class="headerlink" title="三、数据流图步骤"></a>三、数据流图步骤</h1><ul><li>确定系统的输入输出：扩大范围，把可能有的内容全部包括进去</li><li>由外向内构建系统的顶层数据流图：系统从外界接收了什么数据、系统向外界发送了什么数据</li><li>自顶向下逐层分解，绘制分层数据流图</li></ul><h1 id="四、数据流图注意"><a href="#四、数据流图注意" class="headerlink" title="四、数据流图注意"></a>四、数据流图注意</h1><ul><li>加工的输出数据流不应与输入数据流同名，即是成分相同；</li><li>允许一个加工有多条数据流流向另一个加工，也允许一个加工有两条相同的输出数据流向不同的加工；</li><li>数据存储首次出现且只与一个加工有关，那么这个数据存储作为加工的内部文件可不必画出；</li><li>数据守恒：每个加工必须既有输入数据流，又有输出数据流，反映此加工数据的来源与加工结果；</li><li>数据存储必须既有读的数据流，又有写的数据流。子图中可能存在只读不写或只写不读；</li></ul><h1 id="五、数据流图案例"><a href="#五、数据流图案例" class="headerlink" title="五、数据流图案例"></a>五、数据流图案例</h1><ol><li>某高校学生选课系统有如下功能：学生根据开课情况和培养方案填写选课单，选课系统对每个学生的选课单进行处理。选课系统根据教学计划检查学生学分情况，计算上课时间如果不发生冲突，或冲突时间小于 20%，则可以选修。根据选课优先级，最后产生每个学生的个人课表和每门课程的选课名单。请分层画出该系统的顶层和 1 层的数据流图。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857525078-ea8f06b2-c5d5-477c-8a3e-57502949cab6.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=152&id=uf0ff4163&margin=%5Bobject%20Object%5D&originHeight=179&originWidth=812&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u05f51a1c-fea2-4e51-9a03-680138dbc95&title=&width=689"><br>选课系统顶层数据流图<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857525001-ca0e49c8-d2b8-4130-a9ff-c5e3086b23db.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=326&id=uaa777b09&margin=%5Bobject%20Object%5D&originHeight=453&originWidth=1022&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua231b06f-dc79-49dc-9178-caeb65b6953&title=&width=736"><br>选课系统 1 层数据流程</li><li>目前住院病人主要由护士护理，这样做不仅需要大量护士，而且由于不能随时观察危重病人的病情变化，还会延误抢救时机。某医院打算开发一个以计算机为中心的患者监护系统，请画出数据流图医院对患者监护系统的基本要求是随时接收每个病人的生理信号（脉搏、体温、血压、心电图等），定时记录病人情况以形成患者日志，当某个病人的生理信号超出医生规定的安全范围时向值班护士发出警告信息，此外，护士在需要时还可以要求系统输出某个指定病人的病情报告。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857524943-93e0c1e9-413b-4eef-bd1b-cae95722ca26.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=ufa890aaf&margin=%5Bobject%20Object%5D&originHeight=357&originWidth=890&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc1a6a972-0fb0-490f-9b94-0a21c6e767d&title=&width=758"><br>患者监护系统顶层数据流程<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857524927-1b60f7d0-0034-45ba-aa29-6706fe862a6a.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u45e7e00b&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=1062&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue102f81d-49b9-45a0-b6a0-4675c53a235&title="><br>患者监护系统 1 层数据流程</li><li>假设一家工厂的采购部每天需要一张订货报表，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据：零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为事务，通过放在仓库中的 CRT 终端把事务报告给订货系统。当某种零件的库存数量少于库存量临界值时就应该再次订货。要求：画出系统的顶层模型、第一层模型和第二层模型。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857524954-b0c31c7c-2607-454d-9ed7-8a0271c5c6ae.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=193&id=ub6dc2ae4&margin=%5Bobject%20Object%5D&originHeight=264&originWidth=1228&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufa6d6369-91e8-4b98-8db2-9121f272d62&title=&width=897.2000732421875"><br>订货系统顶层数据流程<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857525592-30e39d35-cec6-4744-8a1e-6dca15179fcd.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3af5618a&margin=%5Bobject%20Object%5D&originHeight=358&originWidth=852&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2b08ae4e-fbdb-442b-a905-5e2cf4ccc9f&title="><br>订货系统 1 层数据流图<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857525800-574ca4a1-15c0-4772-886b-5374626658e0.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=237&id=u113feeaa&margin=%5Bobject%20Object%5D&originHeight=307&originWidth=1084&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6a43ecd1-dff5-44fb-9251-99dd7a57e36&title=&width=836"><br>订货系统 2 层数据流图</li><li>银行计算机储蓄系统的工作过程大致如下：储户填写的存款单或取款单由业务员键入系统，如果是存款则系统记录存款人姓名、住址（或电话号码）、身份证号码、存款类型、存款日期、到期日期、利率及密码（可选）等信息，并打印出存款存单给储户；如果是取款而且存款时留有密码，则系统首先核对储户密码，若密码正确或存款时未留密码，则系统计算利息并打印利息清单给储户。请用数据流图描绘本系统的功能。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857525802-473fcd31-1d28-4282-b099-077e6a0f92e1.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u114af756&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=656&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued4f1fb6-1f9c-4665-9227-834b04ab416&title="><br>银行计算机储蓄系统顶层数据流程<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857525732-718c1fa4-c362-4597-bd52-b5216ee1a19b.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u7ff5936f&margin=%5Bobject%20Object%5D&originHeight=308&originWidth=812&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ude6df673-cb24-4719-968e-5d154114ac8&title=&width=646"><br>银行计算机储蓄系统 1 层数据流图<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857525739-1aaec6b0-215c-440b-b6e0-046e9f208d58.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=310&id=u8a278695&margin=%5Bobject%20Object%5D&originHeight=376&originWidth=1067&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=uff9d483a-380c-42b1-9eee-22c386c072b&title=&width=879"><br>银行计算机储蓄系统 2 层数据流图</li><li>为方便旅客，某航空公司拟开发一个机票预定系统。旅行社把预定机票的旅客信息（姓名、性别、工作单位、身份证号码、旅行时间、旅行目的地等）输入进入该系统，系统为旅客安排航班，印出取票通知和账单，旅客在飞机起飞的前一天凭取票通知和账单交款取票，系统校对无误即印出机票给旅客。画出系统的顶层及 1 层数据流图。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857526156-904eab6f-7b73-49b4-b0fe-b21689c59ea4.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u792d72bc&margin=%5Bobject%20Object%5D&originHeight=338&originWidth=1208&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud0826888-a126-42a9-9cdd-27eef731d5b&title=&width=833.2000732421875"><br>机票预订系统数据流图<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1657857526400-76ed0479-57e3-4a78-9136-0dda7eecfe7d.jpeg#clientId=u67871e10-1272-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u81ec6c9e&margin=%5Bobject%20Object%5D&originHeight=410&originWidth=1036&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=udecbce3c-75b8-418f-9309-0719b8d6ffc&title=&width=756"><br>机票预订系统 1 层数据流图</li></ol><p><a href="https://blog.csdn.net/qq_38230811/article/details/80798538">https://blog.csdn.net/qq_38230811/article/details/80798538</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>带你快速了解什么是敏捷Scrum</title>
      <link href="2022/07/08/yuque/sowiwi/"/>
      <url>2022/07/08/yuque/sowiwi/</url>
      
        <content type="html"><![CDATA[<h2 id="Scrum-中的角色"><a href="#Scrum-中的角色" class="headerlink" title="Scrum 中的角色"></a>Scrum 中的角色</h2><p><strong>Scrum Master——项目负责人、项目经理</strong><br>保护团队不受外界干扰，是团队的领导和推进者，负责提升 Scrum 团队的工作效率，控制 Scrum 中的“检视和适应”周期过程。与 Product Owner 一起将投资产出最大化，他确保所有的利益相关者都可以理解敏捷和尊重敏捷的理念。<br><strong>Team——开发人员、测试人员、美工设计、DBA 等全职能性团队</strong><br>团队负责交付产品并对其质量负责，团队与所有提出产品需求的人一起工作，包括客户和最终用户，并共同创建 Product Backlog 。团队按照大家的共识来创建功能设计、测试 Backlog 条目交付产品。<br><strong>Product Owner——产品负责人、产品经理、运营人员</strong><br>从业务角度驱动项目，传播产品的明确愿景，并定义其主要特性。Product Owner 的主要职责是确保团队只开发对于组织最重要的 Backlog 条目，在 Sprint 中帮助团队完成自己的工作，不干扰团队成员，并迅速提供团队需要的所有信息。<br><strong>User——最终用户、运营人员、系统使用人员</strong><br>很多人都可能成为最终用户，比如市场部人员、真正的最终用户、最好的领域专家，也可能是因其专业知识而被雇佣的资讯顾问。最终用户会根据自己的业务知识定义产品，并告知团队自己的期望，提出请求。<br><strong>Manager——管理层、投资人</strong><br>管理层要为 Scrum 团队搭建良好的环境，以确保团队能够出色工作，必要的时候，他们也会与 Scrum Master 一起重新组织结构和指导原则。<br><strong>Customer——客户、系统使用人员、运营人员</strong><br>客户是为 Scrum 团队提出产品需求的人，她会与组织签订合同，以开发产品。一般来说，这些人是组织中的高级管理人员，负责从外部软件开发公司购买软件开发能力。在为内部产品的公司中，负责批准项目预算的人就是客户。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1657295528356-bb952641-686e-418c-a58c-d6cdd0d9857a.png#clientId=uf5597745-6d60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=451&id=ue7073a44&margin=%5Bobject%20Object%5D&originHeight=585&originWidth=877&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7d2f8267-4ef9-4226-bbf7-287d2d90f33&title=&width=676"></p><h2 id="Scrum-团队"><a href="#Scrum-团队" class="headerlink" title="Scrum 团队"></a>Scrum 团队</h2><ul><li>Scrum 团队最佳人数控制在“5 ～ 9”人。</li><li>全职能性团队：开发组（后台开发、前端开发、测试人员——3~8 人）、Scrum Master（项目经理）、产品负责人</li><li>兼职团队成员：美工、DBA、运维</li></ul><h2 id="Scrum-中的产出物"><a href="#Scrum-中的产出物" class="headerlink" title="Scrum 中的产出物"></a>Scrum 中的产出物</h2><p><strong>Product Backlog——Backlog 待开发项，积压的任务。</strong><br>产品 Backlog 包括了所有需要交付的内容，其内容根据业务需求的价值顺序排列，每个 Backlog 的优先级是可以调整的，需求是可以增减的，因此产品 Backlog 将根据不断增长来持续驱动维护。<br><strong>Sprint Backlog——Sprint 本意为“冲刺”，指迭代周期，长度通常是一至六周。</strong><br>在 Sprint 开始前，定义本次 Sprint 要讨论的“Sprint Backlog”，从中产生本次 Sprint 要完成的 “已定 Product Backlog”。<br><strong>已定 Product Backlog</strong><br>Sprint 计划会议的产物，它定义了团队所接受的工作量，在整个 Sprint 过程中它将保持不变。<br><strong>User Story、Task——用户故事、任务</strong><br>用 User Story 来描述 Sprint Backlog 里的项目，User Story 是从用户的角度对系统的某个功能模块所作的简短描述。一个 User Story 描述了项目中的一个小功能，以及这个功能完成之后将会产生什么效果，或者说能为客户创造什么价值。<strong>一个 User Story 的大小和复杂度应该以能在一个 Sprint 中完成为宜</strong>。如果 User Story 太大，可能会导致对它的开发横跨几个 Sprint，此时就应该将这个 User Story 分解。<br>为了能够及时，高效地完成每个 Story，Scrum 团队会把每个 Story 分解成若干个 Task。每个 Task 的时间最好不要超过 8 小时，保证在 1 个工作日内完成，如果 Task 的时间超过了 8 个小时，就说明 Task 的划分有问题，需要特别注意。<br><strong>障碍 Backlog——问题列表，积压的待处理事务。</strong><br>列举了所有团队内部和团队相关的和阻碍项目的进度的问题，Scrum Master 需要确保所有的障碍 Backlog 中的问题都已分配并可以得到解决。</p><h2 id="每日立会（Daily-Standup-Meeting）"><a href="#每日立会（Daily-Standup-Meeting）" class="headerlink" title="每日立会（Daily Standup Meeting）"></a>每日立会（Daily Standup Meeting）</h2><p><strong>——建议下班前开始</strong><br><strong>会议目的</strong></p><ul><li>团队在会议中作计划，协调其每日活动，还可以报告和讨论遇到的障碍。</li><li>任务板能够帮助团队聚焦于每日活动之上，要在这个时候更新任务板和燃尽图。</li></ul><p><strong>构成部分</strong></p><ul><li>任务板、即时贴、马克笔</li><li>提示：ScrumMaster 不要站在团队前面或是任务板旁边，不要营造类似于师生教学的气氛。</li></ul><p><strong>基本要求</strong></p><ul><li>成员：团队、Scrum Master</li><li>无法出席的团队成员要由同伴代表。</li><li>持续时间/举办地点：每天 15 分钟，同样时间，同样地点。</li><li>提示：团队成员在聆听他人发言时，都应该想这个问题：“我该怎么帮他做得更快？”</li></ul><p><strong>会议输出</strong></p><ul><li>团队彼此明确知道各自的工作，最新的工作进度图。</li><li>得到最新的“障碍 Backlog”</li><li>得到最新的“Sprint Backlog”</li></ul><p><strong>会议过程</strong></p><ul><li>团队聚在故事板旁边，可以围成环形。</li><li>从左边第一个开始，向团队伙伴说明他到现在完成的工作。</li><li>然后该成员将任务板上的任务放到正确的列中。</li><li>如果可以的话，该成员可以选取新的任务，交将其放入“进行中工作”列。</li><li>如果该成员遇到问题或障碍，就要将其报告给 Scrum Master。</li><li>每个团队成员重复步骤 2 到步骤 5。</li></ul><p><strong>每个人三个问题：</strong></p><ul><li>上次会议时的任务哪些已经完成？：把任务从“正在处理”状态转为“已完成”状态。——今天完成了什么？</li><li>下次会议之前，你计划完成什么任务？：如果任务状态为“待处理”，转为“正在处理”状态。如果任务不在 Sprint Backlog 上，则添加这个任务。如果任务不能在一天成，把这任务细分成多个任务。如果任务可以在一天内完成，把任务状态设为“正在处理”。如果任务状态已经是“正在 处理”，询问是否存在阻碍任务完成得问题。——明天做什么？</li><li>有什么问题阻碍了你的开发？：如果有阻碍你的开发进度的问题，把该障碍加入到障碍 Backlog 中。——今天遇到了什么问题？</li></ul><p><strong>注意事项</strong></p><ul><li>不要迟到</li><li>不要超出限制时间</li><li>不要讨论技术问题</li><li>不要转变会议话题</li><li>不要在没有准备的情况下参加</li><li>Scrum Master 不要替团队成员移动任务卡片，不要替团队更新燃尽图。</li><li>Scrum Master 不要提出问题，团队成员不要向 Scrum Master 或管理层人员报告。</li><li>如果不能出席会议，需要通知团队，并找一名代表参加。</li></ul><h2 id="任务板"><a href="#任务板" class="headerlink" title="任务板"></a>任务板</h2><ul><li><p>任务板集合了选择好的 Product Backlog 和 Sprint Backlog，并以可视化方式展示。</p></li><li><p>任务板只能由团队维护，使用不同颜色的“即时贴”来区分开发人员，或者在“即时贴”写上接受任务的姓名。</p></li><li><p>尽量使用大白板，也可以使用软件。</p></li><li><p>选择好的 Product Backlog：按照优先级，将团队在当前 Sprint 中要着手的 Product Backlog 条目或是故事放在该列中。</p></li><li><p>待完成的任务：要完成一个故事，你得完成一些任务。在 Sprint 规划会议中，或是在进行当前 Sprint 中，收集所有特定 Backlog 条目需要完成的新任务，并将它们放入该列。</p></li><li><p>进行中的工作：当团队成员开始某个任务后，他会将该任务对应的卡片放到“进行中的工作”列中。从上个每日 Scrum 例会开始，没有完成的任务都会放在该列中，并在上面做标记（通常是个红点）。如果某个任务在“待完成任务”列中所处时间超过一天，就尽量将该任务分为更小 的部分，然后把新任务放到那一列，移除其所属大任务卡片。如果一个新任务因为某个障碍无法完成，就会得到一个红点标记，Scrum Master 就会记下一个障碍。</p></li><li><p>完成：当一个任务卡完成后，完成此任务的成员将其放入“完成”列，并开始选取下一张任务卡。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1657297614066-dc485cd6-ef07-4c14-a06c-effb0e8475cd.png#clientId=uf5597745-6d60-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=389&id=u56820fc1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=389&originWidth=655&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=94745&status=done&style=none&taskId=ud989ca99-eea4-477e-b4a5-44240e022c1&title=&width=655" alt="image.png"></p><h2 id="燃尽图（Burn-Down-Chart）"><a href="#燃尽图（Burn-Down-Chart）" class="headerlink" title="燃尽图（Burn Down Chart）"></a>燃尽图（Burn Down Chart）</h2><ul><li>跟踪进度要由团队来完成，燃尽图的横轴表示整个 Sprint 的总时间，纵轴表示 Sprint 中所有的任务，其单位可以是小时，人天等。一般来说，燃尽图有”Sprint 燃尽图”和”Release 燃尽图”之分。</li><li>团队每天更新燃尽图。</li><li>如果燃尽图一直是上升状态，或当 Sprint 进行一段时间之后，Sprint 燃尽图上的 Y 值仍然与 Sprint 刚开始时相差无几，就说明这个 Sprint 中的 Story 过多，要拿掉一些 Story 以保证这个 Sprint 能顺利完成。 如果 Sprint 燃尽图下降得很快，例如 Sprint 刚过半时 Y 值已经接近 0 了，则说明这个 Sprint 分配的任务太少，还要多加一些任务进来。在 Sprint 计划会议上，如果团队对即将要做的任务理解和认识不充分，就很可能导致这两种情况的出现。（锻炼团队人员的自我估算时间）</li><li>燃尽图要便于团队更新，没必要让它看起来很炫，也不要过于复杂，难以维护。</li></ul><p>Release 燃尽图：记录整个 Scurm 项目的进度，它的横轴表示这个项目的所有 Sprint， 纵轴表示各个 Sprint 开始前，尚未完成的工作，它的单位可以是个（Story 的数量），人天等。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655652918578-e27f0ac9-52c1-42b3-9e73-b4d96744ed8a.png?x-oss-process=image/resize,w_737,limit_0#crop=0&crop=0&crop=1&crop=1&from=url&id=Foh7v&margin=%5Bobject%20Object%5D&originHeight=348&originWidth=737&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="Sprint-规划会议"><a href="#Sprint-规划会议" class="headerlink" title="Sprint 规划会议"></a>Sprint 规划会议</h2><h3 id="第一部分（上午）"><a href="#第一部分（上午）" class="headerlink" title="第一部分（上午）"></a>第一部分（上午）</h3><p><strong>会议目的</strong></p><ul><li><strong>该会议的工作以分析为主</strong>，目的是要详细理解最终用户到底要什么，产品开发团队可以从该会议中详细了解最终用户的真实需要。在会议的结束，团队将会决定他们能够交付哪些东西。</li><li>产品负责人在会前准备：条目化的需求（用户故事），优先级排序，最近 1~2 个迭代最希望看到的功能。会前准备至关重要，可帮助产品负责人理清头绪，不至于在迭代期内频繁提出变更、增加或删除故事。</li></ul><p><strong>基本要求</strong></p><ul><li>迭代计划会在每个迭代第一天召开，目的是选择和估算本次迭代的工作项。</li><li>只有团队成员才能决定团队在当前 Sprint 中能够领取多少个 Backlog 条目的工作。</li></ul><p><strong>构成部分：</strong></p><ul><li>经过估算和排序的 Product Backlog。</li><li>挂图、马克笔、剪刀、胶水、即时贴、白板、铅笔和蜡笔。</li><li>假期计划表、重要人员的详细联系信息。</li><li>参会成员：团队成员、Scrum Master、产品负责人</li></ul><p><strong>持续时间</strong>：在 Sprint 中，每周该会议占用时间为 60 分钟，在早上召开该会议，这样还有可能在同一天召开 Sprint 规划会议的第二部分。<br><strong>会议输出</strong></p><ul><li>选择好的 Product Backlog 条目。</li><li>各个 Backlog 条目的需求。</li><li>各个 Backlog 条目的用户验收测试。</li></ul><p><strong>会议过程</strong></p><ul><li>从第一个 Product Backlog 条目（故事）开始。</li><li>讨论该 Product Backlog 条目，以深入理解。</li><li>分析、明确用户验收测试。</li><li>找到非功能性需求（性能、稳定性…）</li><li>找到验收条件。</li><li>弄清楚需要“完成”到何种水平。</li><li>获得 Backlog 条目各个方面的清晰了解。</li><li>绘制出所需交付物的相关图表，包括流程图、UML 图、手绘草图、屏幕 UI 设计等。</li><li>回到步骤 1，选取下一个 Backlog 条目。</li></ul><p><strong>流程检查：</strong>询问团队能否快速回答下列问题，只需要简要回答即可：“我们能在这个 Sprint 中完成第一个 Backlog 条目吗？”如果能得到肯定的回答，那么继续询问下一个 Backlog 条目，一直到已经分析完的最后一个 Backlog 条目。——接下来，休息一下。在休息后，对下一个 Backlog 条目展开上述流程。<br><strong>结束流程</strong>：</p><ul><li>在 Sprint 规划会议第一部分结束前留出 20 分钟。</li><li>再次提问——这次要更加严肃、正式：“你们能否完成第一个 Backlog 条目，…第二个，…？”</li><li>如果团队认为他们不能再接受更多的 Backlog 条目，那就停下来。</li><li>现在是非常重要的一步：送走 Product Owner，除了团队和 Scrum Master 之外的所有人，都得离开。</li><li>当其他人都离开后，再询问团队：“说真的——你们相信自己可以完成这个列表？”</li><li>希望团队现在能短暂讨论一下，看看他们到底认为自己能完成多少工作。</li><li>将结果与 Product Owner 和最终用户沟通。</li></ul><p>注意事项：不要改变 Backlog 条目大小，不要估算任务。</p><h3 id="第二部分（下午）"><a href="#第二部分（下午）" class="headerlink" title="第二部分（下午）"></a>第二部分（下午）</h3><p><strong>会议目的</strong></p><ul><li><strong>该会议的工作以设计为主</strong>，产品开发团队可以为他们要实现的解决方案完成设计工作，在会议结束后，团队知道如何构建他们在当前 Sprint 中要开发的功能。</li></ul><p><strong>基本要求</strong></p><ul><li>只有产品开发团队才能制定解决方案，架构师或其他团队之外的人只是受邀帮助团队。</li></ul><p><strong>构成部分：</strong></p><ul><li>能够帮助团队在该 Sprint 中构建解决方案的人，比如厂商或是来自其他团队的人员。</li><li>选择好的 Product Backlog 条目。</li><li>挂图……</li></ul><p><strong>注意事项：</strong>不要估算任务，不要分配任务。<br><strong>会议输出</strong></p><ul><li>应用设计、架构设计图、相关图表</li><li>确保团队知道应该如何完成任务！</li></ul><p><strong>会议过程</strong></p><ul><li>从第一个 Backlog 条目开始。</li><li>查看挂图，确定对于客户的需求理解正确。</li><li>围绕该 Backlog 条目进行设计，并基于下列类似问题：<ul><li>我们需要编写什么样的接口？</li><li>我们需要创建什么样的架构？</li><li>我们需要更新哪些表？</li><li>我们需要更新或是编写哪些组件？</li><li>……</li></ul></li></ul><p>当团队明确知道自己应该如何开发该功能后，就可以转向下一个 Backlog 条目了。在会议的最后 10 分钟，团队成员使用即时贴写出初步的任务。这能帮助团队成员知道接下来的工作从哪里开展，将这些任务放在任务板上。<br><strong>持续时间</strong>：在 Sprint 规划会议第一部分完成后，召开该会议。可以将午餐作为两次会议的一个更长久的休息。但是要在同一天完成 Sprint 规划第一部分，在 Sprint 中，每周该会议占用时间为 60 分钟。</p><h2 id="估算会议"><a href="#估算会议" class="headerlink" title="估算会议"></a>估算会议</h2><p><strong>——根据项目情况合并到 Sprint 第二部分会议</strong><br><strong>会议目的</strong></p><ul><li>要做好战略规划，你需要知道 Backlog 中各项的大小，这是版本规划的必要输入；如果想知道团队在一个 Sprint 中能够完成多少工作，这个数据也是必须的。</li><li>团队成员可以从会议中知道项目接下来的阶段会发生哪些事情。</li></ul><p><strong>基本要求</strong></p><ul><li>只有团队才能作估算，Product Owner（产品负责人）需要在场，以帮助判定某些用户故事能否拆分为更小的故事。</li></ul><p><strong>构成部分：</strong></p><ul><li>Product Owner 根据业务价值排定 Product Backlog 各项顺序。</li><li>需要参加的人员：Team、Product Owner、User、Scrum Master</li></ul><p><strong>注意事项：</strong></p><ul><li>不要估算工作量大小——只有团队能这么做。</li><li>Product Owner 不参与估算。</li></ul><p><strong>会议过程</strong></p><ul><li>Prodcut Owner 展示她希望得到估算的 Product Backlog 条目。</li><li>团队使用规划扑克来估算 Backlog 条目。</li><li>如果某个 Backlog 条目过大，需要放到下一个或是后续的 Sprint 中，团队就会将该大 Backlog 条目划分为较小的几个 Backlog 条目，并对新的 Backlog 条目使用规划扑克进行估算。</li><li>重新估算 Backlog 中当前没有完成、但是可能会在接下来三个 Sprint 中要完成的条目。</li></ul><p><strong>持续时间：</strong>该会议时间限制为不超过 90 分钟。如果 Sprint 持续时间长于一周，那么每个 Sprint 举行两次估算会议比较合适。<br><strong>会议输出</strong></p><ul><li>经过估算的 Product Backlog。</li><li>更小的 Backlog 条目。</li></ul><h3 id="扑克牌估算（Planning-Poker）"><a href="#扑克牌估算（Planning-Poker）" class="headerlink" title="扑克牌估算（Planning Poker）"></a>扑克牌估算（Planning Poker）</h3><p><strong>具体步骤：</strong></p><ul><li>每个人各自估算后独立出暗牌，听口令一起开牌。</li><li>数值最大者与最小者 PK，其他人旁听也可参考。</li><li>讨论结束后重新出牌和开牌。</li><li>重复上述过程，直到结果比较接近。</li></ul><p><strong>常见问题</strong><br>1、为什么任务要分给组而不是个人？<br>答：因为怕出错了牌又说不出所以然，这样即使日后他不做这个功能，也对这个功能很了解。<br>2、为什么不让最后领任务的人自己估算？<br>答：因为他很可能因为不知道某代码可用、不知道某软件不行….而选择了错误的实现方法。<br>3、为什么不让师傅估算大家采纳，他不是最厉害吗？<br>答：师傅的想法常常是徒弟们理解不了的，比如为什么不留在女儿国而偏偏去西天取经之类的，共同估算就是让大家在思考中对照自己的实现方法和师傅差异的过程。</p><h2 id="Sprint-评审会议（Review-Meeting）"><a href="#Sprint-评审会议（Review-Meeting）" class="headerlink" title="Sprint 评审会议（Review Meeting）"></a>Sprint 评审会议（Review Meeting）</h2><p>——根据项目需要举行<br>会议目的</p><ul><li>Scrum 团队在会议中向最终用户展示工作成果，团队成员希望得到反馈，并以之创建或变更 Backlog 条目。</li></ul><p>基本要求</p><ul><li>Sprint 复审会议允许所有的参与者尝试由团队展示的新功能。</li></ul><p>构成部分</p><ul><li>有可能发布的产品增量，由团队展示。</li></ul><p>会议输出</p><ul><li>来自最终用户的反馈。</li><li>障碍 Backlog 的输入。</li><li>团队 Backlog 的输入。</li><li>来自团队的反馈为 Product Backlog 产生输入。</li></ul><p>持续时间：90 分钟，在 Sprint 结束时进行。<br>会议过程</p><ul><li>Product Owner 欢迎大家来参加 Sprint 复审会议。</li><li>Product Owner 提醒大家关于本次 Sprint 的目的：Sprint 目标、Scrum 团队在本次 Sprint 中选定要开发的故事。</li><li>产品开发团队展示新功能，并让最终用户尝试新功能。</li><li>Scrum Master 推进会议进程。</li><li>最终用户的反馈将会由 Product Owner 和/或 Scrum Master 记录在案。</li></ul><p>注意事项：</p><ul><li>不要展示不可能发布的产品增量。</li><li>Scrum Master 不要负责展示结果。</li><li>团队不要针对 Product Owner 展示。</li></ul><h2 id="Sprint-反思会议（Retrospective-Meeting）"><a href="#Sprint-反思会议（Retrospective-Meeting）" class="headerlink" title="Sprint 反思会议（Retrospective Meeting）"></a>Sprint 反思会议（Retrospective Meeting）</h2><p>——根据项目需要举行<br>会议目的</p><ul><li>该会议的对应隐喻：医疗诊断！其目的不是为了找到治愈方案，而是要发现哪些方面需要改进。</li></ul><p>构成部分</p><ul><li>参与人员：团队成员、Scrum Master</li></ul><p>基本要求</p><ul><li>从过去中学习，指导将来。</li><li>改进团队的生产力。</li></ul><p>注意事项</p><ul><li>不要让管理层人员参与会议。</li><li>不要在团队之外讨论找到的东西。</li></ul><p>会议输出</p><ul><li>障碍 Backlog 的输入。</li><li>团队 Backlog 的输入。</li></ul><p>持续时间：90 分钟，在 Sprint 评审会议结束后几分钟开始。<br>会议过程</p><ul><li>准备一个写着“过去哪些做的不错？”的挂图。</li><li>准备一个写着“哪些应该改进？”的挂图。</li><li>绘制一条带有开始和结束日期的时间线。</li><li>给每个团队成员发放一叠即时贴。</li><li>开始回顾。</li><li>做一个安全练习。</li><li>收集事实：发放即时贴，用之构成一条时间线。每个团队成员（包括 Scrum Master）在每张即时贴上写上一个重要的事件。</li><li>“过去哪些做的不错？”：采取收集事实同样的过程，不过这次要把即时贴放在准备好的挂图上。</li><li>做一个分隔，以区分“过去哪些做的不错”和接下来要产出的东西。</li><li>“哪些应该改进？”：像“过去哪些做的不错”那样进行。</li><li>现在将即时贴分组：</li><li>我们能做什么》团队 Backlog 的输入。</li><li>哪些不在我们掌控之内？》障碍 Backlog 的输入。</li><li>根据团队成员的意见对两个列表排序。</li><li>将这两个列表作为下个 Sprint 的 Sprint 规划会议第一部分和 Sprint 规划会议第二部分的输入，并决定到时候要如何处理这些发现的信息。</li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>硝烟中的 Scrum 和 XP</li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统设计之架构图</title>
      <link href="2022/06/20/yuque/ikzr14/"/>
      <url>2022/06/20/yuque/ikzr14/</url>
      
        <content type="html"><![CDATA[<p>软件领域发展到今天，延伸出了企业架构、业务架构、应用架构、数据架构、产品架构、技术架构等一堆的名词。是不是有点晕了，这些架构都是用来干什么，它们之间有什么区别？不搞清楚它们之间的关系，产品架构从何谈起。</p><h2 id="架构图的定义"><a href="#架构图的定义" class="headerlink" title="架构图的定义"></a>架构图的定义</h2><p>往往系统是非常复杂的，无法一下子全部表达清楚，架构要涵盖的内容和决策太多了，超过了人脑”一蹴而就”的能力范围，因此采用”分而治之”的办法从不同视角分别设计。<br>也就是说架构图是对系统从某种维度视角的表达，<strong>每一种架构图，都是一种视角。</strong>它的作用有两个：划分目标系统边界; 将目标系统的结构可视化.<br><strong>一个架构视图，是对系统从某一个视角或某一点上看到的，所做的简化的描述，涵盖了系统的某一个特定方面，忽略了此方面无关的实体。</strong><br>架构图，是可视化的，是给人看的。所以，归根结底是为了交流理解。</p><ol><li>对上，经常需要汇报，争取领导层的认同支持。</li><li>对己，借助多种视图来厘清思路。</li><li>对下，用不同视角来表达自己的想法，沟通交流。</li></ol><p>对于架构设计师来说，架构图，是一种非常“硬核”的必要能力。</p><h2 id="架构图的分类"><a href="#架构图的分类" class="headerlink" title="架构图的分类"></a>架构图的分类</h2><ul><li><strong>业务架构</strong>：需求初期业务的结果和过程描述一般比较模糊，可能来自于某个老板、运营或用户的反馈。<em>客户说海尔洗衣机洗土豆会堵，海尔立马设计专门的土豆洗衣机</em> 业务方向往往是定方向和结果的叫战略，主要包括业务规划、业务模块和流程以及问题域的列表等。</li><li><strong>应用架构：</strong>服务复用、跨组协同，简单、灵活、整合是应用架构必须考虑的点，就像你要上线一个聊天功能，那么聊天内容的输入法、文字识别、舆情监控以及视频服务、支付服务等，它们都是在应用架构分层下沉淀到平台的产物，在供各个方使用。</li><li><strong>产品架构：</strong>业务提需求，产品定方案，<strong>相对于业务的粗放流程，产品架构会更加细腻以及考虑各个模块的分层和边界</strong>。</li><li><strong>数据架构</strong>：数据的获取、数据的存放和数据的使用是数据架构要解决的三个问题，数据库存放、大数据汇总、数据分析等。</li><li><strong>技术架构：</strong>是离程序员最近的架构设计，它不仅是系统搭建的架构图设计，还包括了结构、功能、流程、逻辑等内容。它的具体描述就是整个系统如何落地的具体实现方案</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655742643463-3fb32fc7-c073-4cd2-a06f-761b3b46faea.png#clientId=u1bcd7285-1704-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=IltPE&margin=%5Bobject%20Object%5D&originHeight=384&originWidth=574&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u97b42e61-6659-46a7-b7a4-80c916b8610&title="><br>现在很多人在推崇“<strong>RUP+1</strong>”方法，或者<strong>C4 模型</strong>方法来画架构图，这种架构图表达方式，更适合上面说的对己、对下来交流。<br>但是实际工作场景中，尤其是对上汇报中，经常需要的是如下几种架构图。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655775097771-9a7b88ef-7992-42f0-82ac-bd8fae017149.png#clientId=ubffeeb89-afc0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=364&id=u4af81e8c&margin=%5Bobject%20Object%5D&originHeight=375&originWidth=602&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8128f4da-f8ec-4921-9403-d8b0c473875&title=&width=584"></p><h3 id="1）-业务架构图"><a href="#1）-业务架构图" class="headerlink" title="1） 业务架构图"></a>1） 业务架构图</h3><p>业务架构：使用一套方法论/逻辑对产品（项目）所涉及到的业务进行边界划分。所以熟悉业务是关键。<strong>简单来说，是从业务、产品视角，描述整个平台、或某个产品的实现。</strong><br>比如做一个团购网站，你需要把商品类目、商品、订单、订单服务、支付、退款等进行清晰划分，<strong>而业务架构不需要考虑诸如我用什么技术开发、我的并发大怎么办、我选择什么样的硬件等等。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655740659456-1b3b30b3-4e36-4bcc-ba44-45e881de26d2.png#clientId=ueae83a84-81c4-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb0a8857&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=353414&status=done&style=none&taskId=u528fecdb-baba-48f3-8a16-49a628f6408&title=" alt="image.png"><br>业务架构是指企业通过分析自身所处的外界环境，自身面临的机遇和挑战，同时剖析自身的结构特点和资源情况，明确自身优劣势，从而选择和制定企业发展目标，制定具体的实施方案和计划。<br>核心要素主要包括业务目标、资源能力、业务流程和组织结构；放在企业层面是企业业务目标，放在部门层面是部门业务目标。<br>对业务架构我们要思考一下的问题：</p><ul><li>达成的目标是什么；</li><li>做什么业务；</li><li>资源和能力在哪里；</li><li>什么样方式在什么样的组织里做；</li></ul><p>举例来说：企业采购业务的业务架构</p><ul><li>业务目标：合理、合规、高效、节约的方式为集团各部门提供寻源、合同签订、订单执行等服务，保障和保本各运营业务线的运行。</li><li>资源能力：品类丰富、规模优势、采购模式多样，具备一定的市场话语权。</li><li>业务流程：以集团统管的方式，实现供应商交付，需求部门验收的上下游流程一体化的格局。</li><li>组织结构：建立集采、分采等采购团队，集中管控+授权自购的组织体系。</li></ul><h3 id="2）-应用架构图"><a href="#2）-应用架构图" class="headerlink" title="2） 应用架构图"></a>2） 应用架构图</h3><p>应用架构（Application Architecture）是描述了 IT 系统功能和技术实现的内容。应用架构分为以下两个不同的层次：</p><ul><li><strong>企业级的应用架构：</strong>企业层面的应用架构起到了统一规划、承上启下的作用，向上承接了企业战略发展方向和业务模式，向下规划和指导企业各个 IT 系统的定位和功能。在企业架构中，应用架构是最重要和工作量最大的部分，他包括了企业的应用架构蓝图、架构标准/原则、系统的边界和定义、系统间的关联关系等方面的内容。</li><li><strong>单个系统的应用架构：</strong>在开发或设计单一 IT 系统时，设计系统的主要模块和功能点，系统技术实现是从前端展示到业务处理逻辑，到后台数据是如何架构的。这方面的工作一般属于项目组，而不是企业架构的范畴，不过各个系统的架构设计需要遵循企业总体应用架构原则。</li></ul><p>简而言之，应用架构图分为两类，</p><ul><li><strong>一类为多系统应用架构，用来分层次说明不同系统间的业务逻辑关系、信息流、系统边界等等。</strong></li><li><strong>一类为单系统应用架构，用来分层次说明系统主要组成模块和功能点之间的业务逻辑关系。</strong></li></ul><p>应用架构是描述一个企业各个相互独立的应用系统的部署以及核心业务流程之间的关系，目的是建立业务架构与数据架构和其他架构之间的关联；它能连接业务架构的流程，功能，人员，也能够连接数据架构中的数据管理和使用，还能提出对技术架构的要求。<br>主要分为表现层、应用层和数据层来表示<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655743107543-788f792f-222b-40d6-bd76-d9db4d9258a3.png#clientId=uf015c360-51e4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=241&id=u1533e78a&margin=%5Bobject%20Object%5D&originHeight=285&originWidth=593&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0b4948df-a40e-4494-bd09-34ea93fe88a&title=&width=501"></p><p><strong>产品架构是产品的结构，是对某一块具体业务的进行抽象</strong>，并用可视化的方式呈现出来，它划分了功能模块、数据流向，包括现有的，以及未来规划的。其目的不仅是为了架构设计的简洁性，更是为了整个业务的完整性，把离散的业务过程场景化。<br><strong>产品架构和应用架构的关系？</strong><br>产品架构是应用架构的一部分，当应用架构只有一个产品时，也就是产品架构。多个产品组合一起形成了企业应用架构全景图。</p><h4 id="多系统业务架构图"><a href="#多系统业务架构图" class="headerlink" title="多系统业务架构图"></a>多系统业务架构图</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/5374140/1655784024817-4dd02d62-7b50-4b99-9f0c-69b9569d9a66.webp#clientId=ubcde7e11-5334-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=546&id=uf711cd56&margin=%5Bobject%20Object%5D&originHeight=603&originWidth=648&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u31176248-9516-4b9a-a42b-eae3bff3175&title=&width=587"><br>业务架构图按照层次结构可以分为经典的三层结构：展现层、业务逻辑层和数据层，而上图作者在该基础上又分别对展现层和业务逻辑层做了细分。在上图的基础上其实还可以加上一层运维层来说明系统所需要的硬件条件。对于单个系统的架构图而言尤其重要。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655784610896-5dc495ab-70ad-4f1c-9743-a47e13e272c6.png#clientId=ubcde7e11-5334-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=u6c3462a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=486&originWidth=845&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=60717&status=done&style=none&taskId=u324c7bb7-ef6b-44e6-901b-ce886ef6cc1&title=&width=623" alt="image.png"><br><strong>使用多系统应用架构图还有一个好处在于，每当有新增的子系统时，可以提前预判是否需要共用哪些单元或者业务逻辑。例如是否用同一套账户体系，这对产品前期开发至关重要。</strong></p><h4 id="单系统业务架构图"><a href="#单系统业务架构图" class="headerlink" title="单系统业务架构图"></a>单系统业务架构图</h4><p>对于一个从 0 到 1 的项目而言，产品经理除了要了解这个项目在整个企业应用架构中的定位，还要对整个系统的模块和功能有着清晰的分层次设计和了解。所以产品经理就不仅需要多系统业务架构图，也需要单系统业务架构图。<br>**<img src="https://cdn.nlark.com/yuque/0/2022/webp/5374140/1655784071612-8f9fdee4-5665-46b9-9bbd-e86530bfa32f.webp#clientId=ubcde7e11-5334-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=u118125a9&margin=%5Bobject%20Object%5D&originHeight=464&originWidth=595&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u099b3225-3f15-44f6-a30a-286c8a6d83b&title=&width=512"></p><h3 id="3）-数据架构图"><a href="#3）-数据架构图" class="headerlink" title="3） 数据架构图"></a>3） 数据架构图</h3><p>数据架构：是一套对存储数据的架构逻辑，它会根据各个系统应用场景、不同时间段的应用场景 ，对数据进行诸如数据异构、读写分离、缓存使用、分布式数据策略等划分。<br>数据架构主要解决三个问题：第一，系统需要什么样的数据；第二，如何存储这些数据；第三，如何进行数据架构设计。</p><p>数据架构是基于数据管理领域知识经验的总结，提炼指导未来数据管理的过程。<br>主要包括数据治理和数据管理，数据治理包括数据管理政策，原则，规范和标准等；数据管理包括数据总体视图和数据结构，数据库设计等。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655742888857-1661ffa7-d21c-4115-9895-870288aef576.png#clientId=uf015c360-51e4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=457&id=u8d62f280&margin=%5Bobject%20Object%5D&originHeight=363&originWidth=654&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2befe2ce-7faa-49a5-a6a3-bb94657e861&title=&width=824"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1655775306548-e4ecd4a5-b33b-4b6c-a0ba-2e708a48c895.jpeg#clientId=ubffeeb89-afc0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uccb9fd6e&margin=%5Bobject%20Object%5D&originHeight=470&originWidth=641&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3e49664b-76dc-4eb5-b4b0-c097f8dfce4&title="></p><h3 id="4）-技术架构图"><a href="#4）-技术架构图" class="headerlink" title="4） 技术架构图"></a>4） 技术架构图</h3><p>应用架构本身只关心需要哪些应用系统，哪些平台来满足业务目标的需求，而不会关心在整个构建过程中你需要使用哪些技术。技术架构则是应接应用架构的技术需求，并根据识别的技术需求，进行技术选型，把各个关键技术和技术之间的关系描述清楚。<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/5374140/1655783877222-7efd76f7-c015-4476-a4cd-0f42ab505d75.webp#clientId=ubcde7e11-5334-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=460&id=u27cbd549&margin=%5Bobject%20Object%5D&originHeight=601&originWidth=587&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2226a321-0f5f-404b-9b3c-f7b9971ae5b&title=&width=449"><br>技术架构是将数据架构和应用架构落实下去，通过技术的手段实现出来。主要包括架构规划和技术选型等事项。架构规划包括网络、平台、语言、中台、微服务等概念规划；技术选型主要是具体到某个产品时技术方案的选型，包括开源框架、语言、架构风格、数据库、中间件等。<br><strong>技术架构解决的问题包括：纯技术层面的分层、开发框架的选择、开发语言的选择、涉及非功能性需求的技术选择</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655743063771-cb287b7e-9c92-42d2-90e3-24b75a7b19ac.png#clientId=uf015c360-51e4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=421&id=u5f9791b3&margin=%5Bobject%20Object%5D&originHeight=615&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9c9d20d2-bce8-4db2-bd86-2e2760bf4a6&title=&width=740"><br>一般要求从技术层面描述系统。技术架构就是对在业务架构中提出的功能（或服务）进行技术方案的实现，包括软件系统实现、操作系统选择和运行时设计。<br><strong>一般分为单个系统和分布式系统</strong><br><strong>单个系统</strong><br>主要体现分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架、组件，例如 Spring、hibernate、ioc、<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=MVC&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">MVC</a>、成熟的类库、中间件、WebService 等，分别说明，要求这些技术能够将整个系统的主要实现概括。注意：千万不要把技术架构图画的花里胡哨的，颜色配色不要太多。<br>技术架构图的要求是：精准、明确、简练。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655741939413-3842e8f6-157d-4a79-af11-61f66fe3b26b.png#clientId=ueae83a84-81c4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=564&id=ub0e68f3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=688&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=343914&status=done&style=none&taskId=u37c198e5-0427-4b9c-a6fe-cb442544644&title=&width=590" alt="image.png"><br>还有一种是框架类的，例如 struts 的技术架构图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655741986129-2ea2ce55-098a-4362-bcc5-72b1736c02cd.png#clientId=ueae83a84-81c4-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1094b7c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=537&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=257655&status=done&style=none&taskId=u5d12d9d6-e761-468c-bbb9-d053f5f105c&title=" alt="image.png"></p><p><strong>分布式系统</strong><br>但是，现在更多的情况，是多个系统模块，组成一个大的分布式系统，或者现存多个系统的情况下，需要进行集成开发一个产品。<br>这样的话，技术架构，就是高层级的技术架构了，不仅仅体现的是技术组件了，而是更高层级的一些模块，甚至规范。<br>例如蚂蚁金服的分布式金融核心套件中，就从较为高的角度给出了一整套的技术架构、方案，甚至还体现了规范标准。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655742029755-ff844687-2041-4a3e-8a81-7cc231c3fa44.png#clientId=ueae83a84-81c4-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub31e1ad3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=421&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=393591&status=done&style=none&taskId=u230b5cfd-e7eb-4177-8986-553d3d8cdfe&title=" alt="image.png"></p><h3 id="5）部署架构图"><a href="#5）部署架构图" class="headerlink" title="5）部署架构图"></a>5）部署架构图</h3><p>物理部署图，重要性稍次，但是如果公司中的运维是单独的团队的话，就非常有必要了。<br>物理部署图主要体现如下几点：</p><ol><li>体现机房<br>很多是两地三中心这种异地容灾配置，需要体现出来部署的数据中心机房的不同。</li><li>体现物理服务器个数、配置<br>如果是物理服务器的话，数量少的话，有几台就画几个图，并且明确下来配置。例如 8C32G160G。<br>如果是容器化云配置，可以后面写一个类似 X4 这样的处理。</li><li>体现网络分区关系<br>一般机房，可能划分外联区、后台区；之间的网络是隔离的，需要开通网络关系。<br>一些网络前置之类，需要部署在哪个区域也要标明。</li><li>体现数据库、高可用<br>数据库的类型，高可用方式要简单体现出来，起码也要写上 HA 字样。</li><li>体现负载均衡<br>例如使用了多少 F5，或者 Nginx。</li><li>必要的时候可以写上分配的 IP，以及部署的应用英文缩写等信息<br>这个完全是为了提供全量信息，方便后续运维等人员查看。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1655776387724-f49cdfc8-c1c4-4ca8-8f44-1de96a00c654.png#clientId=ufa09a3f4-63f8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=518&id=u2c89e5f6&margin=%5Bobject%20Object%5D&originHeight=664&originWidth=513&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua379ae86-c6b5-4cb0-8099-6a977662572&title=&width=400"></p><h2 id="画架构图分四步走"><a href="#画架构图分四步走" class="headerlink" title="画架构图分四步走"></a>画架构图分四步走</h2><p>第一，搞清楚要画的架构图的类型；<br>第二，确认架构图中的关键要素（比如产品、技术、服务）；<br>第三，梳理关键要素之间的关联：包含、支撑、同级并列等；<br>第四，输出关联关系清晰的架构图。</p><h2 id="架构图点线规范"><a href="#架构图点线规范" class="headerlink" title="架构图点线规范"></a>架构图点线规范</h2><p>矩形，一般用于表达逻辑或者模块、系统等实体，独立的边界。<br>矩形里面是圆角矩形，可以有各个层次的具体内容、模块。<br>虚线，用来做逻辑上的归类。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最详尽教程完整介绍-Windows 的 Linux 子系统-WSL1&amp;WSL2</title>
      <link href="2022/03/17/yuque/aeqg7c/"/>
      <url>2022/03/17/yuque/aeqg7c/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-WSL"><a href="#安装-WSL" class="headerlink" title="安装 WSL"></a>安装 WSL</h2><h3 id="1-开启-WSL"><a href="#1-开启-WSL" class="headerlink" title="1. 开启 WSL"></a>1. 开启 WSL</h3><p>必须启用“适用于 Linux 的 Windows 子系统”可选功能并重启，然后才能在 Windows 上运行 Linux 发行版。</p><p>以管理员运行 Powershell（开启 WSL，如已开启可跳过）<br>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux<br>Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform –启用“虚拟机平台”可选组件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647529996839-81ae83f6-9e0f-4ccb-82e6-c84f859898d9.png#clientId=u55907c36-f633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=302&id=u9c5fc070&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=362&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=18666&status=done&style=none&taskId=uf0cfaa3f-8717-427a-82a6-6872236ef20&title=&width=362" alt="image.png"></p><h3 id="2-安装-WSL-Linux-发行版本"><a href="#2-安装-WSL-Linux-发行版本" class="headerlink" title="2. 安装 WSL Linux 发行版本"></a>2. 安装 WSL Linux 发行版本</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647529645130-53f28a96-1707-463d-b93b-50b32ceded25.png#clientId=u55907c36-f633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=503&id=ucd1bea0f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=521&originWidth=812&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=41717&status=done&style=none&taskId=u6b677060-0ea0-4f4f-9375-4addf7b0f47&title=&width=784" alt="image.png"></p><h2 id="比较-WSL-1-和-WSL-2"><a href="#比较-WSL-1-和-WSL-2" class="headerlink" title="比较 WSL 1 和 WSL 2"></a>比较 WSL 1 和 WSL 2</h2><p>WSL 1 和 WSL 2 之间的主要区别在于，在托管 VM 内使用实际的 Linux 内核、支持完整的系统调用兼容性以及跨 Linux 和 Windows 操作系统的性能。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647529681660-86e8e026-27aa-4448-a294-8760783cefa3.png#clientId=u55907c36-f633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u1d46ce81&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=648&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=19272&status=done&style=none&taskId=u5a473192-25aa-46cf-af01-8139782167d&title=&width=607" alt="image.png"></p><p>WSL2 相比 WSL1 来说可以完美支持 Docker。与 WSL1 的模拟 Linux API 不同的是，WSL2 采用在 Hyper-V 虚拟机中运行的方案。可以说 WSL2 和原汁原味的 Linux 已经十分接近</p><ul><li>WSL1 没有 Linux 内核，不支持 docker；WSL2 是有 Linux 内核的轻量化虚拟机，支持 docker。</li><li>目前 docker 已经针对 WSL2 做了适配，安装时检测到 WSL2 就会启用 WSL2 后端，不仅能同时在 Windows 和 WSL 下操作 docker 服务器，还比以前的 docker on Windows 启动更快、占用资源更少。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647530278119-6fa66970-364c-45d9-a44d-8270b9e6d642.png#clientId=u55907c36-f633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=u0df7cf05&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=960&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=33171&status=done&style=none&taskId=ubbf05da7-64c3-47a5-8c65-3f80d1e4469&title=&width=960" alt="image.png"></p><h3 id="WSL1"><a href="#WSL1" class="headerlink" title="WSL1"></a>WSL1</h3><p>不支持 Docker 的守护进程，但您可以使用<a href="https://nickjanetakis.com/blog/get-to-know-dockers-ecosystem#docker-cli">Docker CLI</a>连接到通过<a href="https://nickjanetakis.com/blog/should-you-use-the-docker-toolbox-or-docker-for-mac-windows">Docker for Windows</a>或您创建的任何其他 VM 运行的远程 Docker 守护进程</p><p>不能完全兼容 systemctl, systemd 等等，IO 速度相对原生 Linux 也是大打折扣，在编译和解压方面可以很深体会到。毕竟不是真正的 Linux，而是挂在 Windows NT 内核之上的仿 Linux 系统<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647533841852-102dae5e-fe63-4b38-a3af-3f19c667cb82.png#clientId=uaa6e97b1-f84b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=464&id=ue727b28e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=464&originWidth=870&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=334227&status=done&style=none&taskId=u039006c7-43b5-4d8d-ab71-f198b0842bf&title=&width=870" alt="image.png"></p><h4 id="WSL1-与-Docker-集成"><a href="#WSL1-与-Docker-集成" class="headerlink" title="WSL1 与 Docker 集成"></a>WSL1 与 Docker 集成</h4><p>由于 WSL 还不是原生的 Linux，所以需要借助<strong>Docker for Windows</strong>来实现 Docker（Docker for Windows 是基于 Hyper-V 技术）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647616126156-5387dd7a-bd51-4963-a6a0-5bb5305bc700.png#clientId=u28df5a07-27f3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=u31873250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=515&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=33307&status=done&style=none&taskId=u70c242e1-b9fc-4821-a79d-5768836e12e&title=&width=515" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647616081225-3327d150-8261-4238-8967-53efc10feb01.png#clientId=u28df5a07-27f3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=396&id=u586aaa98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=499&originWidth=936&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62026&status=done&style=none&taskId=ud8cba253-3a84-4e60-9f99-808195c821e&title=&width=743" alt="image.png"></p><p>另外一种方式是，在 WSL1 中安装 docker 客户端，连接 docker server, 来解决在 WSL1 上使用 docker 的问题。（PS: Win10 的 Linux 子系统是装不了 docker （服务端）的，但是可以安装客户端）</p><p>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br>curl -fsSL <a href="https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg">https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg</a> | sudo apt-key add -<br>sudo apt remove gpg<br>sudo apt install gnupg1<br>sudo apt install software-properties-common<br>sudo add-apt-repository “deb [arch=amd64] <a href="https://mirrors.aliyun.com/docker-ce/linux/ubuntu">https://mirrors.aliyun.com/docker-ce/linux/ubuntu</a> $(lsb_release -cs) stable”<br>sudo apt-get -y update<br>sudo apt-get -y install docker-ce<br>echo “export DOCKER_HOST=tcp://localhost:2375” &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647616722592-6ac604ac-c5c6-46fe-8f2b-0a550f9e2518.png#clientId=u28df5a07-27f3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=172&id=uc4a8fc78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=761&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16568&status=done&style=none&taskId=u7e69bcf6-6297-4b0c-8ad3-cc566a22bfb&title=&width=761" alt="image.png"></p><p><strong>参考</strong></p><ul><li>Running Docker containers on Bash on Windows 来自 &lt;<a href="https://blog.jayway.com/2017/04/19/running-docker-on-bash-on-windows/">https://blog.jayway.com/2017/04/19/running-docker-on-bash-on-windows/</a>&gt;</li><li>Setting Up Docker for Windows and WSL to Work Flawlessly 来自 &lt;<a href="https://nickjanetakis.com/blog/setting-up-docker-for-windows-and-wsl-to-work-flawlessly">https://nickjanetakis.com/blog/setting-up-docker-for-windows-and-wsl-to-work-flawlessly</a>&gt;</li></ul><h3 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h3><p>WSL2 是第二代 WSL，包含在 2020 年 5 月正式发布 Windows 10 v2004 版中。相比第一代，新的 WSL2 重新设计了架构，使用真正的 Linux 内核，几乎具有 Linux 的所有完整功能。启用 WSL2 的 Linux 系统启动时间非常快，内存占用很少，并且，WSL 2 还可以直接原生运行 Docker，VS Code 编辑器还有 Remote-WSL 插件，相对于完整的 linux 虚拟机只是不支持 systemctl、systemd，不能直接运行图形桌面。Windows 也越来越向虚拟平台靠拢，Windows NT 内核和 Linux 内核都是运行在虚拟平台之上的，是平级的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647616950907-526c1f16-0ef6-4528-bf9c-c05ad353ad23.png#clientId=u28df5a07-27f3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=udf317e50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=424&originWidth=700&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=161175&status=done&style=none&taskId=u34a1417d-a3db-434d-a330-5bcb98aebab&title=&width=549" alt="image.png"></p><blockquote><p>We will replace the Hyper-V VM we currently use by a WSL 2 integration package. This package will provide the same features as the current Docker Desktop VM: Kubernetes 1-click setup, automatic updates, transparent HTTP proxy configuration, access to the daemon from Windows, transparent bind mounts of Windows files, and more.</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647619834250-3722735b-210f-4122-8477-4d995f108138.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=574&id=UBGi4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=622&originWidth=1110&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=317756&status=done&style=none&taskId=uf878cd46-b291-49f8-9a0b-74e7aeb633d&title=&width=1024" alt="image.png"></p><h4 id="升级到-WSL2"><a href="#升级到-WSL2" class="headerlink" title="升级到 WSL2"></a>升级到 WSL2</h4><p>如果发现 VERSION 为 1，说明 Ubuntu 运行在 WSL1 下，可以升级到 WSL2。同样，WSL2 也可以降级到 WSL1。<br>wsl -l -v #查看已安装 Linux 版本和名称，完整命令格式：wsl –list –verbose<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647616963376-c6e9a539-a9a5-4c50-abf6-e6f9ae876e2e.png#clientId=u28df5a07-27f3-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub80c7cd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=109&originWidth=453&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=6138&status=done&style=none&taskId=u07270dbe-1c37-41d4-9504-d3451b31c2d&title=" alt="image.png"><br>**WSL2 需要 Windows build 18917 更新, **WSL 不需要. 但是最好首先将操作系统更新到需要的版本, 而不是先安装 WSL 再更新<br>WSL 2 需要更新其内核组件。有关信息，请访问<br><a href="https://link.zhihu.com/?target=https://aka.ms/wsl2kernel">https://aka.ms/wsl2kernel</a></p><p><strong>具体步骤参考 ：</strong> <a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4—download-the-linux-kernel-update-package</a></p><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647617434043-68363fa6-e74a-4283-89fb-d16fe8221f6a.png#clientId=ue97c3a5d-fad2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=241&id=u65f1cc33&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=780&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9529&status=done&style=none&taskId=u50de9bcb-7236-4b89-9e8d-08c57abdd9b&title=&width=780" alt="image.png"><br>wsl –set-version Ubuntu 2 #升级到 WSL2，其中 Ubuntu 是已经安装的 Linux 名称，命令格式：wsl –set-version <Distro> <Version><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647617953943-e6163a14-614d-44fc-8281-c81eb38c43ae.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=302&id=u350b9ea1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=571&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32341&status=done&style=none&taskId=u4f963d55-e5c6-4b21-a9be-69bea82a2ba&title=&width=571" alt="image.png"></p><p>启用 WSL 后，通过 \wsl$ 可以访问 WSL 文件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647618355710-9d079dcd-3727-4609-8aba-6d917d86b611.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=121&id=mVv0w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=555&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4995&status=done&style=none&taskId=u423ce7dd-5202-4a2e-a61c-7b61c8aac2b&title=&width=555" alt="image.png"></p><h4 id="WSL2-与-docker-集成"><a href="#WSL2-与-docker-集成" class="headerlink" title="WSL2 与 docker 集成"></a>WSL2 与 docker 集成</h4><p>最初的 WSL 是在 Windows 之上模拟 Linux 内核，但是 Windows 和 Linux 之间存在如此基本的差异，以至于某些事情不可能以与本机 Linux 相同的行为实现，这意味着不可能直接在 WSL 中运行<a href="https://www.docker.com/products/container-runtime">Docker Engine</a>和 Kubernetes<br>在 WSL1 中，Docker Desktop 通过 Hyper-V 虚拟机去运行 docker 环境的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647618906482-1ce2161d-012d-48ec-b487-600ccf945eb6.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=418&id=u75be4e9d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=481&originWidth=1127&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=48195&status=done&style=none&taskId=u1628185b-5aef-482a-895a-ff1d96a6523&title=&width=979" alt="image.png"></p><p>升级到 WSL2 之后， Docker Desktop 可以直接用 WSL2，直接运行在 Linux 内核上了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647618842640-e61a1930-1d25-4900-8689-4153f8d54276.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u5ed60b91&margin=%5Bobject%20Object%5D&name=image.png&originHeight=316&originWidth=550&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=75614&status=done&style=none&taskId=u1dd5d3c4-9729-4fbb-9d46-0f083d04fb1&title=&width=516" alt="image.png"><br>通过如下设置，Docker Desktop 就和 WSL2 分发版本进行了集成，无需在 WSL 中安装 docker; 当然，也可以选择不与 Docker Desktop 集成，直接在 WSL 中运行 docker 容器。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647618808924-559ee531-d44e-4877-8dd0-dc2690b4fda7.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=u1d167c66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=813&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31377&status=done&style=none&taskId=u2fb22b61-3ced-45a8-abcb-961e4e9cd28&title=&width=740" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647619069350-62cf0d62-6dda-40a1-be1b-e6f82362b58d.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=uc6d43112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=742&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24409&status=done&style=none&taskId=u313a8091-4213-4b90-b84a-06c993ba48d&title=&width=742" alt="image.png"><br>启用 WSL 后，docker 运行数据都在 WSL 发行版中，文件位置都只能由 WSL 管理</p><p>安装 docker 后，docker 会自动创建 2 个发行版：</p><ul><li>docker-desktop</li><li>docker-desktop-data</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647619110994-00cd41be-1a83-4304-b451-0ee7e1326626.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=121&id=mivs6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=483&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11593&status=done&style=none&taskId=u8d6ad613-c09b-4b87-8b2f-249173389f8&title=&width=483" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647619089784-c4b415b0-f466-493d-b9b6-17b873e28259.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=171&id=u519fbe52&margin=%5Bobject%20Object%5D&name=image.png&originHeight=171&originWidth=779&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10412&status=done&style=none&taskId=u6756944a-05dc-48d7-9390-e886d67d4f5&title=&width=779" alt="image.png"><br>WSL 发行版默认都是安装在 C 盘，在%LOCALAPPDATA%/Docker/wsl 目录<br>docker 的运行数据、镜像文件都存在%LOCALAPPDATA%/Docker/wsl/data/ext4.vhdx 中</p><p>通过 WSL 2 集成，您仍然可以体验到与 Windows 的无缝集成，但在 WSL 中运行的 Linux 程序也可以执行相同的操作。这对于从事面向 Linux 环境的项目或为 Linux 量身定制的构建过程的开发人员产生了巨大影响。不再需要维护 Linux 和 Windows 构建脚本！例如，Docker 的开发人员现在可以在 Windows 上的 Linux Docker 守护程序上工作，使用与 Linux 计算机上的开发人员相同的工具和脚本集：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/5374140/1647620311643-f99812b7-f6c2-4594-a564-587eb487b996.gif#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u83c87f14&margin=%5Bobject%20Object%5D&originHeight=563&originWidth=1000&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89614f24-5cc9-4d9c-b6e0-e994e186d4f&title="></p><p>注：WSL2 Docker 最爽的地方是和宿主机 Win10 共享 network，我们在宿主机 Win10 使用 localhost 加端口号就可以访问 Docker 中对应 container 中的服务，十分方便<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647622786592-610e435f-4e22-4d54-8a4d-a41f7c69f524.png#clientId=u3e440c5d-9b01-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=288&id=u808edd32&margin=%5Bobject%20Object%5D&name=image.png&originHeight=345&originWidth=1218&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=48052&status=done&style=none&taskId=u5d33b5c5-a941-4325-a209-9df3d3f591c&title=&width=1018" alt="image.png"></p><h2 id="WSL-使用"><a href="#WSL-使用" class="headerlink" title="WSL 使用"></a>WSL 使用</h2><p>wsl #启动<br>wsl –shutdown #关闭所有正在运行的 Linux 和 WSL 2</p><p>启动 WSL2 之后，会在任务管理器中发现多了一个 虚拟机工作线程<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647620476353-e781c988-b01d-4236-8ead-2a8ab68e48aa.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2bb541df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=59&originWidth=602&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=23165&status=done&style=none&taskId=u444d5e68-0b19-43ae-96fe-74c0aa65b59&title=" alt="image.png"></p><p><strong>访问 wsl 文件</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1647620476354-618523e3-db05-4a76-9ee2-247a70183e7b.png#clientId=ub4b3da5e-c2f5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7f0c1378&margin=%5Bobject%20Object%5D&name=image.png&originHeight=287&originWidth=598&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=21869&status=done&style=none&taskId=u3520d4f7-df82-4068-a6bf-94348981365&title=" alt="image.png"></p><p><strong>卸载发行版</strong><br>有时候某个 Linux 发行版不再使用，或者是环境被搞坏需要重装，这时候我们可以卸载掉这个 Linux 发行版。方法如下。</p><ul><li>首先使用：wslconfig /l 命令查看系统内安装的 Linux 发行版。</li><li>然后使用：wslconfig /u &lt;发行版名称&gt;卸载掉指定的发行版 Linux。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊DevOps制品管理-不止是存储制品这么简单</title>
      <link href="2022/01/14/yuque/rqeiq5/"/>
      <url>2022/01/14/yuque/rqeiq5/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是制品？"><a href="#什么是制品？" class="headerlink" title="什么是制品？"></a>什么是制品？</h2><p><strong>制品</strong>是指由源码编译打包生成的二进制文件，不同的开发语言对应着不同格式的二进制文件；这些二进制文件通常用于运行在服务器上或者作为编译依赖,“制品的管理”是配置管理的重要组成部分。</p><p>通常，这些组件是各种文件的存档，包括：类文件中的 Java 字节码、C 对象文件、文本文件、二进制文件。组件的多种格式，例如：Java JAR，WAR，EAR 格式；普通 ZIP 或.tar.gz 文件；其他软件包格式，例如 NuGet 软件包，Ruby gems，NPM 软件包；可执行文件格式，例如.exe 或.sh 文件，Android APK 文件，各种安装程序格式。</p><p><strong>按照使用场景，制品大致分为三类</strong></p><ol><li>外部引入的第三方组件</li><li>产品内部依赖包，公共 SDK</li><li>产品交付安装包</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1642823900704-0695efe9-03f9-4062-abf7-af2317b67fc2.png#clientId=u121e30f5-3b13-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=ue8d0710f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=537&originWidth=1437&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=185047&status=done&style=none&taskId=u1d66f15d-a104-4630-8a08-826682730f3&title=&width=870" alt="image.png"><br><strong>按照开发语言，制品类型包含以下类型：</strong></p><ul><li>Generic File 指的是通用文件类型的制品。</li><li>Docker</li><li>Maven</li><li>npm</li><li>PyPI</li><li>Helm</li><li>Composer</li><li>NuGet</li><li>Conan</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645267322133-1627f1ab-7d1c-43d4-9ee7-ef23570e2d4c.png#clientId=ua5ff6c33-2b41-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=158&id=u621d9a5c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=1072&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=120065&status=done&style=none&taskId=uf5e19b33-af68-4c8c-8278-8d8fcdd0b68&title=&width=849" alt="image.png"></p><h2 id="为什么要制品管理？"><a href="#为什么要制品管理？" class="headerlink" title="为什么要制品管理？"></a>为什么要制品管理？</h2><ol><li>外部依赖下载慢</li></ol><ul><li>影响研发构建速度</li></ul><ol start="2"><li>版本管理混乱 （svn,ftp）</li></ol><ul><li>交付包使用 FTP 或者 SVN 进行管理，管理粒度相对较粗；在这种粗放式的制品管理方式下，不同类型包的存储与获取是一件头疼的事情，版本追踪极其混乱，团队协作也是障碍重重。</li><li>由于受到监管约束，一键部署是不可能任务，跨网段的包交付智能依赖于手工拷贝</li></ul><ol start="3"><li>安全漏洞风险</li></ol><ul><li>依赖组件越多，引入漏洞的风险也越高</li><li>第三方依赖包下载管理混乱，没有准入管控</li><li>漏洞藏的越深，修复漏洞所花费的时间就越长</li></ul><ol start="4"><li>制品存储风险</li></ol><ul><li>团队内部搭建的制品库是单点的，缺乏集群部署</li></ul><ol start="5"><li>资源浪费</li></ol><ul><li>因为没有统一的制品库，存在重复建设的问题；维护成本高，或者说目前根本就没有维护</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1642823993983-ad099612-d7b2-4b7b-8c8d-9f9394846ded.png#clientId=u121e30f5-3b13-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=401&id=pMAbI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=481&originWidth=747&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=283692&status=done&style=none&taskId=u50504f7e-da1d-4ea6-94d3-0d4e4898dbf&title=&width=623" alt="image.png"></p><h2 id="制品和-CI-CD-流水线"><a href="#制品和-CI-CD-流水线" class="headerlink" title="制品和 CI/CD 流水线"></a>制品和 CI/CD 流水线</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645230369369-92f7e8b2-4228-4df0-80a6-e4d2f981b5ed.png#clientId=u67e39b42-944c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=364&id=fgt5w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=1110&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=209092&status=done&style=none&taskId=ucc898842-dd0f-4db5-9045-df489ef5ae4&title=&width=737" alt="image.png"><br>对于 CI/CD 流水线而言，制品起到一个<strong>承上启下</strong>的关键作用，它是持续集成 CI 的终点，同时也是持续交付 CD 的起点。</p><p>如果缺乏有效的制品管理策略和工具，根本不可能建立高效的流水线；脱离制品管理，每次只能重新从代码开始构建，对于任何企业组织是不可接受的，同时也不符合“一次构建，多次使用”的原则。</p><p>在整个研发过程中，制品对于测试人员和运维人员至关重要，他们关注的是怎么拿到需要的版本进行测试和部署，如果缺乏有效的制品管理，整个 DevOps 价值流就会出现衔接上的问题。你可能会碰到这种情况，测试同学会通过各种方式去询问那个版本可以测试，包在哪里等情况。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1642824037961-c73ebd96-709f-406e-b881-cc24cadaa162.png#clientId=u121e30f5-3b13-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=285&id=bWd6A&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1507&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=215076&status=done&style=none&taskId=ufb92dac4-f0a1-4986-b809-558ab14b889&title=&width=714" alt="image.png"></p><h3 id="包的元数据"><a href="#包的元数据" class="headerlink" title="包的元数据"></a>包的元数据</h3><p>何为包的元数据？别人给你一个包，你怎么知道包里包含了哪些需求缺陷变更，包含了哪些代码提交，还有包的 md5,hash 等信息。这些信息对于测试人员<strong>追踪问题的引入，后续改进，版本回归</strong>至关重要，通俗点说，弄清楚制品的前世今生。</p><p>那么这些信息哪里来？当然是持续构建 CI 流水线，需求，代码提交都可以通过 CI 流水线收集。如果你的组织购买过 Jfrog 的产品，会发现这个特点在的它的平台上尤为突出。</p><h3 id="制品的晋级"><a href="#制品的晋级" class="headerlink" title="制品的晋级"></a>制品的晋级</h3><p>在开发实践中，大多数团队会准备 DEV, TEST, UAT, RELEASE 等不同的环境，相应的建设不同的流水线，将制品部署到不同的环境前都会对制品进行不同的测试，所里这里也衍生出来了制品的晋级，就是给制品设置不同的准入门禁。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645256523287-5c6006cd-3a23-4e87-90e9-ccd42a9504b6.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=389&id=ued8e2eda&margin=%5Bobject%20Object%5D&name=image.png&originHeight=771&originWidth=1426&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=450246&status=done&style=none&taskId=ua9c9bdc8-b6ee-45db-ae5a-76683021381&title=&width=719" alt="image.png"><br>综上所属，制品和 CI/CD 流水线有着紧密的联系，不可分割，在设计流水线时候要考虑好制品的使用场景。</p><h2 id="制品管理工具"><a href="#制品管理工具" class="headerlink" title="制品管理工具"></a>制品管理工具</h2><p>如上所述，由于制品管理的重要性，所以衍生出来对应的制品解决方案用来统一管理不同格式的软件制品。 除了基本的存储功能，还提供了版本控制、访问控制、安全扫描、依赖分析等重要功能，最终建立“单一可信源”，是一种企业处理软件开发过程中产生的所有包类型的标准化方式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645233233874-12d53638-566a-478e-8d3a-08493b2c8482.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=u10120188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=733&originWidth=1342&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=208058&status=done&style=none&taskId=ubcc0a23c-52bf-498b-b69c-5c477dad9c3&title=&width=630" alt="image.png"><br>目前主市场上主流的制品管理工具主要有以下几种：</p><h3 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a>Nexus</h3><p>Nexus 是一套“开箱即用”的系统不需要数据库，它使用文件系统加 Lucene 来组织数据。Nexus 使用 ExtJS 来开发界面，利用 Restlet 来提供完整的 REST APIs，通过 m2eclipse 与 Eclipse 集成使用。Nexus 支持 WebDAV 与 LDAP 安全身份认证。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645233361951-aeac567a-cd45-44ca-a8aa-db28b2660d1f.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=327&id=uff8aff58&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=1136&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=84390&status=done&style=none&taskId=u2fcd7445-f5b0-4150-b340-55005b55042&title=&width=794" alt="image.png"></p><p>Nexus 是少有的支持几乎所有主流制品格式，并且提供免费版的制品管理产品，这也是大多数中小公司的选择，可以满足大部分业务场景，但是，免费版不提供高可用方案。<br>价格参考： <a href="https://www.sonatype.com/products/pricing?topnav=true">https://www.sonatype.com/products/pricing?topnav=true</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645233543803-24699daf-ea08-4010-8cd1-dc682808f738.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=263&id=XYAs0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=342&originWidth=1098&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=46136&status=done&style=none&taskId=u67702115-1cb7-4826-abfb-7822d936c42&title=&width=844" alt="image.png"><br>由于 Nexus 在国内没有代理商，所以大家对它的认知还有限，其实 Nexus 仅仅是<a href="https://www.sonatype.com/">sonatype</a>产品解决方案的一种，提供对软件研发周期的制品管理方案。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645250966191-b5b66c09-0c2d-4a83-9295-0beaf0116cf3.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=388&id=u35b8f518&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=1225&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=74569&status=done&style=none&taskId=u6e6fc659-b162-45a4-8215-fc36de5fd6a&title=&width=751" alt="image.png"></p><h3 id="Jfrog-Artifactory"><a href="#Jfrog-Artifactory" class="headerlink" title="Jfrog Artifactory"></a>Jfrog Artifactory</h3><p>Jfrog 是一家以色列公司，专注于制品管理环境，提供商用的解决方案，所以它的产品是要花钱的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645251112457-2a78691d-229b-4a32-99f8-207cc8265901.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=352&id=ub5811adb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=539&originWidth=1181&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=144244&status=done&style=none&taskId=uee218f2f-8c30-437e-97a1-52f9bb89c03&title=&width=772" alt="image.png"><br>下图列出了 Jfrog Artifactory 和 Nexus 的产品特点对比，仅供参考。既然是掏钱买的，肯定比免费的 Nexus 提供的支持和服务更多，包括高可用，组件的漏洞风险分析，多地分发等等。不是说 Nexus 不行，而是我们大家用的大部分都是 Nexus 的免费版，其实它的收费版也提供类似的方案。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645233474360-66441376-234d-4fdc-a0cb-c0f7c303c54a.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=412&id=u0da0eae5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=757&originWidth=1417&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=415674&status=done&style=none&taskId=u941b21fe-7565-48e1-a8a9-0a489473d88&title=&width=771" alt="image.png"></p><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h3><p>Harbor 是 VMware 公司<strong>开源</strong>的企业级 Docker Registry 项目，其目标是帮助用户迅速搭建一个企业级的 Docker registry 服务。</p><p>基于官方 Registry V2 实现，提供了管理 UI，基于角色的访问控制(Role Based AccessControl)，AD/LDAP 集成、以及审计日志(Auditlogging) 等企业用户需求的功能，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源 Docker Distribution。</p><p>Harbor 目前已经成为私有 Docker/Helm 管理的主要工具，相比于 Nexus, Harbor 在 docker 镜像的管理方面更有优势，提供镜像同步服务，支持团队项目隔离。在实践过程中，笔者发现 Nexus 在 docker 镜像的团队隔离方面上，存在一些问题。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645250918970-c35307b7-fdd5-4d04-bd5b-0b58f140744d.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=356&id=u68823e5a&margin=%5Bobject%20Object%5D&name=Snipaste_2022-02-19_09-39-12.png&originHeight=653&originWidth=1656&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=59534&status=done&style=none&taskId=u4d41760c-8046-4d62-99e1-4117d219f68&title=&width=902" alt="Snipaste_2022-02-19_09-39-12.png"></p><h3 id="WePack"><a href="#WePack" class="headerlink" title="WePack"></a>WePack</h3><p>WePack 是腾讯 Coding 基于之前的 DevOps 拆分出来的单独的制品管理服务，支持私有化部署。也许也是看到单独的制品管理工具，比大而全的 DevOps 平台更好的切入用户场景吧。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645252578364-0735a6c3-8c16-4920-81d4-b5ffb918238d.png#clientId=u32c84d3f-ce40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=449&id=u1af41741&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=1259&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=185622&status=done&style=none&taskId=ua5fe50e9-18ec-4df5-82bd-4c42ad9ac9e&title=&width=937" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645253918727-2a81f443-d496-46fe-b23d-a490c58666f2.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=422&id=ud985df42&margin=%5Bobject%20Object%5D&name=image.png&originHeight=582&originWidth=825&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27771&status=done&style=none&taskId=uaac9fe92-3a70-4753-a6f3-a7cf68f518b&title=&width=598" alt="image.png"></p><h2 id="如何管理制品？"><a href="#如何管理制品？" class="headerlink" title="如何管理制品？"></a>如何管理制品？</h2><p>为了统一管理不同语言格式的包，以上制品管理工具几乎都按照如下方式管理组织制品。</p><p>制品库的层级关系为：仓库 &gt; 包 &gt; 版本，每个层级描述如下：</p><ul><li>仓库：用于管理不同类型的仓库和仓库下的包资源，可以设置仓库对外的访问权限。</li><li>包：构建产物对外提供访问的基础单元，用于介绍当前构建产物的用途和使用指引。</li><li>版本：列出某个包下的所有构建产物，详细记录了每次构建产物的版本迭代更新变化。</li></ul><h3 id="规范制品库命名"><a href="#规范制品库命名" class="headerlink" title="规范制品库命名"></a>规范制品库命名</h3><p>如果团队比较大一，对制品管理的要求不高，按照以上方式基本可以满足需求。但是，如果建设公司级别的需要规范一些命名，如下所示<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645255559771-f899a6fe-88be-4f0d-bb83-00f298e9aada.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=265&id=u6022370a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=347&originWidth=724&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=157657&status=done&style=none&taskId=ue6fb1d84-b1ab-4c5e-aa05-e4cca362c95&title=&width=553" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645255681369-681e076d-25fa-4e50-b05c-83e8c9e6f60b.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=u7328dc04&margin=%5Bobject%20Object%5D&name=image.png&originHeight=229&originWidth=630&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=101436&status=done&style=none&taskId=u10251052-30bd-4098-b513-a724864e365&title=&width=544" alt="image.png"></p><h3 id="制品版本号规范化"><a href="#制品版本号规范化" class="headerlink" title="制品版本号规范化"></a>制品版本号规范化</h3><p>制品的版本号用于标记特定制品，通过规范化命名有助于自动化脚本的编写和流水线的复用。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645256398308-12e40a28-76ee-480d-886d-5c60a79c95cd.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=uaf87485c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=419&originWidth=855&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=97627&status=done&style=none&taskId=u653f85d6-a94a-4c2e-a182-fe4ab86a77a&title=&width=680" alt="image.png"></p><h3 id="制品库权限规范化"><a href="#制品库权限规范化" class="headerlink" title="制品库权限规范化"></a>制品库权限规范化</h3><p>不管是基于开源工具，还是自研工具，基于制品仓库的权限设计也是必要的，做到团队产品的隔离。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645256280495-92d355a2-7097-4d87-9d77-21622d860083.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=394&id=u90b3be92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=996&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=238690&status=done&style=none&taskId=u8ace3334-18bb-43c2-b4d7-c921ec84e32&title=&width=721" alt="image.png"></p><h2 id="开源制品的安全风险"><a href="#开源制品的安全风险" class="headerlink" title="开源制品的安全风险"></a>开源制品的安全风险</h2><p>对于制品的管理，大多人数都停留在仅仅是存储，拉取使用的想法，笔者今年前也是这种思维。2021 年末的 Log4j2 的安全事件，引起了整个 IT 圈的轩然大波，这个开源组件几乎涉及所有的 java 应用，每个公司不得不紧急排查自己产品是否引入该风险。</p><p>通过该事件，让我们开始关注开源组件可能存在的风险，这也是目前比较热门的研发过程中的“<a href="https://baijiahao.baidu.com/s?id=1709504114617115003%ED%94%B4=spider&for=pc">供应链安全</a>”，也是 DevSecOps 其中重要的一个环节。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645257211219-cbb64b0d-6fa9-4661-8e54-83886c911726.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u45e8d483&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=649&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue78b02b5-95fe-4164-90fe-5547ebd5a8c&title="><br>作为研发过程中的制品管理，引入阶段的审核机制，使用中的安全，越来越成为大家关注的热点。如果所示，组织需要引入组件审核制度，杜绝开发人员随意的拉取互联网的开源制品，并且建立实时的漏洞扫描机制，形成组织级的白名单仓库。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645257563752-00c447fb-24e0-42de-9797-90405fba89dd.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=368&id=u28d20d63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=575&originWidth=1093&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=293917&status=done&style=none&taskId=uaaa48df0-b404-4542-a36c-802b821306c&title=&width=699" alt="image.png"></p><h3 id="SBOM-软件物料清单"><a href="#SBOM-软件物料清单" class="headerlink" title="SBOM-软件物料清单"></a>SBOM-软件物料清单</h3><p>现代软件主要是使用第三方和开源组件组装而成的，它们以复杂而独特的方式融合在一起，并与原始代码集成以实现所需的功能。除了通过在开源组件引入阶段加入安全审核机制，IT 企业往往也需要关注自己开发或使用的软件产品的组成，像我们在超市购买食品时在食品包装上看到的食品配料清单，标注了所用的所有材料。</p><p>为了准确摸清软件所含组件的情况，SBOM（即：Software Bill Of Materials）应运而生，其包括多种关键信息，如：组件名称、版本号、供应商等，这些关键信息在分析软件安全时发挥着关键作用。通过这些信息，可以追溯软件的原始供应链，极大提高开发者对其所用软件安全风险的理解，帮助企业在网络安全风险分析、漏洞管理和应急响应过程中提高效率。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645266294022-3b6dcd06-d151-4c84-a794-d5d865fa1048.png#clientId=u7e7dce47-1975-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=331&id=fXZvu&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=267804&status=done&style=none&taskId=u9bdfdcb7-2a28-4433-99e7-a4d8e61a16b&title=&width=679" alt="image.png"></p><p>对软件开发企业而言，SBOM 可有效控制开源组件风险，帮助企业更早识别并消除开源组件安全缺陷和许可风险；对软件采购企业而言，SBOM 可帮助采购决策者轻松了解开发方软件是否存在开源组件风险；对软件开发人员而言，SBOM 可帮助开发人员全面准确掌握其所研发软件的开源组件情况。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645266403725-755edfe1-f9ff-467d-ab0f-68651c63a718.png#clientId=u5568aa8e-25a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=378&id=u4c62a775&margin=%5Bobject%20Object%5D&name=image.png&originHeight=465&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=114314&status=done&style=none&taskId=u79ed479b-e1b0-48bd-ae02-fb58fb29966&title=&width=585" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>制品管理是 DevOps 实践过程中的重要环节，起着承上启下，收集过程信息的重要角色；</li><li>于此同时，制品的引入使用会存在安全风险，组织需要关注这一点，避免类似 Log4j2 安全事件带来的一系列风险；</li><li>作为实践者，在制品的管理上需要结合组织和流水线需要，指定相应的规范，避免混乱；</li><li>好的制品管理流程，可减少开发自测和测试人员进行接收测试衔接过程中的低效沟通；</li></ul><p>这里仅仅是对制品管理做了全局的梳理，后续会对其中具体的知识点进行详细介绍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何设计CI/CD流水线</title>
      <link href="2021/12/20/yuque/aq3rz4/"/>
      <url>2021/12/20/yuque/aq3rz4/</url>
      
        <content type="html"><![CDATA[<p>CICD 的目标是代码的快速、可靠上线运行，它应当以 DevOps 理念落地为核心，将好的 Coding 规范、运维策略融合入 CICD 系统。</p><p>简单将其归为五化（如果包含智能化，就是六化啦，但这是个长期的、不断演进的过程，不可能一蹴而就，是技术+数据）：</p><ul><li><strong>标准化</strong>：这是 CICD 的灵魂，它是软件工程最佳实践的落地，也是企业内部规范的落地，是具有企业特色、团队风格的软件产品。很多公司开发 CICD 系统的目的也是统一发布模式，简化发布流程。有两点需要说明的是，其一，标准并非是对的，但是它是必须要遵守的，由于标准制定者的认知或是历史因素，有些标准可能并非正确，如有的团队认为 CI 和 CD 是一个事情，主张二者捆绑在一起，但是实际上，我们更倾向于二者分离。其二，标准也非一成不变的，而是持续优化改进，它需要与时俱进，适用技术需求、业务需求以及开发人员诉求。</li><li><strong>可配置化</strong>：CICD 系统要提供一些配置接口，便于对一些启动参数、部署模板进行修改。但是，虽然我们支持配置，但并不主张配置，我们更倾向于约定：<strong>约定大于配置，减少不必要配置</strong>，如果配置项可以通过约定固化下来，我们不建议配置。很多软件都有丰富的配置菜单，虽然面面俱到，却又让人烦不胜烦，配置可以让功能丰富，也让操作更复杂。因而，近些年，流行“约定大于配置”，比如变量名是驼峰好呢？还是 snake 好呢？这些都是形式而已，无需同时支持，统一规范即可。</li><li><strong>自动化</strong>：自动化最好理解，通过系统替代人工，减少人工误差，节约人力成本，让人发挥其真正的价值，而非重复的劳动。</li><li><strong>可视化</strong>：让用户更好的感知 CICD 的过程，也方便其排障。可视化并非是简单的报表、图线，它应当是人机交互的接口，通过系统 UI，让开发了解进程状态，实时合规的操作进程，提供 Web 终端，让开发排障更简单。</li><li><strong>简便化</strong>：“让系统操作更简单”，说说很容易，开发之前的简便性设计，会成为上线后的用户抱怨，很多情况下，设计者并不了解用户，尤其是 CICD 这样的内部系统，没有 PM，需求全靠猜，UI 随便写，其结果就是用户全抱怨。如何做到简便化？我觉得，最简单的就是走近用户，吸收意见，不断重构。运维开发有一个很坏的观念，“反正内部使用，能用就行”，这种观念很害人，这样既会影响自己的品味，也会影响自己的 KPI。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/5374140/1640017458005-745c17fa-924f-4fca-9797-7684440db49f.jpeg#clientId=udbc8f147-cc5b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=587&id=ucb08e893&margin=%5Bobject%20Object%5D&name=9bd0ce742113937958c8b3c3f5597af0.jpg&originHeight=587&originWidth=1080&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=64971&status=done&style=none&taskId=ucc94672e-219b-468d-ab39-7ae9e2bc4f4&title=&width=1080" alt="9bd0ce742113937958c8b3c3f5597af0.jpg"></p><p><strong>四、开发过程中的一些问题</strong><br>从产品设计到目前的 2.3 版本，这一路走来，确实遇到了许多问题，有技术问题，也有观念问题，今天摘取几个分享：<br><strong>1. 交互问题</strong><br>CICD 系统并非孤立的系统，它需要与一些第三方系统协同，有时候是 API 的互通、有时候是数据的同步，因此，队友给不给力，也是很重要的。第三方系统的架构设计也会影响 CICD 的设计。比如，我们的用户权限设计就分为两套，一套是系统权限管理，另一套就是从第三方系统同步而来，因为从设计上就很难达成一致。人生是门妥协的艺术，软件也是如此，要学会向历史妥协、向第三方妥协、向企业文化妥协。<br><strong>2. 收与放的度量</strong><br>多系统协同，很容易出现这样的问题，一个功能在 A 系统中实现，和在 B 系统中实现，效果都一样，那么如何抉择呢？比如，我们在设计 Pipeline 管理时，就在这遇到问题，有人主张将 Pipeline 做成 SDK，也有的主张将 Pipeline 做成可配置的组件，我选择了后者（因为我就是主张者），因为如果将 Pipeline 做在 CICD 里，虽然以组件拼装的方式会复杂些，但是可以将一些标准固化在代码里，而如果依赖于第三方提供的 SDK，那么这些标准能否很好的遵守，就很难判断啦。<br>更复杂的是，有些时候，收与放并非技术层面的度量，而是利益的瓜葛，这往往是影响最终结果的主要因素。见过有些团队为了争夺某一应用话语权，打的是妻离子散、分崩离析。遇到这类的事情怎么办？我的观点，客观审慎、长远打算、合理建议、尊重决定。无论作何决定，都有领导层的考虑，无非是会走些弯路，但是如果不走，谁也不知道是曲是直。</p><p>真正的流水线需要具备的 15 个特性：</p><ol><li><strong>版本控制</strong></li><li><strong>最优的分支策略</strong></li><li><strong>代码静态扫描</strong></li><li><strong>80%以上的单元测试覆盖率</strong></li><li><strong>漏洞（Vulnerability）扫描</strong></li><li><strong>开源工具扫描</strong></li><li><strong>制品（Artifact）版本控制</strong></li><li><strong>环境自动创建</strong></li><li><strong>不可变服务器（Immutable Server ）</strong></li><li><strong>集成测试</strong></li><li><strong>性能测试</strong></li><li><strong>每次提交都触发：构建、部署和自动化测试</strong></li><li><strong>自动化变更请求</strong></li><li><strong>零停机发布</strong></li><li><strong>功能开关</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>企业DevOps平台建设</title>
      <link href="2021/12/15/yuque/yra64e/"/>
      <url>2021/12/15/yuque/yra64e/</url>
      
        <content type="html"><![CDATA[<h2 id="平台固化-or-灵活？"><a href="#平台固化-or-灵活？" class="headerlink" title="平台固化 or 灵活？"></a>平台固化 or 灵活？</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1639580962849-77575a1b-d455-4d6d-b90c-0449fe335efb.png#clientId=ubfdb5753-3ef4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u749ee335&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=1167&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=160713&status=done&style=none&taskId=u995f1a8a-64f5-415a-8402-6c6f79ab019&title=&width=756" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1639580988013-f41d827b-d4fc-4525-99e4-fea08b6b5b1c.png#clientId=ubfdb5753-3ef4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=u8ff1e0a5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=830&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=78595&status=done&style=none&taskId=ub67a2f68-5906-4dbd-a9ed-eabd6ebafca&title=&width=684" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1639581123076-bed381f1-02d0-440e-bc72-97d5f845f6e2.png#clientId=ubfdb5753-3ef4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=610&id=u42f01902&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1094&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=117504&status=done&style=none&taskId=ua46f0887-6701-4cfb-a918-0813be65d82&title=&width=1094" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1639581580727-6cd51fbb-5f9a-45e5-beb9-59824b732ae4.png#clientId=ubfdb5753-3ef4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=ud8595f33&margin=%5Bobject%20Object%5D&name=image.png&originHeight=305&originWidth=723&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=113456&status=done&style=none&taskId=u65ad67e1-1216-4270-bed7-2d7ba238289&title=&width=723" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CI/CD场景价值</title>
      <link href="2021/12/06/yuque/evq8l3/"/>
      <url>2021/12/06/yuque/evq8l3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/5374140/1638804962466-a11a63e6-9e0b-494b-b75c-767c548552be.jpeg#clientId=uae7271a2-a0f7-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3f1503af&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4064d7b1-e338-4e28-8f21-72ded60791b&title="></p><p>简单聊了一下个人接触的 CI/CD 演进过程的技术选型演变，接下来聊聊什么场景下需要 CI/CD ，它到底能带来什么样的变化。</p><h2 id="工作流程的变化"><a href="#工作流程的变化" class="headerlink" title="工作流程的变化"></a>工作流程的变化</h2><p>与持续集成和持续交付关联最紧密的便是研发流程，那么有 CI/CD 和没有 CI/CD 的团队分别是什么样子的呢？</p><h3 id="没有-CI-CD-的团队"><a href="#没有-CI-CD-的团队" class="headerlink" title="没有 CI/CD 的团队"></a>没有 CI/CD 的团队</h3><ol><li>项目创建</li><li>功能编写</li><li>代码提交</li><li>功能自测</li><li>代码 Review</li><li>合并发布分支</li><li>人工构建</li><li>人工部署</li><li>产品发布</li><li>人工观察线上质量</li><li>质量修复、持续改进（循环第 3 步开始的内容）</li></ol><p>上面是一个常规的单任务场景下的流程，可以看到起码有 10 个步骤：当然有的公司会省略一些步骤，诸如 Code Review；也有许多人只会接触到功能编写和提交代码几个阶段。<br>实际场景中，会更复杂一些，涉及“并行开发多个需求”、“多个完成的功能等待上线”、“部分代码进行重构，等待兼容测试”等等。<br>如果你的公司欣欣向荣，业务蓬勃发展，那么整个研发流程会浪费非常多的资源：<strong>聪明能干的工程师总是不停的做着构建、发布、大量非必要的线上人肉观察等本该机器做的事情</strong>。</p><h3 id="有部分自动化脚本的团队"><a href="#有部分自动化脚本的团队" class="headerlink" title="有部分自动化脚本的团队"></a>有部分自动化脚本的团队</h3><ol><li>项目创建</li><li>功能编写</li><li>代码提交</li><li>功能自测</li><li>代码 Review [<strong>这里可能使用了一些 lint、coverage、risk scanner 功能分摊了一些 Review 压力</strong>]</li><li>合并发布分支 [<strong>这里可能使用了一些脚本进行对非敏感内容进行自动合并</strong>]</li><li>人工构建 [<strong>有抽象构建过程为脚本，然后通过手工调用</strong>]</li><li>人工部署 [<strong>有抽象部署过程为脚本，然后通过手工调用</strong>]</li><li>产品发布 [<strong>有抽象发布过程为脚本，然后通过手工调用</strong>]</li><li>人工观察线上质量 [<strong>有编写一些监控程序，然后通过手工调用</strong>]</li><li>质量修复、持续改进（循环第 3 步开始的内容）</li></ol><p>可以看到在流程没有任何变化的过程中，因为多了一些工具的引入、过程脚本的编写，很多事情可以让机器去做了，这样可以解放一大部分重复简单工作上的资源。<br>但是，协调每个阶段的事情，多数是由人来做的，因为有人的介入，部分自动化的事情，变的有一些不可控和不可靠，人是情绪化的动物，总会有疲惫、松懈的状态出现，然后可能影响到结果。<br>人工进行诸如:</p><ul><li>maven build</li><li>npm build</li><li>docker build</li></ul><p>然后执行 maven、npm、docker push 真的是有意义的吗？<br>而这个过程经过统计，其实在软件开发过程中占比并不会很低。（推荐使用时间追溯软件进行统计、也可以参考代码大全）<br>而且在多数时候，这些定制化的辅助脚本各式各样，后续一旦想批量进行升级更换操作，十分麻烦，<strong>缺乏标准化的技术方案，是应该被摒弃的</strong>。</p><h3 id="使用-CI-CD-基础设施的团队"><a href="#使用-CI-CD-基础设施的团队" class="headerlink" title="使用 CI/CD 基础设施的团队"></a>使用 CI/CD 基础设施的团队</h3><ol><li>项目创建</li><li>功能编写</li><li>代码提交 [<strong>CI 工具介入</strong>]</li><li>功能自测</li><li>代码 Review [<strong>CI 工具介入</strong>]</li><li>合并发布分支 [<strong>CI 工具介入</strong>]</li><li>人工构建 [<strong>CI 工具介入</strong>]</li><li>人工部署 [<strong>CD 工具介入</strong>]</li><li>产品发布 [<strong>CI/CD 工具介入</strong>]</li><li>人工观察线上质量 [<strong>CI 工具介入</strong>]</li><li>质量修复、持续改进（循环第 3 步开始的内容）</li></ol><p>看起来和上面并没有太大的不同，确实是这样：<br>如果你的研发流程是正常的，CI/CD 并不改造你的研发流程，只是给你进行标准化的工程流水线改造。<br>以 GitLab + GitLab CI Runner 环境下的 CI/CD 为例：</p><ul><li>在代码提交之后，将会根据提交分支进行不同的自动化处理：<ul><li>代码常规检查</li><li>自动化单元测试</li><li>依赖漏洞检查</li></ul></li><li>在代码 Review 阶段，因为上一阶段已经进行了 Code Style、代码底层实现 Code Lint 等检查，相关 reviewer 只需要对逻辑和实现方案进行 Review。</li><li>在合并发布分支阶段，可以自动检查是否冲突，如果没有冲突自动进行合并，有则进行通知，等待人工介入，<strong>人工只做必须介入的事情</strong>。</li><li>在构建过程，CI 可基于标准的容器镜像进行构建，依赖被约束在稳定的镜像二进制包内，唯一的变量就是你有变动的代码，保障构建环境是可准确、可靠、可迁移的。因为使用 dockerfile 进行描述，容器环境的分析和升级也变的透明、可追溯。在构建结束将成功与否的结果告知工程师，但仅仅是告知即可，因为软件已经可以到下一个阶段进行自动化部署了。</li><li>在部署阶段，CI 可基于上一步构建结果是否正确进行下一步的分发操作，包括交付测试使用的测试环境、给开发自行联调使用的开发环境、给团队成员验收使用的预发或者叫仿真环境、乃至线上正式的生产环境。</li><li>最后，当部署完成之后，等待人工介入完成产品上线切换，会触发 CI 的线上复查、监控验收。</li></ul><p>我们可以看到虽然之前看似简单的过程脚本变成了一大块的持续集成执行阶段，但是带来了容器标准化执行，未来对构建环境的统一维护和升级可以快速被应用。<br>之前看似简单，但是极其浪费资源的人工执行变成了自动化执行，很多东西在无声无息的进行着，只有必须人去参与决策的时候，才需要人去操作，对于研发团队来说，这里可以节约大量的资源，对于工程师来说，你工作中来自软件研发流程上的等待和打断少了许多。</p><h2 id="CI-CD-价值小结"><a href="#CI-CD-价值小结" class="headerlink" title="CI/CD 价值小结"></a>CI/CD 价值小结</h2><ul><li>流水线标准化生产和交付<ul><li>最大化减少人为介入和决策，提高交付效率、节约人力成本在机器可以做的很好的情况下的浪费。</li><li>环境标准化，避免硬编码的脚本带来后续升级改造成本或者绑架技术栈。</li><li>流程标准化有助于扩展性提升，连接研发流程的设施可以相对轻松的进行升级维护。</li></ul></li><li>“简化”研发流程<ul><li>开发人员可以更加专注于产品打磨，而非周边“乱七八糟”的一堆事情上。</li></ul></li><li>研发质量辅助提升<ul><li>原本需要人工执行的代码质量检查的操作，统一由机器去完成。</li><li>结合数据工具，可以针对性的自动化产出某个项目上线前后的数据变化，回馈产品、运营团队，辅助后续的产品决策。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DevOps时代的软件过程改进</title>
      <link href="2021/11/30/yuque/nrl1a9/"/>
      <url>2021/11/30/yuque/nrl1a9/</url>
      
        <content type="html"><![CDATA[<p>软件开发经过多年的发展，从互联网史前，到移动互联网，再到 AI、大数据、云计算、物联网、区块链等的时代，其本质并没有发生根本性的改变，但组织形式却在持续演化，其中以敏捷和 DevOps 为特征的两个典型阶段，在今天得到了较大规模的应用。</p><p>本文将尝试探讨在 DevOps 时代，软件过程改进的必要性及其理念与方法方面的新挑战，并对 Cloud Native 云原生生态的 DevOps 略作展望，希望对读者有所启发。</p><h2 id="01-重新审视软件过程改进"><a href="#01-重新审视软件过程改进" class="headerlink" title="01 重新审视软件过程改进"></a><strong>01 重新审视软件过程改进</strong></h2><p>SPI 相关的概念比较多，我们在此先回顾最基础的两个相关概念：<br><strong>软件过程（software process）：</strong> “软件过程为一个为建造高质量软件所需完成的任务的框架，即形成软件产品的一系列步骤，包括中间产品、资源、角色及过程中采取的方法、工具等范畴。<br>人们在开发和维护软件机器相关产品时所涉及的各种活动、方法、实践和改革等。其中软件相关产品包括软件项目计划、设计文档、程序代码、测试用例和用户手册等。”<br><strong>过程模型（process model）：</strong>“ 所谓软件过程模型就是一种开发策略，这种策略针对软件工程的各个阶段提供了一套范形，使工程的进展达到预期的目的。<br>对一个软件的开发无论其大小，我们都需要选择一个合适的软件过程模型，这种选择基于项目和应用的性质、采用的方法、需要的控制，以及要交付的产品的特点。 常见的模型包括瀑布模型、螺旋模型、增量模型、迭代模型、V 模型等。”</p><p>现实往往更加残酷，在绝大部分中小企业，软件开发过程相对粗放，并不严格遵循某种模型或范式，基本是 KPI 驱动和 BOSS 驱动。<br>与此同时大型企业尤其是如今的互联网巨头公司，对效率和质量的要求较高，所以在软件开发过程方面愿意投入，在每天/每周/每月的版本迭代过程中，组织层面会更加关注每一次迭代的效率和质量与上一次相比是否有保持或者提升（下降通常是不可接受的），此时 SPI 就该出场了，这是让迭代效率和质量持续提升的法宝！ 也许很多组织内已经在做这类工作，但并没有明确把它定义为 SPI。</p><p>一般大型管理咨询公司会更乐意提及 SPI，他们更加擅长帮助客户梳理和优化业务流程，给出改进建议或方案，并通过使用他们销售的产品来落地。<br>在互联网企业中，版本迭代的典型特点是周期较短，我们从 BAT 及京东、携程、美团、字节跳动等企业的工程效率相关团队发布的数据看到，大家通常会使用平均发布周期、发布成功率、日构建及发布次数等指标来观察和衡量软件开发与交付的效率和质量。</p><p>建立可观测的指标，是过程改进非常重要的一个步骤！ 只有建立核心指标，才能直观地看到改进活动的效果，举个例子： 某开发团队把版本控制工具从 SVN 要切换到 Git；实践中这项工作的实施通常不会进行充分评审，最多做一个开发者调查，因为大家潜意识里认为这是”行业趋势“，我们要跟着同行的步伐；</p><p>但是如果从问题的本质思考，即使是”行业趋势“，一个团队应该在什么时间点切换比较合适，切换后带来的具体收益是什么？<br>是否因为新工具/新方法的引入，短期内团队交付效率会有所下降，而长期会上升？ 这是非常典型的一个改进活动，我所服务过的雇主，有 3 个团队经历过 SVN 切换 Git，并没有一个团队从 SPI 的角度去评估过。但是如果建立了最基础的度量指标，即使没有评估，我们也可以从版本迭代和交付数据上看到变化。</p><h2 id="02-DevOps-时代的软件过程改进"><a href="#02-DevOps-时代的软件过程改进" class="headerlink" title="02 DevOps 时代的软件过程改进"></a><strong>02 DevOps 时代的软件过程改进</strong></h2><p>DevOps 理念在推广初期，受到不少人士的质疑甚至反对，比如有人担心运维工程师会丢掉自己的工作；后来的结果大家都看到了，非但运维工程师没有消失或减少，有些组织反而多了一种专职 DevOps 的角色，而原有的运维工程师其效率更高，单人可以维护的系统数量和复杂度都显著提升。可以说按照新技术应用周期，验证了这一事实：“新技术在短期内其价值通常被高估，而长期被低估”。</p><p>DevOps 从理念甚至组织文化层面为软件开发与交付带来了新的提升，开发从系统设计和实现阶段就考虑到对持续交付的支撑，与此同时运维也从系统设计和实现阶段就开始关注整体技术方案，让其面向持续交付来保证一定的可运维性。</p><p>因此可以说 DevOps 让软件系统的开发与交付环节更加紧密，这对过程改进来说是好消息；更紧密的协作，会让过程指标传递更加高效，开发与运维甚至 QA 等角色，能共用同一套衡量指标体系，用同一把尺子衡量各环节及过程整体的效率和质量。</p><p>所以，DevOps 时代，SPI 的必要性不言而喻，甚至 SPI 的效果和意义会更容易凸显，更容易通过指标体系观测到。<br>那么 DevOps 时代的 SPI 工作会有哪些新的挑战呢？理念方面，需要在组织层面持续加强对过程改进的认可度，越是紧密的协作，越是需要更灵活的过程度量方法，过程改进工作的价值也就越容易得到体现。常见的认识误区是，采用了 DevOps 就是引入了一个标准范式，无需过程改进；</p><p>相反，DevOps 对每一个过程的要求相对更高，能持续对瓶颈或薄弱过程进行改进，会让 DevOps 的价值更大。方法方面，除了常见的新方法导入、工具引入或替换，还有一个方面是，现有方法或工具自身的持续改进。<br>比如自动化测试，要求在 CI 环节全部自动化，甚至在 CD 环节可以进行预发布/线上环境的无损测试，更进一步需要在红绿发布/金丝雀发布过程中通过自动化测试来判断发布是否达到预期。再比如监控和告警，要求相关信息必须做到可视化，并让开发、运维、QA 在同一个 dashboard 里观测，这样可以提高沟通效率，减少术语和指标定义不一致带来的沟通成本；可以说，优秀的监控和告警体系，会让 DevOps 链条上的所有角色能及时感知系统各部分及整体的任何风吹草动。</p><p>##</p><h2 id="03-从-Jenkins-发展轨迹窥视软件过程改进"><a href="#03-从-Jenkins-发展轨迹窥视软件过程改进" class="headerlink" title="03 从 Jenkins 发展轨迹窥视软件过程改进"></a><strong>03 从 Jenkins 发展轨迹窥视软件过程改进</strong></h2><p>Jenkins 在 CI 及 DevOps 生态扮演者非常重要的角色，可以说是软件交付史上的活化石！我们来回顾下 Jenkins 的发展轨迹：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1638203324550-d6a46eea-2946-4860-b431-c1a238e99caf.png#clientId=u787d3d1f-1db0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u9076e946&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=903&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=22636&status=done&style=none&taskId=u53e3c09e-995d-45c8-924b-536915dfe07&title=&width=903" alt="image.png"><br>Hudson 时代，更多的是希望把写完的代码能自动编译、测试，做一些基本代码的分析，最后输出合格的部署包。这些最基本的追求，还不是每个团队都有甚至能达成共识，更多团队依然是比较粗放的开发方式，稍好一些的会通过自动化脚本来实现类似目的。</p><p>在大约 2013 年之前，国内其实对于 Jenkins 的认知和应用依然只停留在“一个能自动构建项目的工具”层面上。当然也有不少团队会依赖 Jenkins 来进行部署，但主要针对把部署包 scp 到有限的物理机或虚拟机上然后执行部署 shell 脚本等场景，基本没有成品仓的概念，也没有 Docker 容器及镜像级别的打包部署。后来随着 Docker 和 K8S 的流行，以及 Jenkins 自身的快速进化，到 2016 年几乎是一夜之间所有招聘网站的相关职位 JD 里都增加了 Jenkins 技能要求。</p><p>因为比较早地使用 Jenkins，并且在社区内参与了一些翻译工作，2017 年我与 Jenkins 社区的 Maxwell 沟通后在深圳发起了国内首次 Jenkins Area Meetup，受到了广泛支持和热烈欢迎。</p><p>本来预期是办一个小型的 Meetup 活动而已，30 或 50 人的交流活动，结果办成了 100+人次的小型会议；实在没想到一个 Jenkins 怎么吸引了这么多人，会后我们还分析了一下报名及参与的人群特点，发现不只是开发人员很有兴趣，还有运维人员，配置管理人员，测试人员，甚至云计算和基础设施的人员。</p><p>后来业内其他社区很快在北京、上海等城市发起了 Jenkins Area Meetup，并在 2017 年底于上海，召开了国内第一次 Jenkins 中文用户大会，Jenkins 作者 KK 也从 2017 年开始频繁在国内的相关会议和活动上露面。<br>今天 Jenkins 中文社区也蓬勃发展，不但有了中文版的网站 <a href="https://jenkins.io/zh/%EF%BC%8C%E8%BF%98%E6%9C%89%E8%BF%90%E8%90%A5%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7">https://jenkins.io/zh/，还有运营微信公众号</a> “Jenkins”。</p><p>作为 Jenkins 中文社区的一员，非常欢迎大家积极参与到社区活动中来，包括但不限于代码提交，测试用例提交，文档优化，文档翻译，Meetup 活动组织等。<br>至于后来 Jenkins 2.x 的出炉，以及 Pipeline 特性的持续增强，甚至到目前 Jenkins X 的发布和流行，让开发者们真正感受到了“一切皆可编程”的真理！ 我们发现不只是可使用的资源可编程，比如云计算的本质可以理解为</p><p>让各种基础设施可编程，而且过程也可编程，而且是超越了资源调度或任务编排的水准。<br>也许不远的将来，开发人员真的只要关注业务逻辑的实现即可，其他都交给可编程的自动化过程来完成，包括资源的获取、初始化、启用等；当然，这些自动化过程依然需要专门的开发人员来实现。</p><p>通过以上 Jenkins 的发展轨迹，特别是国内外社区的发展状况，我们可以明显地感受到，组织和个人对软件过程有着越来越高的要求，更加追求效率和质量，过程资源调度的可编程性和自动化程度日益提高。可以认为，是 Jenkins 把过程改进相关的工作串联了起来。</p><p>##</p><h2 id="04-云原生生态的-DevOps-与软件过程改进展望"><a href="#04-云原生生态的-DevOps-与软件过程改进展望" class="headerlink" title="04 云原生生态的 DevOps 与软件过程改进展望"></a><strong>04 云原生生态的 DevOps 与软件过程改进展望</strong></h2><p>Cloud Native 生态目前已经进入快速发展阶段，参考新技术应用周期，笔者认为已经在”快速成长期“的尾巴上了，可能很快要进入”成熟期“了。<br>关于云原生的定义，可以参考<a href="https://jimmysong.io/kubernetes-handbook/cloud-native/cloud-native-definition.html">https://jimmysong.io/kubernetes-handbook/cloud-native/cloud-native-definition.html</a></p><p>笔者的个人观点是：云原生是软件交付方式的突破性进化，而不仅仅是效率的提升。</p><p>云原生所需的能力和特征：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1638203419593-4c80f20e-69f1-4faf-9166-19653130ba95.png#clientId=u787d3d1f-1db0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=512&id=uc8b84986&margin=%5Bobject%20Object%5D&name=image.png&originHeight=654&originWidth=1071&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=292159&status=done&style=none&taskId=ud9efbe92-b9d9-4d95-b1ee-dbacc127e5b&title=&width=839" alt="image.png"></p><p><a href="https://jimmysong.io/kubernetes-handbook/cloud-native/from-kubernetes-to-cloud-native.html">https://jimmysong.io/kubernetes-handbook/cloud-native/from-kubernetes-to-cloud-native.html</a></p><p>云原生时代大规模微服务的出现，让质量保证工作也面临新的挑战，目前比较火热的 CHAOS 混沌工程，是解决方案之一，可以通过随机给系统注入故障来验证系统整体的健壮性。<br>这无法通过常规的测试工作来解决，一方面系统间的关系变得更加复杂，几乎无法遍历所有路径；另一方面，不同微服务相对独立迭代，版本差别较大，只有线上拥有真实的系统演化过程信息，其他环境几乎无法模拟。</p><p>云原生时代 DevOps 的挑战将会更大，还体现在开发人员离线上系统更近，对线上系统的操作会更加频繁；资源和过程的可编程性让系统复杂度持续提升，大规模微服务已经不像之前的中小系统，运维人员可以全面掌握整个系统的拓扑，必须依赖可观测性工具，甚至只能了解复杂系统的某个部分。</p><p>微服务时代必备的调用链工具，在新的发展阶段，可能已经不是“链式”关系可以覆盖的了，可能是“网状”结构，虽然从系统设计角度我们追求更加优雅的拓扑结构。<br>此时的软件过程改进，已经超越了某个方法和工具的引入或替换，更需要具有良好可集成性的解决方案级别的服务导入，AIOps 就是典型案例。国内外大部分互联网企业的研发体系中，软件过程改进的相关工作通常归属在“工程效率”、“基础设施”等团队中；</p><p>理想的研发体系中，比如云原生技术栈的引入，可能来自业务需求的驱动，而实践中通常是基础设施提供方来直接驱动的，因为后者更加关注资源使用效率、系统可用性与成本，并在这几个方面对业务团队的技术方案进行评估，对业务系统建立考核指标。</p><p>所以此时要让软件过程改进工作顺利进行，必须进行大范围的效率、质量与成本意识培训和提升，然后给出适合组织文化的行之有效的举措，逐层实施，毕竟此时牵一发而动全身。</p><p>再次回到 Jenkins ，云原生时代的 Jenkins 进化为了 Jenkin X，依赖 Git &amp; K8S 来完成云上的超级 Pipeline ，Jenkins X 还在快速进化，笔者相信它在 KK 的带领下依然是云原生时代的 CI/CD 领跑者！此时的软件过程改进依然可以极大程度地参考 Jenkins X ，任何效率和质量瓶颈都值得去做改进！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UML图-总结</title>
      <link href="2021/10/30/yuque/to1w2y/"/>
      <url>2021/10/30/yuque/to1w2y/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UML 图是软件工程的组成部分，软件工程从宏观的角度保证了软件开发的各个过程的质量。而 UML 作为一种建模语言，更加有效的实现了软件工程的要求</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635602364455-bc0c252a-e554-4e4c-9422-ba0aa04cf7cc.png#clientId=u67980cd5-ed5c-4&from=paste&height=444&id=ua6fac574&margin=%5Bobject%20Object%5D&originHeight=619&originWidth=694&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u28aa0f44-6b2a-4412-b0ce-37ab913b006&width=498"></p><p><strong>UML 定义了 5 类，9 种模型图</strong><br><strong>1.用例图</strong>：展现了一组用例、参与者（actor）以及它们之间的关系。用例图从用户角度描述系统的静态使用情况，用于建立需求模型<br><strong>2.静态图</strong>：包括类图，包图，对象图。</p><ul><li>类图：展现了一组对象、接口、协作和它们之间的关系。类图描述的是一种静态关系，在系统的整个生命周期都是有效的，是面向对象系统的建模中最常见的图。</li><li>对象图：展现了一组对象以及它们之间的关系。对象图是类图的实例，几乎使用与类图完全相同的标示。</li></ul><p><strong>3.行为图</strong>：描述系统动态模型和对象组成的交换关系。包括状态图和活动图</p><ul><li>活动图：一种特殊的状态图，展现了系统内一个活动到另一个活动的流程。活动图有利于识别并行活动。</li><li>状态图：由状态、转换、事件和活动组成，描述类的对象所有可能的状态以及事件发生时的转移条件。通常状态图是对类图的补充，仅需为那些有多个状态的、行为随外界环境而改变的类画状态图。</li></ul><p><strong>4.交互图：</strong>用于描述对象间的交互关系，由一组对象和它们之间的关系组成，包含它们之间可能传递的消息。交互图又分为序列图和协作图</p><ul><li>序列图：对象之间的动态合作关系，强调对象发送消息的顺序，同时显示对象之间的交互</li><li>协作图：强调收发消息的对象的结构组织。</li></ul><p><strong>5.实现图：</strong></p><ul><li>部署图：展现了运行处理节点以及其中的组件的配置。部署图给出了系统的体系结构和静态实施视图。它与组件图相关，通常一个节点包含一个或多个构建。</li><li>组件图: 展现了一组组件的物理结构和组件之间的依赖关系。组件图有助于分析和理解组件之间的相互影响程度。</li></ul><p>需要指出的是，UML 并不限定仅使用这 9 种图，开发工具可以采用 UML 来提供其他种类的图，但到目前为止，这 9 种图在实际应用中最常用的。</p><h2 id="1-用例图（UseCase-Diagrams）"><a href="#1-用例图（UseCase-Diagrams）" class="headerlink" title="1. 用例图（UseCase Diagrams）"></a>1. 用例图（UseCase Diagrams）</h2><p>需求分析的第一步是确定系统能够做什么？谁来使用这个系统？</p><p>用例图主要用来描述 用户、需求、系统功能单元 之间的关系，主要回答了两个问题：1、是谁用软件。2、软件的功能。描述了作为一个外部的观察者的视角对系统的印象。强调这个系统是什么，而不是这个系统怎么工作。</p><p>用例图在三个领域很有作用。</p><ul><li>决定特征（需求）。当系统已经分析好并且设计成型时，新的用例产生新的需求</li><li>客户通讯。使用用例图很容易表示开发者与客户之间的联系。</li><li>产生测试用例。一个用例的情节可能产生这些情节的一批测试用例。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635649292093-10d54333-d4f8-45eb-871d-c00c91c7c4b3.png#clientId=u25684858-bed7-4&from=paste&id=ud51baf9c&margin=%5Bobject%20Object%5D&originHeight=579&originWidth=583&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u64f08d5e-a9e9-4b81-b5f8-88ee12ad5c3"></p><p>用例图所包含的元素如下：<br><strong>1.</strong> <strong>参与者(Actor)</strong><br>表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596449899-200d627e-9c58-423a-b796-98ca40e88d47.png#clientId=uef7ac64a-b779-4&from=paste&height=59&id=uf11245f4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=83&originWidth=66&originalType=url%E2%88%B6=1&size=370&status=done&style=none&taskId=ue953e1ad-3113-4dce-af04-b42613ddf46&width=47" alt="image.png"><br><strong>2.</strong> <strong>用例(Use Case)</strong><br>用例就是外部可见的系统功能，对系统提供的服务进行描述。 用椭圆表示<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596449909-da4abef0-75c6-43df-ab60-411f5dbe2813.png#clientId=uef7ac64a-b779-4&from=paste&height=57&id=u0fb92da8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=112&originalType=url%E2%88%B6=1&size=1171&status=done&style=none&taskId=uf64ef994-c64d-45b0-ba08-dfce69ba7ea&width=88" alt="image.png"><br><strong>3.</strong> <strong>子系统(Subsystem)</strong><br>用来展示系统的一部分功能，这部分功能联系紧密。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596449920-c1edddd7-6ffb-4926-b3c8-af307f3010f9.png#clientId=uef7ac64a-b779-4&from=paste&height=276&id=u1eb52c65&margin=%5Bobject%20Object%5D&name=image.png&originHeight=310&originWidth=403&originalType=url%E2%88%B6=1&size=4229&status=done&style=none&taskId=u3376dec3-1ba7-4ae6-ab1c-5f0727a7dfe&width=359" alt="image.png"><br><strong>4.</strong> <strong>关系</strong><br>用例图中涉及的关系有：关联、泛化、包含、扩展；<br>如下表所示：</p><table><thead><tr><th>关系类型</th><th>说明</th><th>表示符号</th></tr></thead><tbody><tr><td>关联</td><td>参与者与用例间的关系</td><td><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596449908-d9a9ed9b-072b-47eb-b3e0-65eb1f826e62.png#clientId=uef7ac64a-b779-4&from=paste&id=u8ff1b7bf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=22&originWidth=111&originalType=url%E2%88%B6=1&size=255&status=done&style=none&taskId=u0ddd4356-7427-45a9-a7a7-a18bf9fbd45" alt="image.png"></td></tr><tr><td>泛化</td><td>参与者之间或用例之间的关系</td><td><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596449910-206c12f0-27c8-4c7c-90dd-07a758e93c6c.png#clientId=uef7ac64a-b779-4&from=paste&id=u930e8adb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=21&originWidth=110&originalType=url%E2%88%B6=1&size=275&status=done&style=none&taskId=ud5a139fd-3539-4ce2-a28f-8ceb0681cb5" alt="image.png"></td></tr><tr><td>包含</td><td>用例之间的关系</td><td><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450304-5545266c-597c-4f56-93ee-f5a21d930c33.png#clientId=uef7ac64a-b779-4&from=paste&id=u8401f551&margin=%5Bobject%20Object%5D&name=image.png&originHeight=31&originWidth=108&originalType=url%E2%88%B6=1&size=352&status=done&style=none&taskId=u8c48990a-0945-45d5-93a0-3dbcd48bd32" alt="image.png"></td></tr><tr><td>扩展</td><td>用例之间的关系</td><td><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450442-2a679dde-2183-4dd6-98af-b165baa892e1.png#clientId=uef7ac64a-b779-4&from=paste&id=u51609593&margin=%5Bobject%20Object%5D&name=image.png&originHeight=34&originWidth=111&originalType=url%E2%88%B6=1&size=347&status=done&style=none&taskId=u756e5c81-368d-4d6d-a659-3081ceb9c2b" alt="image.png"></td></tr></tbody></table><p><strong>a.</strong> <strong>关联(Association)</strong><br>表示参与者与用例之间的通信，任何一方都可发送或接受消息。【箭头指向】：指向消息接收方</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450482-c8ecdd09-2953-4f57-b77a-7b2ed23182ce.png#clientId=uef7ac64a-b779-4&from=paste&id=u7696aac1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=83&originWidth=282&originalType=url%E2%88%B6=1&size=1572&status=done&style=none&taskId=ub3db5da2-6878-4daf-b5b1-2552f1d2c2f" alt="image.png"><br><strong>b.</strong> <strong>泛化(Inheritance)</strong><br>就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。【箭头指向】：指向父用例<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450484-c7d29ccf-1388-4378-acc8-3ad80da4c7bf.png#clientId=uef7ac64a-b779-4&from=paste&id=ue869cde4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=197&originWidth=525&originalType=url%E2%88%B6=1&size=5033&status=done&style=none&taskId=u08aacd2d-695b-4b47-9fe1-59366687126" alt="image.png"><br><strong>c.</strong> <strong>包含(Include)</strong><br>包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤；【箭头指向】：指向分解出来的功能用例<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450671-e41efa81-ec99-4f7b-922e-e12918ac56df.png#clientId=uef7ac64a-b779-4&from=paste&id=u8e1ade31&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=419&originalType=url%E2%88%B6=1&size=3958&status=done&style=none&taskId=ucaad83a2-112b-4ee3-a57d-ba7a299fbf0" alt="image.png"><br><strong>d.</strong> <strong>扩展(Extend)</strong><br>扩展关系是指 用例功能的延伸，相当于为基础用例提供一个附加功能。【箭头指向】：指向基础用例<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450873-9ce004b2-238f-4112-a051-95efb774a6bc.png#clientId=uef7ac64a-b779-4&from=paste&id=ud2449e87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=166&originWidth=280&originalType=url%E2%88%B6=1&size=3655&status=done&style=none&taskId=u30f04773-d8d7-40e5-9a54-be8e46d6fda" alt="image.png"></p><p><strong>e.</strong> <strong>依赖(Dependency)</strong><br>以上 4 中关系，是 UML 定义的标准关系。 但 VS2010 的用例模型图中，添加了依赖关系，用带箭头的虚线表示<br>表示源用例依赖于目标用例；【箭头指向】：指向被依赖项<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450882-8320cd32-f4cd-4371-a040-3f7a4fb47514.png#clientId=uef7ac64a-b779-4&from=paste&id=ufc5a4fc6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=83&originWidth=295&originalType=url%E2%88%B6=1&size=1686&status=done&style=none&taskId=u6d74791a-b797-4028-b241-0e9cd180f7f" alt="image.png"><br><strong>5.</strong> <strong>项目(Artifact)</strong><br>用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用 Excel 都比用例图强，VS2010 中引入了“项目”这样一个元素，以便让开发人员能够在用例图中链接一个普通文档。<br>用依赖关系把某个用例依赖到项目上<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596450972-fa7c0f2c-6835-4b63-b1f2-ae320de1a695.png#clientId=uef7ac64a-b779-4&from=paste&id=u82af5e66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=360&originalType=url%E2%88%B6=1&size=2564&status=done&style=none&taskId=u8358112f-5b86-401b-8e8e-c9cefb655e3" alt="image.png"><br>然后把项目-》属性 的 Hyperlink 设置到你的文档上，这样当你在用例图上 双击项目时，就会打开相关联的文档。</p><p><strong>6.</strong> <strong>注释(Comment)</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596451318-2576669c-8b2c-4270-a461-5bf41c29950d.png#clientId=uef7ac64a-b779-4&from=paste&id=uf1fdcd2c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=87&originWidth=345&originalType=url%E2%88%B6=1&size=2755&status=done&style=none&taskId=u48cb50f6-829c-4a43-add8-abf53d8d3be" alt="image.png"></p><p><strong>包含(include)、扩展(extend)、泛化(**Inheritance</strong>) 的区别：**<br>条件性：泛化中的子用例和 include 中的被包含的用例会无条件发生，而 extend 中的延伸用例的发生是有条件的；<br>直接性：泛化中的子用例和 extend 中的延伸用例为参与者提供直接服务，而 include 中被包含的用例为参与者提供间接服务。<br>对 extend 而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。<br>对 Inheritance 而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；</p><p><strong>一个用例图示例：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596451423-d29f4ec8-ac77-472d-ba7a-810ba6dd6f58.png#clientId=uef7ac64a-b779-4&from=paste&id=uf2730910&margin=%5Bobject%20Object%5D&name=image.png&originHeight=263&originWidth=558&originalType=url%E2%88%B6=1&size=18519&status=done&style=none&taskId=u92d3dde2-f113-4727-899a-9040f666ceb" alt="image.png"></p><p><strong>牢骚：</strong><br>感觉用例图还不成熟，并不能很好地表达系统的需求， 没有 UML 背景的用户几乎不知道画的些什么。<br>其次，包含关系、扩展关系 的箭头符号竟然是同样的箭头，仅靠上方写个文字来加以区别，翻译成其他语言的话，几乎就不知道代表什么意思。 扩展关系的箭头朝向也很难理解，为何要指向基用例，而不指向扩展用例</p><p><strong>用例描述表：</strong><br>鉴于用列图并不能清楚地表达功能需求，开发中大家通常用描述表来补充某些不易表达的用例，下图的表给大家提供一个参考：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635596451565-c33b3fe5-377c-4ce2-81fa-4c8669626d13.png#clientId=uef7ac64a-b779-4&from=paste&height=327&id=u58ac0d0b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=558&originalType=url%E2%88%B6=1&size=30696&status=done&style=none&taskId=u20ab496f-48f6-487d-a40d-e4e008ffa4f&width=565" alt="image.png"></p><h2 id="2-类图（Class-Diagrams）"><a href="#2-类图（Class-Diagrams）" class="headerlink" title="2. 类图（Class Diagrams）"></a>2. 类图（Class Diagrams）</h2><p>用户根据用例图抽象成类，描述类的内部结构和类与类之间的关系，是一种静态结构图。 在 UML 类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635644673311-7b09f915-0968-4c96-8d95-808c2c19979a.png#clientId=ue01307b8-45f4-4&from=paste&id=u76b7b2ef&margin=%5Bobject%20Object%5D&originHeight=383&originWidth=773&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u21248269-75e0-4ae8-a542-3407b0156c9"><br><strong>各种关系的强弱顺序：</strong><br><strong>泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖</strong></p><h3 id="1-泛化-Generalization"><a href="#1-泛化-Generalization" class="headerlink" title="1.泛化(Generalization)"></a>1.泛化(Generalization)</h3><p><strong>【泛化关系】：</strong>是一种继承关系,它指定了子类如何特化父类的所有特征和行为例如：老虎是动物的一种.<br><strong>【箭头指向】：</strong>带三角箭头的实线，箭头指向父类</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299048-571d1070-1150-41ab-9ea6-2642967688e1.png#clientId=u67980cd5-ed5c-4&from=paste&height=243&id=ubc46ad46&margin=%5Bobject%20Object%5D&name=image.png&originHeight=315&originWidth=202&originalType=url%E2%88%B6=1&size=6084&status=done&style=none&taskId=u8dd73139-e7b8-494a-b1ba-89587fac76e&width=156" alt="image.png"></p><h3 id="2-实现（Realization"><a href="#2-实现（Realization" class="headerlink" title="2.实现（Realization)"></a>2.实现（Realization)</h3><p><strong>【实现关系】：</strong>是一种类与接口的关系，表示类是接口所有特征和行为的实现<br><strong>【箭头指向】：</strong>带三角箭头的虚线，箭头指向接口</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299050-81797651-8a33-4d67-b30b-fba80a5989ce.png#clientId=u67980cd5-ed5c-4&from=paste&id=u4be2b309&margin=%5Bobject%20Object%5D&name=image.png&originHeight=284&originWidth=204&originalType=url%E2%88%B6=1&size=6222&status=done&style=none&taskId=udbdcc1fd-ab41-4303-bbae-1b5858c380c" alt="image.png"></p><h3 id="3-关联（Association）"><a href="#3-关联（Association）" class="headerlink" title="3.关联（Association）"></a>3.关联（Association）</h3><p><strong>【关联关系】：</strong>是一种拥有的关系,它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子<br>关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br><strong>【代码体现】：</strong>成员变量<br><strong>【箭头及指向】：</strong>带普通箭头的实心线，指向被拥有者</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299065-09ed2954-3713-43e1-a538-2e180f1f79e0.png#clientId=u67980cd5-ed5c-4&from=paste&id=ub6124ff2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=159&originWidth=558&originalType=url%E2%88%B6=1&size=18584&status=done&style=none&taskId=u5ce725c2-9ef8-4f5c-9494-5b57b08ec8f" alt="image.png"></p><p>上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299067-f58562ef-689e-40dc-89f7-dfe5afe1b6a9.png#clientId=u67980cd5-ed5c-4&from=paste&id=u4c2ee1cb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=180&originWidth=233&originalType=url%E2%88%B6=1&size=4824&status=done&style=none&taskId=u4c44cefa-18a7-477d-9d19-04270f9e611" alt="image.png"></p><p><strong>上图为自身关联：</strong></p><h3 id="4-聚合（Aggregation）"><a href="#4-聚合（Aggregation）" class="headerlink" title="4. 聚合（Aggregation）"></a>4. 聚合（Aggregation）</h3><p><strong>【聚合关系】：</strong>是整体与部分的关系.如车和轮胎是整体和部分的关系.<br>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>是一种“弱”的拥有关系，体现的是 A 对象可以包含 B 对象，但是 B 对象不是 A 对象的一部分<br><strong>【代码体现】：</strong>成员变量<br><strong>【箭头及指向】：</strong>带空心菱形的实心线，菱形指向整体</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299067-e3d0c44b-ea71-4557-8d9f-58642140a2cd.png#clientId=u67980cd5-ed5c-4&from=paste&id=u75c1b608&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=389&originalType=url%E2%88%B6=1&size=7814&status=done&style=none&taskId=u91ca8b35-31c7-4bc2-ac80-3eecfd65e3c" alt="image.png"></p><h3 id="5-组合-Composition"><a href="#5-组合-Composition" class="headerlink" title="5. 组合(Composition)"></a>5. 组合(Composition)</h3><p><strong>【组合关系】：</strong>是整体与部分的关系.,没有公司就不存在部门 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期<br>是一种“强”的拥有关系，体现了严格的部分与整体的关系，部分与整体的生命周期一样<br><strong>【代码体现】：</strong>成员变量<br><strong>【箭头及指向】：</strong>带实心菱形的实线，菱形指向整体</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299823-17113a68-7a8f-49a5-b22c-638c11e1e561.png#clientId=u67980cd5-ed5c-4&from=paste&id=ud91c71c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=218&originalType=url%E2%88%B6=1&size=6519&status=done&style=none&taskId=u27c7dbe3-fd27-4808-ac6c-24fcf2fe580" alt="image.png"></p><h3 id="6-依赖-Dependency"><a href="#6-依赖-Dependency" class="headerlink" title="6. 依赖(Dependency)"></a>6. 依赖(Dependency)</h3><p><strong>【依赖关系】：</strong>是一种使用的关系,所以要尽量不使用双向的互相依赖<br><strong>【代码表现】：</strong>局部变量、方法的参数或者对静态方法的调用<br><strong>【箭头及指向】：</strong>带箭头的虚线，指向被使用者</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299887-b0969b0e-ff2f-487a-80da-55b1fa2f05f3.png#clientId=u67980cd5-ed5c-4&from=paste&id=u4fba445f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=196&originalType=url%E2%88%B6=1&size=6246&status=done&style=none&taskId=u62908373-68a9-44d7-8c11-38dfc5b356e" alt="image.png"></p><p><strong>下面这张 UML 图，比较形象地展示了各种类图关系：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635601299900-70f37f22-c88c-4239-b17b-8d9ab7ca728a.png#clientId=u67980cd5-ed5c-4&from=paste&id=ue0efb15f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=645&originWidth=794&originalType=url%E2%88%B6=1&size=26271&status=done&style=none&taskId=u50fb9579-05ba-4ab7-80c9-65df6eead4b" alt="image.png"></p><h2 id="3-对象图（Object-Diagrams）"><a href="#3-对象图（Object-Diagrams）" class="headerlink" title="3. 对象图（Object Diagrams）"></a>3. 对象图（Object Diagrams）</h2><p>描述的是参与<strong>交互的各个对象在交互过程中某一时刻的状态</strong>。对象图可以被看作是类图在某一时刻的实例。</p><h2 id="4-状态图（Statechart-Diagrams）"><a href="#4-状态图（Statechart-Diagrams）" class="headerlink" title="4. 状态图（Statechart Diagrams）"></a>4. 状态图（Statechart Diagrams）</h2><p>显示一个对象从生成到删除的生命周期中相应事件所经历的状态序列以及它们对哪些事件的相应。 分析人员和开发人员通过状态图更好的了解类的动态行为，使编码前能讨论和建立复杂逻辑。</p><h2 id="5-活动图（Activity-Diagrams）"><a href="#5-活动图（Activity-Diagrams）" class="headerlink" title="5. 活动图（Activity Diagrams）"></a>5. 活动图（Activity Diagrams）</h2><p>交互图强调的是对象到对象的控制流，而活动图则强调的是从活动到活动的控制流。</p><p>活动图 activity diagram 是一个很特别的流程图。活动图和状态图之间是有关系的。状态图把焦点集中在过程中的对象身上，而活动图则集中在一个单独过程动作流程。活动图告诉了我们活动之间的依赖关系。</p><p>我们的例子来说，我们使用如下的过程。<br>“通过 ATM 来取钱。”<br>这个活动有三个类 Customer, ATM 和 Bank。整个过程从黑色圆圈开始到黑白的同心圆结束。活动用圆角矩形表示。</p><p>活动图可以被分解成许多对象泳道 swimlanes ，可以决定哪些对象负责那些活动。每个活动都有一个单独的转移 transition 连接这其他的活动。<br>转移可能分支 branch 成两个以上的互斥的转移。保护表达式（在[]中）表示转移是从一个分支中引出的。分支以及分支结束时的合并 merge 在图中用菱形表示。<br>转移也可以分解 fork 成两个以上的并行活动。分解以及分解结束时的线程结合 join 在图中用粗黑线表示<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635645194033-a0a42f93-ca74-470c-a975-d25e8c71e9ee.png#clientId=ue01307b8-45f4-4&from=paste&height=426&id=u87b8158a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=783&originWidth=830&originalType=binary%E2%88%B6=1&size=90480&status=done&style=none&taskId=u0c90178b-e15d-4ec4-b418-00c07b775cf&width=452" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/5374140/1635601637657-ee3fc793-ec2a-4919-8723-897293228d00.jpeg#clientId=u67980cd5-ed5c-4&from=paste&id=uff6327b5&margin=%5Bobject%20Object%5D&originHeight=329&originWidth=435&originalType=url%E2%88%B6=1&status=done&style=none&taskId=ude524ab6-2d22-47de-bbaf-ff9e62a5f6e"></p><h2 id="6-时序图（Sequence-Diagrams）"><a href="#6-时序图（Sequence-Diagrams）" class="headerlink" title="6. 时序图（Sequence Diagrams）"></a>6. 时序图（Sequence Diagrams）</h2><p>时序图（Sequence Diagram），亦称为序列图、循序图或顺序图，是一种 UML 交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。时序图是一个二维图，横轴表示对象，纵轴表示时间，消息在各对象之间横向传递，依照时间顺序纵向排列。</p><h3 id="1-时序图的作用是什么？"><a href="#1-时序图的作用是什么？" class="headerlink" title="1) 时序图的作用是什么？"></a>1) 时序图的作用是什么？</h3><p>1、展示对象之间交互的顺序。将交互行为建模为消息传递，通过描述消息是如何在对象间发送和接收的来动态展示对象之间的交互；<br>2、相对于其他 UML 图，时序图更强调交互的时间顺序；<br>3、可以直观的描述并发进程。</p><h3 id="2-组成元素有哪些？"><a href="#2-组成元素有哪些？" class="headerlink" title="2) 组成元素有哪些？"></a>2) 组成元素有哪些？</h3><p><strong>1. 角色（Actor）</strong><br>系统角色，可以是人、机器、其他系统、子系统；</p><p><strong>2. 对象（Object）</strong></p><p>（1）对象的三种命名方式</p><ul><li>第一种方式包括对象名和类名，例如：直播课时:课时，在时序图中，<strong>用“对象：类”表示</strong>；</li><li>第二种方式只显示类名，即表示它是一个匿名对象，例如： :课程；在时序图中，<strong>用“：类”表示</strong>；</li><li>第三种方式只显示对象名不显示类名，例如：讲师；在时序图中，用“对象”表示。</li></ul><p>（2）命名方式的选择<br>三种命名方式均可，哪种最容易让阅读该时序图的人理解，就选择哪种。</p><p>（3）对象的排列顺序<br>对象的左右顺序并不重要，但是为了作图清晰整洁，通常应遵循以下两个原则：<strong>1.把交互频繁的对象尽可能的靠拢；2.把初始化整个交互活动的对象放置在最左端。</strong></p><p><strong>3. 生命线（Lifeline）</strong><br>在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。</p><p><strong>4. 控制焦点（Focus of Control）</strong><br>又称为激活期，表示时间段的符号，在这个时间段内对象将执行相应的操作。它可以被理解成 C 语言语义中一对花括号{ }中的内容；用小矩形表示。</p><p><strong>5. 消息（Message）</strong><br><strong>消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）。</strong></p><ul><li>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义；</li><li>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</li><li>返回消息表示从过程调用返回。</li></ul><p><strong>6. 自关联消息</strong><br>表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635748362525-4eee8273-6f15-4ea5-a6a7-8f806eac3bc7.png#clientId=u69d38362-af57-4&from=paste&height=499&id=u414a1ed5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=756&originWidth=904&originalType=url%E2%88%B6=1&size=224902&status=done&style=none&taskId=ue0b215b5-501f-4d6a-ae0b-f1a5380807b&width=597" alt="image.png"></p><p><strong>7. 组合片段</strong><br>组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有 13 种，名称及含义如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635746227453-31ea1912-8839-43ea-92ab-e3d62ae44b0b.png#clientId=u69d38362-af57-4&from=paste&id=uc46f13f1&margin=%5Bobject%20Object%5D&originHeight=567&originWidth=665&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u00d7e2a7-8d69-41d5-aebc-09001a792ed"></p><p><strong>常用组合片段举例：</strong>用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的 if..else..<br><strong>（1）抉择（Alt）</strong><br>抉择在任何场合下只发生一个序列。 可以在每个片段中设置一个临界来指示该片段可以运行的条件。else 的临界指示其他任何临界都不为 True 时应运行的片段。如果所有临界都为 False 并且没有 else，则不执行任何片段。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635746382745-83814503-abca-4939-b2bf-ea2486a60ef7.png#clientId=u69d38362-af57-4&from=paste&id=ub244113d&margin=%5Bobject%20Object%5D&originHeight=402&originWidth=558&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u46686680-12a1-4834-b16f-bf08498f9e1"><br>（2）选项（Opt）<br>包含一个可能发生或不发生的序列；<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635746382746-c4c62ff4-07aa-44eb-bd34-df232af4e696.png#clientId=u69d38362-af57-4&from=paste&id=u373fd358&margin=%5Bobject%20Object%5D&originHeight=312&originWidth=558&originalType=url%E2%88%B6=1&status=done&style=none&taskId=ud8eb08fa-ede9-4a8e-a12a-1ad96461e61"><br>（3）循环（Loop）<br>片段重复一定次数，可以在临界中指示片段重复的条件。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635746382982-cd8c20ac-1e1d-4f93-ae90-b80892774d0b.png#clientId=u69d38362-af57-4&from=paste&id=u3d02f0a7&margin=%5Bobject%20Object%5D&originHeight=263&originWidth=369&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u149b458c-e682-470c-8ff4-207858909d3"><br>（4）并行（Par）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635746383666-22ebfbf7-b2d7-44c6-a6e2-333168052f92.png#clientId=u69d38362-af57-4&from=paste&height=413&id=uae41eeef&margin=%5Bobject%20Object%5D&originHeight=497&originWidth=384&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u4de1ed26-ada9-4ad3-b570-52c5ffffe52&width=319"></p><h3 id="3）时序图的画法及实例"><a href="#3）时序图的画法及实例" class="headerlink" title="3）时序图的画法及实例"></a>3）时序图的画法及实例</h3><p>时序图的绘制步骤可简单总结如下：</p><ul><li>划清边界，识别交互的语境；</li><li>将所要绘制的交互场景中的角色以及对象梳理出来；</li><li>从触发整个交互的某个消息开始，在生命线之间从上到下依次画出所有消息，并注明每个消息的特性（如参数等）。</li></ul><p>接下来，我们按照上面所讲的时序图的绘制步骤，以学生在教务系统中查询其课程的成绩为例，来讲解时序图的绘制方法。</p><p><strong>1、划清边界，识别交互的语境</strong><br>所谓划清边界，就是要界定好自己所要画的时序图的范围，“学生在教务系统中查询其课程的成绩”就是所要绘制的时序图的交互内容，不用往上延伸到用户登录，也不要往下延伸到下载成绩单。<br>识别交互的语境，即是读懂所要画的时序图的前提和背景。比如本例中，既然学生可以查询成绩，那么该学生肯定已经注册并认证过其身份，并可选择其所考试的课程查询相应成绩。</p><p><strong>2、梳理角色和对象</strong><br>在本例中，角色有学生，对象有教务系统、课程、成绩。<br>对象的梳理是一个相对主观的过程，比如本例中，课程以及成绩分别作为了对象存在，也可以合并为数据库这一个对象。</p><p>请注意：角色以及对象，都为名词，动词不可作为角色和对象，如“成绩查询”不可作为对象。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635746641312-1d064301-2161-432f-9276-85c614a9a9aa.png#clientId=u69d38362-af57-4&from=paste&height=425&id=u511a1d4b&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=713&originalType=url%E2%88%B6=1&status=done&style=none&taskId=ue0994e6f-d14e-4134-9980-4f4a0cadcd1&width=496"><br><strong>3、添加消息</strong><br>学生的登录验证作为本时序图的前置行为，可直接引用到本时序图中，也可忽略不画；学生进入成绩查询页面后，页面会加载本学生的成绩查询课程列表，并显示出课程对应的成绩；<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635746433447-bda9cfdf-3a8f-4418-99e9-99412acbc172.png#clientId=u69d38362-af57-4&from=paste&height=357&id=u8e0f9b4a&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=713&originalType=url%E2%88%B6=1&status=done&style=none&taskId=uf9d2d186-1b19-4cac-adee-eed1e1f2c4e&width=417"></p><h2 id="7-协作图（Collaboration-Diagrams）"><a href="#7-协作图（Collaboration-Diagrams）" class="headerlink" title="7. 协作图（Collaboration Diagrams）"></a>7. 协作图（Collaboration Diagrams）</h2><p>交互图的一种，描述了收发消息的对象的组织关系，<strong>强调对象之间的合作关系</strong>。时序图按照时间顺序布图，而协作图按照空间结构布图，不关心什么时候消息被传递，只关心对象的角色<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635644973796-1b2d09b7-cda1-4d7d-8798-e8b06b941055.png#clientId=ue01307b8-45f4-4&from=paste&height=251&id=ue9f4978d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=832&originalType=binary%E2%88%B6=1&size=61105&status=done&style=none&taskId=ud5f5d373-bfc6-4f1c-ba25-fe2bb281d1c&width=485" alt="image.png"><br>对象角色矩形上标有类或对象名（或者都有）。类名前面有个冒号（：）。<br>协作图的每个消息都有一个序列号。顶层消息的数字是 1。同一个等级的消息（也就是同一个调用中的消息）有同样的数字前缀，再根据他们出现的顺序增加一个后缀 1，2 等等。</p><h2 id="8-组件图-（Component-Diagrams）"><a href="#8-组件图-（Component-Diagrams）" class="headerlink" title="8. 组件图 （Component Diagrams）"></a>8. 组件图 （Component Diagrams）</h2><p>表示一组组件之间的组织和依赖关系 编译和部署系统的人员需要使用组件图。显示了类与实现组件之间的映射，组件按什么顺序编译，编译时生成哪些运行组件 构件图对于通过正向工程和逆向工程构造可执行系统是重要的</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635645288727-dfaf24de-554c-47ac-87e0-370f365cdaa5.png#clientId=ue01307b8-45f4-4&from=paste&height=350&id=u67a2214e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=460&originWidth=891&originalType=binary%E2%88%B6=1&size=54362&status=done&style=none&taskId=u4cd0a0be-2f09-4eef-861d-92f89d45dbd&width=677.5" alt="image.png"></h2><h2 id="9-部署图-（Deployment-Diagrams）："><a href="#9-部署图-（Deployment-Diagrams）：" class="headerlink" title="9. 部署图 （Deployment Diagrams）："></a>9. 部署图 （Deployment Diagrams）：</h2><p>建模系统的实际部署 项目管理员，用户，分析员和部署人员通过实施图了解，显示网络的实际布局和网络节点上组件的配置<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1635602054833-afec0cac-205e-4eb9-aa67-4ecc788a2920.png#clientId=u67980cd5-ed5c-4&from=paste&height=315&id=u3732ab79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=567&originalType=url%E2%88%B6=1&size=40984&status=done&style=none&taskId=u3da962c1-ded3-48d9-bb71-180edab7d58&width=405" alt="image.png"></p><h2 id="图的差异比较"><a href="#图的差异比较" class="headerlink" title="图的差异比较"></a>图的差异比较</h2><h3 id="1-序列图-时序图-VS-协作图"><a href="#1-序列图-时序图-VS-协作图" class="headerlink" title="1.序列图(时序图)VS 协作图"></a>1.序列图(时序图)VS 协作图</h3><p>序列图和协作图都是交互图。二者在语义上等价，可以相互转化。但是侧重点不同：序列图侧重时间顺序，协作图侧重对象间的关系。</p><ul><li>共同点：时序图与协作图均显示了对象间的交互。</li><li>不同点：时序图强调交互的时间次序。协作图强调交互的空间结构。</li></ul><h3 id="2-状态图-VS-活动图"><a href="#2-状态图-VS-活动图" class="headerlink" title="2.状态图 VS 活动图"></a>2.状态图 VS 活动图</h3><p>状态图和活动图都是行为图。状态图侧重从行为的结果来描述，活动图侧重从行为的动作来描述。状态图描述了一个具体对象的可能状态以及他们之间的转换。在实际的项目中，活动图并不是必须的，需要满足以下条件：</p><ul><li>1、出现并行过程&amp;行为；</li><li>2、描述算法；</li><li>3、跨越多个用例的活动图。</li></ul><h3 id="3-活动图-VS-交互图"><a href="#3-活动图-VS-交互图" class="headerlink" title="3.活动图 VS 交互图"></a>3.活动图 VS 交互图</h3><p>二者都涉及到对象和他们之间传递的关系。区别在于交互图观察的是传送消息的对象，而活动图观察的是对象之间传递的消息。看似语义相同，但是他们是从不同的角度来观察整个系统的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SonarQube之采购选型参考</title>
      <link href="2021/08/29/yuque/vfvoyq/"/>
      <url>2021/08/29/yuque/vfvoyq/</url>
      
        <content type="html"><![CDATA[<p>SonarQube 是 DevOps 实践中主流的一款质量内建工具，过插件机制，Sonar 可以集成不同的测试工具，代码分析工具，以及持续集成工具，比如 pmd-cpd、checkstyle、findbugs、Jenkins。</p><p>通过不同的插件对这些结果进行再加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。同时 Sonar 还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用 Sonar。<strong>一般情况下，社区版还是可以满足大部分场景的，即便是 C/C++社区也是有其他开源插件的。</strong></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>SonarQube 并不是简单地将各种质量检测工具的结果（例如 FindBugs，PMD 等）直接展现给客户，而是通过不同的插件算法来对这些结果进行再加工，最终以量化的方式来衡量代码质量，从而方便地对不同规模和种类的工程进行相应的代码质量管理。 SonarQube 在进行代码质量管理时，会从图 1 所示的七个纬度来分析项目的质量。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645361536477-19baed46-ccc0-4de3-a77a-0f3d5699255e.png#clientId=u80f9ac51-abfc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=194&id=u79a0e68d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=194&originWidth=352&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32778&status=done&style=none&taskId=u5bf2f9a0-a5e1-47f9-8706-2924bc07012&title=&width=352" alt="image.png"></p><p>SonarQube 可以支持 25+ 种编程语言，针对不同的编程语言其所提供的分析方式也有所不同： 对于所有支持的编程语言，SonarQube 都提供源了代码的静态分析功能； 对于某些特定的编程语言，SonarQube 提供了对编译后代码的静态分析功能，比如 java 中的 class file 和 jar 和 C# 中的 dll file 等； 对于某些特定的编程语言，SonarQube 还可以提供对于代码的动态分析功能，比如 java 和 C# 中的单元测试的执行等。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/5374140/1645372639172-1f9e2c72-d16f-4708-9df1-41ad65b52f5e.png#clientId=u3f51a294-4347-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=417&id=u2c6b3d18&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=914&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=155283&status=done&style=none&taskId=ud78fe533-ebe3-4475-b14e-b0079a124b6&title=&width=713" alt="image.png"><br>远程客户机可以通过各种不同的分析机制，从而将被分析的项目代码上传到 SonarQube server 并进行代码质量的管理和分析，SonarQube 还会通过 Web API 将分析的结果以可视化、可度量的方式展示给用户</p><h2 id="软硬件要求"><a href="#软硬件要求" class="headerlink" title="软硬件要求"></a>软硬件要求</h2><ol><li>硬件上对磁盘读写性能要求高，服务涉及 elasticsearch 索引，IO 读写和分析的代码量直接影响 sonarqube 性能；实际生产环境建议使用专用高速 I/O 存储</li><li>SonarQube server 不支持 32 位，但 SonarQube scannner 支持 32 位</li><li>SonarQube server 仅支持 Java11; SonarQube scanners 同时支持 Java8&amp;11</li><li>数据库支持 PostgreSQL, MSSQL Server, Oracle, 不再支持 Mysql</li></ol><h2 id="版本分类"><a href="#版本分类" class="headerlink" title="版本分类"></a>版本分类</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>全称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>CE</td><td>Community Edition</td><td>社区版</td></tr><tr><td>DE</td><td>Developer Edition</td><td>开发版（具有 CE 版所有特性）</td></tr><tr><td>EE</td><td>Enterprise Edition</td><td>企业版（具有 DE 版所有特性）</td></tr><tr><td>DCE</td><td>Data Center Edition</td><td>数据中心版（具有 EE 版所有特性）</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630251859329-d39337e1-a4a6-4a91-aae3-2022f9f3c762.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=509&id=u0f277aeb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=687&originWidth=1181&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=124309&status=done&style=none&taskId=u565fa461-fbb4-46ad-a456-71b1cff4139&title=&width=875" alt="image.png"></p><h2 id="特性费用对比"><a href="#特性费用对比" class="headerlink" title="特性费用对比"></a>特性费用对比</h2><p><a href="https://www.sonarsource.com/plans-and-pricing/community/">https://www.sonarsource.com/plans-and-pricing/community/</a><br><a href="https://www.sonarsource.com/plans-and-pricing/developer/">https://www.sonarsource.com/plans-and-pricing/developer/</a><br><a href="https://www.sonarsource.com/plans-and-pricing/enterprise/">https://www.sonarsource.com/plans-and-pricing/enterprise/</a><br><a href="https://www.sonarsource.com/plans-and-pricing/data-center/">https://www.sonarsource.com/plans-and-pricing/data-center/</a></p><table><thead><tr><th><strong>类型</strong></th><th><strong>价格</strong></th><th><strong>LOC</strong></th></tr></thead><tbody><tr><td>CE</td><td>免费</td><td>-</td></tr><tr><td>DE</td><td>120 欧元-5 万欧元</td><td>10 万行代码-20M 行代码</td></tr><tr><td>EE</td><td>1.5 万欧元-18 万欧元</td><td>1M 行代码-100M 行代码</td></tr><tr><td>DCE</td><td>10 万欧元-上不封顶</td><td>20M 代码-</td></tr></tbody></table><h3 id="CE-社区免费版本"><a href="#CE-社区免费版本" class="headerlink" title="CE-社区免费版本"></a>CE-社区免费版本</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630252221562-6fdc9b38-c978-4a8e-ab0c-5bf26e48aa1f.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=192&id=u02c0ea3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=879&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=75094&status=done&style=none&taskId=u35b95e99-28f4-4b6a-bbe5-7fa94bfaa4a&title=&width=653" alt="image.png"><br>除了支持 15 种编程语言，CE 版还就有如下特性</p><ul><li>支持 5 种 IDE</li><li>支持 60+的插件</li><li>支持 SonarLint</li><li>支持 Quality Gate</li><li>快速确认近期修改代码的问题</li></ul><p>开源版本不支持一个项目多分支的形式，只能按照特性分支的名称来生成相对应的扫描项目（会产生很多 Sonarqube 项目）。</p><p>解决方案：假如这个项目有 F1，F2 等特性分支，在每次对其中特性分支构建扫描时会配置 sonar 扫描参数（projectName）为 “服务名称_特性分支名称”，这样相当于每个特性分支都对应一个扫描项目。但又间接的带来了一些问题。</p><ul><li>每个特性分支生成一个项目，假如特性分支被删除呢？或者分支很多呢？</li><li>对于 SonarQube 管理员来说很难管理，增加了任务负担。</li></ul><h3 id="DE-开发者版本"><a href="#DE-开发者版本" class="headerlink" title="DE-开发者版本"></a>DE-开发者版本</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630252086655-7dff61e0-2b07-485f-bcfe-983aba176a77.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=340&id=u58d7239c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=1195&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=75855&status=done&style=none&taskId=uf09d58c4-e927-4b39-9e6d-123badd8248&title=&width=711" alt="image.png"><br>相较于 CE 版，增加了 C/C++、Objective-C、T-SQL、ABAP、PL/SQL 和 Swift 等，详细信息如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630252279093-28c8f429-704f-4ce1-afbd-a1743d16340e.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=244&id=ubeb4777e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=881&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=89933&status=done&style=none&taskId=u6318006f-5806-4b0f-963e-345a6cae8e7&title=&width=716" alt="image.png"><br>DE 版具有 CE 版所有特性，在此基础之上，该版本还有如下特性增强：</p><ul><li>支持 22 种编程语言</li><li>支持 Pull Request 的分支代码分析</li><li>安全性的增强：Security Hotspots &amp; Security Vulnerabilities 的全面支持</li><li>支持 SonarLint 的智能提示，更好地与 IDE 进行集成</li></ul><h3 id="EE-企业版本"><a href="#EE-企业版本" class="headerlink" title="EE-企业版本"></a>EE-企业版本</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630252129617-1fbe1c36-5be4-46fc-99f3-e6a2f822cef1.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=ubabf1e89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=495&originWidth=1166&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=69600&status=done&style=none&taskId=u95c0518c-77ba-4859-88d9-24af3fe38c5&title=&width=759" alt="image.png"><br>相较于 DE 版，增加了 Apex、COBOL、PL/1、RPG 和 VB6 等五种，详细信息如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630252295211-23cc2bc4-fb6a-4089-a750-50bbaab82472.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=268&id=ua7ab0b53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=838&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=97221&status=done&style=none&taskId=u1e2f6eb7-3a8e-432a-a39b-0eb6dd36cfd&title=&width=750" alt="image.png"></p><p>EE 版具有 DE 版所有特性，在此基础之上，该版本还有如下特性增强：</p><ul><li>支持 27 种编程语言</li><li>支持对于 Portfolio 的管理</li><li>提供 OWASP / SANS 的安全报告</li><li>提供可配置的 SAST 分析引擎</li></ul><h3 id="DCE-数据中心版本"><a href="#DCE-数据中心版本" class="headerlink" title="DCE-数据中心版本"></a>DCE-数据中心版本</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630252158949-be1930d4-64c6-411b-9433-890148edee39.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=335&id=u50549072&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=1175&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=65603&status=done&style=none&taskId=ue793064f-9f4a-4ea9-b429-21be21fd559&title=&width=836" alt="image.png"><br>EE 版具有 EE 版所有特性，此版本主要对于高可用性和横向扩展性有更好的支持。</p><h2 id="如何计算费用？"><a href="#如何计算费用？" class="headerlink" title="如何计算费用？"></a>如何计算费用？</h2><p>Sonarqube 是按照扫描的行数进行计费的，以年为单位进行订阅。关于行数如何解读？假如你买 100W 行扫描量，那么这个量是被所有项目共享的，但扫描的行数超过 100W 行，分析服务将会终止。当然如果你删除项目重置，扫描量就会恢复。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1630252876197-35f04eae-e476-4f6e-8368-64b5b1beaf45.png#clientId=u43a19740-2098-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=313&id=u0e6f78b0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=1130&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=69511&status=done&style=none&taskId=ucf794015-5c38-4892-93eb-60f6be6112f&title=&width=1064" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>敏捷实践思考</title>
      <link href="2021/05/18/yuque/taegsk/"/>
      <url>2021/05/18/yuque/taegsk/</url>
      
        <content type="html"><![CDATA[<h2 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h2><p>用户故事通常使用下面的格式编写：<br>“作为……<br>我希望……<br>以便……”<br>这促使我们从用户的角度出发编写用户故事（虽然不一定是最终用户）。<br>但是，这些年来，我发现，使用这种格式编写操作故事并未真正带来同等的改善效果。这可能是因为“用户角度”没有影响解决方案的技术实现方式。不管怎样，如果你是自己实现解决方案，那么写上“作为一名系统管理员”或者“作为一名开发人员”就感觉有点多余。</p><p>在编写待办事项列表中的“技术待办事项”时，不使用“作为……我希望……以便……”这种格式的情况并不少见，类似地，我不推荐使用这种格式编写操作特性。取而代之，我更喜欢<strong>使用“什么和为什么”格式，只是简单地列出需要做什么以及为什么做（提供上线文）。</strong></p><h2 id="冲刺"><a href="#冲刺" class="headerlink" title="冲刺"></a>冲刺</h2><p>感觉为期两周的冲刺正好可以开发新特性、测试&amp;部署，然后向相关人员展示。再长一点就很难保持注意力，而反馈循环的数量会增长到一个让人稍微有点不适的数量。再短一点，比如一个周，那么临时会议和其他仪式在实际冲刺时间中的占比就会过高，就是说，你可以完成的工作就会很少。因此，对许多人来说，两个周刚好。这么长一段时间刚好可以让你铺下身子，专心完成你承诺的工作。</p><p>如果你在开发一款新产品，这很好，但如果你是在进行一些改进迭代或者开发产品的下一个版本呢？谁将负责生产平台上不断出现的所有问题？<br>如果你相当频繁地被这类事情打断（或者遭遇不同程度的此类干扰），那么你就会知道，这会严重地妨碍你兑现冲刺承诺。从帮助人们专注于现实目标来看，为期两周的冲刺似乎带来了很大的价值，但在一个不可预测的环境里，很难准确地确定你可以在多大程度上完成待办事项列列表上的内容。很难，但并不是不可能。</p><p>如果可以度量出待办事项列表上的工作我们平均能够完成多少，以及生产平台的问题平均打断我们多少次，那么我们大致上可以推导出两个速度。<strong>待办事项速度是指我们可以以什么样的速度完成产品/服务待办事项列表上“计划好”的工作，而“计划外”速度是冲刺期间意外产生的工作量。跟踪这两个速度，我们可以做出有效的计划。</strong><br>当然，看板也是一种选择，可以兼顾计划好的和计划外的工作，不太清楚一周后要做什么的团队通常会选择这个框架。该框架还可以非常高效地交付周期较长的项目/版本，但需要很强的纪律性来确保可以动态、恰当地调整待办事项的优先级。</p><h2 id="冲刺计划"><a href="#冲刺计划" class="headerlink" title="冲刺计划"></a>冲刺计划</h2><p>如果你在做冲刺，就需要做冲刺计划。将 DevOps 引入冲刺计划，需要做以下工作：</p><ul><li>邀请运维/基础设施/支持人员参加计划会议</li><li>不仅要讨论产品功能，还要讨论操作特性</li><li>把它们加入接下来的冲刺</li><li>把“打断”可能占用的时间&amp;精力考虑进来——就是来自产品平台的计划外工作，如 Bug 修复、升级等（这个值就是“计划外速度”，它会显著降低待办事项速度。计划外速度越高，待办事项速度就越低）</li></ul><h2 id="DevOps-反模式"><a href="#DevOps-反模式" class="headerlink" title="DevOps 反模式"></a>DevOps 反模式</h2><p>DevOps 的重点是消除 Dev 和 Ops 之间的鸿沟，减少让人痛苦的工作交接，加强合作，以便类似“可部署性”、可扩展性、监控和技术支持这样的工作不会被简单地视为计划外的东西。<br>不过，我们已经开始看到 DevOps 场景中出现了强大的反模式，比如，Dev 团队和 DevOps 团队的隔离，导致另一个筒仓的产生，而没有做多少工作来加强合作。</p><p>问题是，从实践角度讲，关于如何将这种新的 DevOps 方法融入敏捷开发团队的信息极少。<br>我们需要采用什么做法？我们需要停止什么做法？我们如何开始？我们的团队应该配备什么角色？在很大程度上，这些问题仍然悬而未决。因此，团队只是“追加”了 DevOps，而没有将其完全整合到他们的软件开发流程。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1655655039583-ff959bfd-08d5-4caa-94d7-edf6bb3ea805.jpeg#clientId=uc3fd37a0-f464-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=227&id=u2afec391&margin=%5Bobject%20Object%5D&name=0.jpeg&originHeight=254&originWidth=451&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=19440&status=done&style=none&taskId=ub58d6bd0-9ed5-403b-af45-4c3bcb00525&title=&width=403" alt="0.jpeg"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/5374140/1655655105654-57918e07-953f-4615-82c2-cbffe4a12658.jpeg#clientId=uc3fd37a0-f464-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=187&id=u17b3c61b&margin=%5Bobject%20Object%5D&name=0.jpeg&originHeight=137&originWidth=451&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=8114&status=done&style=none&taskId=ue72280ec-a815-4c2d-bc58-8889ea1c4f4&title=&width=615" alt="0.jpeg"><br>在这个典型的 DevOps 反模式中，我们完成了所有的敏捷仪式以及许多常规的 DevOps 实践，但是，最终的结果没有比以前更好——可操作性仍然是后期问题，产品针对开发优化，而不是交付和运维。这都是因为他们只是“追加”了关键的 DevOps 实践，而没有从一开始就合并进来。<br>不用说，解决方案就是从一开始就将这些好的 DevOps 实践合并进来，把它们吸收到我们日常的敏捷流程和实践中</p><h2 id="团队建设"><a href="#团队建设" class="headerlink" title="团队建设"></a>团队建设</h2><p>我们共事过的大部分敏捷团队都不包含 Ops、技术支持或基础设施专家。你可能会反驳说，并不是每个敏捷团队都有配备此类专家的强烈需求，你可能是对的，但不要忘了，对于测试人员、架构师、数据库工程师、UX 等，人们的说法也是完全一样的。<br>如果那种交付、支持、升级、扩展和维护产品的方式是重要的，你的团队就需要这些技能。<br>这意味着你要打破杰夫·贝索斯“两个披萨团队”的原则吗？也许吧。但是，如果你的那份披萨对你特别重要，那么就不断提高自己的技能吧！（那实际上没有听上去那么难——我们越趋向 X 即服务的世界，我们所需要的核心系统管理知识就越少。取而代之，我们都需要对云函数及相关服务有一个很好的了解。）</p><h2 id="待办事项列表"><a href="#待办事项列表" class="headerlink" title="待办事项列表"></a>待办事项列表</h2><p>如果我们有跨职能团队，那么我们就会需要跨职能的待办事项列表。<br>忘掉传统的产品待办事项列表——是时候采用一种包括服务操作性方面的全新方法了。我们有意使用了“服务”一词，因为现如今我们倾向于构建的实际上是服务，而不是用收缩塑料薄膜包装的产品。服务是需要部署、扩展、维护、监控和支持的产品，而我们的待办事项列表需要反映出来。</p><p>我们看到的大多数 Scrum 产品待办事项列表，90%的内容是传统特性，这些特性可以描述为一个最终用户期望特性的集合。剩下的 10%往往是与性能相关的东西，或者是与准备工作相关的东西（配置开发环境、准备数据库等）。很明显，这样的列表侧重于最终用户功能/产品特性。我不能确定，这是 Scrum 框架本身造成的，还是产品经理对最终用户存在偏见导致的（或者完全是另外一回事）。</p><p>因此，新式的服务待办事项列表（除了用户功能外）应该描述如下内容：</p><ul><li>产品/服务的可扩展性（向上、向下、向内、向外——以及何时）</li><li>可部署性（需要在线部署而不停机吗？）</li><li>服务监控（哪些方面需要监控？每次变更后如何升级监控？）</li><li>日志（日志应该记录什么信息？采用什么格式？）</li><li>报警（谁？何时？如何？为什么？）</li><li>服务的可测试性</li><li>安全和法规遵从性方面，如加密模型、数据保护、PCI 法规遵从性、数据法规，等等</li><li>操作性能</li></ul><p>Skelton 说：“为了避免在开始时‘使用旧的构建方式’，我们需要将相当一部分产品预算（和团队时间）用在运维方面。我发现，一般来说，将大约 30%的产品预算用在运维方面就会产生不错的结果，我们由此就可以获得可维护、可部署、可诊断、多年以后仍然可以有效运行的系统。”</p><p>需要注意的是，这些操作性和安全方面的需求会不断地变化，会随产品/服务演化，因此，我们不能只是在发布初期把所有那些工作完成，然后就转向传统的产品特性。例如，在系统取得商业成功之前实现系统自动扩展方案可能并不划算。又或者，为了符合新的安全规范，你需要修改加密模型。同样地，当在新的地方上线时，你可能需要修改那个部署模型。此外，当应用程序的功能发生任何大的变更时，监控通常都需要升级。</p><p>##</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DevOps工程师学习路径</title>
      <link href="2021/05/06/yuque/rgp06g/"/>
      <url>2021/05/06/yuque/rgp06g/</url>
      
        <content type="html"><![CDATA[<p>##</p><p>DevOps 实际上是什么意思？?<br>DevOps 是一种软件开发方法，涉及持续开发，持续测试，持续集成，部署和监视。这一系列过程跨越了传统上孤立的开发和运营团队，DevOps 试图消除它们之间的障碍。<br>因此，DevOps 工程师基本上与 Development 和 Operations 团队合作，DevOps 是这两个主要部分之间的链接。</p><p>DevOps 包括诸如构建自动化、CI/CD、基础架构即代码等概念，并且有许多工具可以实现这些概念。由于这些工具数量众多，因此可能会造成混乱和压倒性的结果。<br>最重要的是要了解概念，并为每个类别的学习找一种特定的工具。例如，当你已经知道什么是 CI/CD 并知道如何使用 Jenkins 时，也将很容易学习同类型的其他替代工具。</p><p>接下来让就来看看学习 DevOps 需要掌握哪些技能。</p><h2 id="1）软件开发的概念"><a href="#1）软件开发的概念" class="headerlink" title="1）软件开发的概念"></a><strong>1）软件开发的概念</strong></h2><p>作为一名 DevOps 工程师，你不会直接对应用程序进行编程，但是当你与开发团队紧密合作以改善和自动化他们的任务时，你需要了解以下概念：</p><ul><li>开发人员的工作方式</li><li>他们正在使用哪个 git 工作流程</li><li>如何配置应用程序</li><li>自动化测试</li></ul><h2 id="2）操作系统"><a href="#2）操作系统" class="headerlink" title="2）操作系统"></a><strong>2）操作系统</strong></h2><p>作为 DevOps 工程师，你负责准备在操作系统上部署应用程序的所需要的基础结构环境。并且由于大多数服务器是 Linux 服务器，因此你需要了解 Linux 操作系统，并善于使用命令行，所以你需要知道：</p><ul><li>基本的 Shell 命令</li><li>Linux 文件系统</li><li>管理服务器的基础知识</li><li>SSH 密钥管理</li><li>在服务器上安装不同的工具</li></ul><h2 id="3）网络与安全"><a href="#3）网络与安全" class="headerlink" title="3）网络与安全"></a><strong>3）网络与安全</strong></h2><p>你还需要了解网络和安全性的基础知识才能配置基础架构，例如：</p><ul><li>配置防火墙以保护应用程序</li><li>了解 IP 地址，端口和 DNS 的工作方式</li><li>负载均衡器</li><li>代理服务器</li><li>HTTP/HTTPS</li></ul><p>但是，要在 DevOps 和 IT Operations 之间划清界线，你不是系统管理员。因此，在这里不需要高级知识，理解和了解基本知识就够了。IT 方面是这些 SysAdmins，Networking 或 Security Engineers 人的专长。</p><h2 id="4）容器化"><a href="#4）容器化" class="headerlink" title="4）容器化"></a><strong>4）容器化</strong></h2><p>随着容器成为新标准，你可能会将应用程序作为容器运行，这意味着你需要大致了解：</p><ul><li>虚拟化的概念</li><li>容器的概念</li><li>学习哪个工具？Docker - 当今最受欢迎的容器技术</li></ul><h2 id="5）持续集成和部署"><a href="#5）持续集成和部署" class="headerlink" title="5）持续集成和部署"></a><strong>5）持续集成和部署</strong></h2><p>在 DevOps 中，所有代码更改（例如开发人员的新功能和错误修复）都应集成到现有应用程序中，并以自动化方式连续地部署到最终用户。因此，建立完整的 CI/CD 管道是 DevOps 工程师的主要任务和职责。<br>在完成功能或错误修正后，应自动触发在 CI 服务器（例如 Jenkins ）上运行的管道，该管道：</p><ul><li>运行测试</li><li>打包应用程序</li><li>构建 Docker 镜像</li><li>将 Docker Image 推送到工件存储库，最后</li><li>将新版本部署到服务器（可以是开发，测试或生产服务器）</li></ul><p>因此，你需要在此处学习技能：</p><ul><li>设置 CI/CD 服务器</li><li>构建工具和程序包管理器工具以执行测试并打包应用程序</li><li>配置工件存储库（例如 Nexus，Artifactory）</li></ul><p>当然，可以集成更多的步骤，但是此流程代表 CI/CD 管道的核心，并且是 DevOps 任务和职责的核心。<br>学习哪个工具？Jenkins 是最受欢迎的人之一。其他：Bamboo，Gitlab，TeamCity，CircleCI，TravisCI。</p><h2 id="6）云提供商"><a href="#6）云提供商" class="headerlink" title="6）云提供商"></a><strong>6）云提供商</strong></h2><p>如今，许多公司正在使用云上的虚拟基础架构，而不是管理自己的基础架构。这些是基础架构即服务（IaaS）平台，可提供一系列服务，例如备份，安全性，负载平衡等。<br>因此，你需要学习云平台的服务。例如。对于 AWS，你应该了解以下基本知识：</p><ul><li>IAM 服务-管理用户和权限</li><li>VPC 服务-你的专用网络</li><li>EC2 服务-虚拟服务器</li><li>AWS 提供了更多的服务，但是你只需要了解你实际需要的服务即可。例如，当 K8s 集群在 AWS 上运行时，你还需要学习 EKS 服务。</li></ul><p>AWS 是功能最强大，使用最广泛的一种，但也是最困难的一种。<br>学习哪个工具？AWS 是最受欢迎的一种。其他热门：Azure，Google Cloud，阿里云，腾讯云。</p><h2 id="7）容器编排"><a href="#7）容器编排" class="headerlink" title="7）容器编排"></a><strong>7）容器编排</strong></h2><p>如前所述，容器已被广泛使用，在大公司中，成百上千个容器正在多台服务器上运行，这意味着需要以某种方式管理这些容器。<br>为此目的，有一些容器编排工具，而最受欢迎的是 Kubernetes。因此，你需要学习：</p><ul><li>Kubernetes 如何工作</li><li>管理和管理 Kubernetes 集群</li><li>并在其中部署应用程序</li></ul><p>学习哪个工具？Kubernetes - 最受欢迎。</p><h2 id="8）监视和日志管理"><a href="#8）监视和日志管理" class="headerlink" title="8）监视和日志管理"></a><strong>8）监视和日志管理</strong></h2><p>软件投入生产后，对其进行监视以跟踪性能，发现基础结构以及应用程序中的问题非常重要。因此，作为 DevOps 工程师的职责之一是：</p><ul><li>设置软件监控</li><li>设置基础架构监控，例如用于你的 Kubernetes 集群和底层服务器。</li></ul><p>学习哪个工具？Prometheus, Grafana…</p><h2 id="9）基础设施即代码"><a href="#9）基础设施即代码" class="headerlink" title="9）基础设施即代码"></a><strong>9）基础设施即代码</strong></h2><p>手动创建和维护基础架构非常耗时且容易出错，尤其是当你需要复制基础架构时，例如用于开发，测试和生产环境。<br>在 DevOps 中，希望尽可能地自动化，那就是将“基础结构即代码（Infrastructure as Configuration）”引入其中。因此使用 IaC ，我们将使用代码来创建和配置基础结构，你需要了解两种 IaC 方式：</p><ul><li>基础设施配置</li><li>配置管理</li></ul><p>使用这些工具，可以轻松地复制和恢复基础结构。因此，你应该在每个类别中都知道一种工具，以使自己的工作更有效率，并改善与同事的协作。<br>学习哪个工具？<br>基础架构设置：Terraform 是最受欢迎的一种。配置管理：Ansible，Puppet，Chef。</p><h2 id="10）脚本语言"><a href="#10）脚本语言" class="headerlink" title="10）脚本语言"></a><strong>10）脚本语言</strong></h2><p>作为 DevOps 工程师就常见的工作就是编写脚本和小型的应用程序以自动化任务。为了能够做到这一点，你需要了解一种脚本或编程语言。<br>这可能是特定于操作系统的脚本语言，例如 bash 或 Powershell。<br>还需要掌握一种独立于操作系统的语言，例如 Python 或 Go。这些语言功能更强大，更灵活。如果你善于使用其中之一，它将使你在就业市场上更具价值。<br>学习哪个工具？Python：目前是最需要的一个，它易于学习，易于阅读并且具有许多可用的库。其他：Go，NodeJS，Ruby。</p><h2 id="11）版本控制"><a href="#11）版本控制" class="headerlink" title="11）版本控制"></a><strong>11）版本控制</strong></h2><p>上述所有这些自动化逻辑都作为代码编写，使用版本控制工具（例如 Git）来管理这些代码和配置文件。<br>学习哪个工具？Git - 最受欢迎和广泛使用。<br>[</p><p>](<a href="https://mp.weixin.qq.com/s/HTiPTC1UFg-fs2YCPlOKkQ##">https://mp.weixin.qq.com/s/HTiPTC1UFg-fs2YCPlOKkQ##</a>)<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620315836733-72a84025-18f8-4702-919f-53e62f5fea1d.png#crop=0&crop=0&crop=1&crop=1&id=v8fEH&originHeight=2356&originWidth=1263&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 在团队中的最佳实践</title>
      <link href="2021/05/03/yuque/vn8en5/"/>
      <url>2021/05/03/yuque/vn8en5/</url>
      
        <content type="html"><![CDATA[<p>现代软件开发过程中要实现高效的团队协作，需要使用代码分支管理工具实现代码的共享、追溯、回滚及维护等功能。目前流行的代码管理工具，包括 CVS，SVN，Git，Mercurial 等。</p><p>相比 CVS 和 SVN 的集中管理，Git 具有非常明显的优势，<strong>例如：去中心化的代码管理方式减少了开发者对中心服务器的依赖，每个成员在本地都有一个完整的代码库，在不联网的情况下也能提交代码；不同于 SVN 中的每个分支具有独立的代码，Git 中的每一个分支只是指向当前版本的一个指针，Git 的分支策略使创建和合并分支变得快捷灵活</strong>。</p><p>根据开源社区网站 OpenHub 的统计，使用 Git 管理代码的项目逐年快速增加，如今 Git 在代码管理领域已经占据主导地位。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620048579072-f2416483-61a4-4d39-b1bb-f60fd4a7bef8.png#clientId=u26d01617-abe4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=462&id=u9fb555b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=525&originWidth=720&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=42133&status=done&style=none&taskId=u5a960790-1542-4db9-910e-93859feb3a5&title=&width=634" alt="image.png"><br>从百度指数，也可以看到 Git 的优势被越来越多的人所认可。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620048686121-0fe5f3c1-d5ca-4956-8a27-75b4ebd86397.png#clientId=u26d01617-abe4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=315&id=uc0e4a818&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=1235&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=91375&status=done&style=none&taskId=u8717a9cd-6909-4bda-b1fa-a441b8e0fba&title=&width=818" alt="image.png"></p><h2 id="Git-的优势"><a href="#Git-的优势" class="headerlink" title="Git 的优势"></a>Git 的优势</h2><ul><li>Git 可以在本地进行提交以支持离线工作；</li><li>Git 可以在本地创建分支并且没有命名空间冲突的问题；</li><li>Git 可以让提交通过 Pull Request 的方式进行，不需要所有的开发者都有主仓库的写权限；</li><li>Git 在优化性能时选择了合并分支作为主要的性能衡量指标，将合并分支变成了成本非常低的操作以鼓励分支的使用；</li><li>Git 通过 SHA-1 哈希来保证仓库中数据的可靠性，通过 SHA-1 就可以对数据进行校验，抵御了来自攻击者的恶意篡改；</li></ul><p>Git 作为分布式的代码管理工具，越来越多的团队开始使用它并逐步替代集中式的 SVN 或 TFVC，同时也面临新的挑战。这里我将从以下几个方面总结分享一些最佳实践。</p><h2 id="版本管理的挑战"><a href="#版本管理的挑战" class="headerlink" title="版本管理的挑战"></a>版本管理的挑战</h2><p>大家工作在同一个仓库上，那么彼此的代码协作必然带来很多问题和挑战，如下：</p><ol><li><strong>如何开始一个 Feature 的开发，而不影响别的 Feature？</strong></li><li><strong>由于很容易创建新分支，分支多了如何管理，时间久了，如何知道每个分支是干什么的？</strong></li><li><strong>哪些分支已经合并回了主干？</strong></li><li><strong>如何进行 Release 的管理？开始一个 Release 的时候如何冻结 Feature, 如何在 Prepare Release 的时候，开发人员可以继续开发新的功能？</strong></li><li><strong>线上代码出 Bug 了，如何快速修复？而且修复的代码要包含到开发人员的分支以及下一个 Release?</strong></li></ol><p>大部分开发人员现在使用 Git 就只是用三个甚至两个分支，一个是 Master, 一个是 Develop, 还有一个是基于 Develop 打得各种分支。这个在小项目规模的时候还勉强可以支撑，因为很多人做项目就只有一个 Release, 但是人员一多，而且项目周期一长就会出现各种问题。</p><h2 id="Git-代码分支模型"><a href="#Git-代码分支模型" class="headerlink" title="Git 代码分支模型"></a>Git 代码分支模型</h2><p>在使用 Git 管理代码以及多人协作的开发模式下，一个团队甚至一个公司对 Git 的使用有统一规范的工作流程尤为重要<br>开发团队遵循统一的规则执行功能开发，问题修复，分支合并，版本迭代及发布等操作，可以使团队合作变得平滑顺畅，项目有序向前推进，<br>我们把组织内这样的工作流程（workflow）称为 Git 代码分支管理模型</p><p><strong>主流的 git 代码分支管理模型：</strong></p><ul><li>Git flow</li><li>GitHub flow</li><li>GitLab flow</li><li>TBD flow</li></ul><h3 id="1-Git-flow"><a href="#1-Git-flow" class="headerlink" title="1. Git flow"></a>1. Git flow</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620049024903-7c5d1c7a-7c57-4c25-a3c4-63378f34661c.png#clientId=u26d01617-abe4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=456&id=ud3a95db8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=503&originWidth=763&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=49143&status=done&style=none&taskId=u328f578c-02c8-4516-8ab3-59f32b81158&title=&width=691" alt="image.png"><br><strong>Git flow 存在两个长期的独立分支：主分支 master 和开发分支 develop，</strong></p><ul><li>主分支: 用于版本发布，主分支的每个版本都是质量稳定和功能齐全的发布版。</li><li>开发分支: 用于日常开发工作，存放最新的开发版代码。当开发分支的代码达到稳定状态并可以发布版本时，代码需要被合并到 master 分支，然后标记上对应的版本标签（tag）。</li></ul><p>如果需要开发新的功能或者解决代码中的问题，则创建辅助分支来解决问题，辅助分支常用于：</p><ul><li><strong>功能开发（Feature），</strong></li><li><strong>版本发布（Release），</strong></li><li><strong>问题修复（Hotfix），</strong></li></ul><p>在辅助分支上的工作完成后，辅助分支将被删除。</p><p><strong>## Feature 分支</strong><br>目的是开发新模块或新功能以满足客户需求，从 develop 分支创建，开发结束后只需要合并回 develop 分支，并不需要合并回 master 主分支。</p><p><strong>## Release 分支</strong><br>是用于准备发布的版本分支，从 develop 分支创建，创建时已经包含了发布所需要的所有功能，所以在这个分支上不再开发新功能，仅对这个预发布版本进行修复问题，创建文档及其他与发布相关的工作，<br>一切就绪后将 Release 分支合并回 master 主分支并打上相应的版本号标签（Tag），同时也合并回 develop 分支。<br>创建单独的 Release 分支可以避免在不同发布版本上的工作互相受影响，例如团队 A 准备发布版本 1.0 的同时，团队 B 正在进行版本 1.1 的功能开发，二者相互独立，不会互相影响。</p><p><strong>## Hotfix 分支</strong><br>通常用于紧急修复当前发布的版本中出现的严重问题，从发布版本的标签或 master 主分支创建，问题修复后合并回 master 主分支并打上新的版本号标签（Tag），同时也合并回 develop 分支或者正在进行中的 Release 分支。<br>创建单独的 Hotfix 分支可以避免打断正在进行中的各项开发工作，客户也不需要等到下一个发布周期才能拿到修复。</p><p>Git flow 需要同时维护两个甚至更多分支，Hotfix 分支从 master 创建，Release 和 Feature 分支从 develop 创建，工作完成后又需要将代码合并回 develop 和 master。</p><p>在实际应用中，很多开发者会忘记合并回 develop 或者 master，并且各辅助分支之间互相独立，<br>如果从 master 上 pull 代码不够及时，一方面可能造成某个分支长期使用已经过时或者错误的代码，另一方面如果与 master 相隔较远，合并分支时可能会有大量代码冲突，往往需要花费很多时间来消除代码冲突，并且非常容易出错，影响项目的持续集成。</p><p>Git flow 的优点在于流程清晰，分支管理严格，适用于发布周期比较长的“版本发布”，发布周期可能是几周，几个月，甚至更长时间。<br>由于保持两个长期分支同步的开销较大，所以 Git flow 并不适用于快速的“持续发布”，ThoughtWorks 还专门将 Git flow 列为不被推荐的技术，建议彻底停止使用。</p><h3 id="2-GitHub-flow"><a href="#2-GitHub-flow" class="headerlink" title="2. GitHub flow"></a>2. GitHub flow</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620049318132-dbcdd62e-ce07-441a-b04a-ba0873a3684b.png#clientId=ud14d936f-bd46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=257&id=uc88b0054&margin=%5Bobject%20Object%5D&name=image.png&originHeight=257&originWidth=763&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=30849&status=done&style=none&taskId=ue178d511-6cd5-493d-afb6-9586219bf40&title=&width=763" alt="image.png"></p><p>GitHub flow 是由 Scott Chacon 于 2011 年提出的代码分支管理模型，这是 GitHub 官方推荐的开发流程，以快速部署为目标，目前大部分开源项目都遵循这一流程。</p><p>Github flow 最大的特点是只有一个长期分支，即主分支 master，且主分支始终保持可发布状态。<br>从 master 上创建新分支进行功能开发、问题修复等，这些分支通过 pull request 将代码合并到 master。<br>为了保证主分支的代码质量，master 的权限只开放给一部分人。<br>Pull request 是请求别人 pull 你的代码库（repository），也就是把开发分支的代码经过代码评审并通过测试后，让有权限的管理员合并回 master。</p><p>不过在实际情况中，代码评审不可能检查出提交的代码中的所有问题，所以对于每次提交的代码进行自动化测试，<br>主分支代码的自动化部署尤其重要，自动化测试能在产品部署前及时发现一部分问题，如果产品部署之后发现严重问题，自动化部署可以在最短时间内把产品回滚到上一个版本。</p><h4 id="优点-amp-缺点"><a href="#优点-amp-缺点" class="headerlink" title="优点&amp;缺点"></a>优点&amp;缺点</h4><p>Github flow 的优点在于流程简单灵活，不需要考虑及管理太多的分支，适用于需要快速集成及“持续发布”的项目，这类项目可能需要每天发布一个版本，甚至一天发布多个版本。<br>但是对于应用场景比较复杂的情况，例如：多个环境下的产品部署，多个版本的发布或问题修复，只有一个 master 便会显得力不从心。</p><h3 id="3-Gitlab-flow"><a href="#3-Gitlab-flow" class="headerlink" title="3. Gitlab flow"></a>3. Gitlab flow</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620051820245-282bff01-1b2d-456b-bfb4-ee5a6c9db9bb.png#clientId=ud14d936f-bd46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=517&id=u979528ba&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=802&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=51727&status=done&style=none&taskId=uccec4fd8-61ab-4dae-9eef-238ce464b42&title=&width=802" alt="image.png"></p><p>GitLab flow 是由 GitLab 的 CEO Sytse Sijbrandij 于 2014 年正式发布的代码分支管理模型，属于 GitHub flow 的演进版本。</p><p>与 GitHub 相同之处是也存在一个长期主分支 mater，从 master 上创建新分支进行功能开发、问题修复等，结束后合并回 master。<br>与 GitHub 不同之处是 GitLab flow 又考虑多环境部署等现实因素，增加 production 产品分支用于在不同的环境下部署产品，或者从 master 的稳定版本创建 release 发布分支用于发布软件。</p><p>如果在产品分支或者发布分支发现问题，就从对应版本分支创建修复分支，修复完成之后，GitLab flow 遵循 “上游优先” 的合并策略，也就是将代码先合并到 master，再合并到下游的 production 或 release 分支。</p><p>和 Github flow 类似，master 的修改权限只开放给部分人，开发分支的工作完成后，代码通过 merge request（类似于 GitHub flow 中的 pull request）请求有权限的管理员把代码合并（merge）回主分支</p><h3 id="4-TBD-flow"><a href="#4-TBD-flow" class="headerlink" title="4. TBD flow"></a>4. TBD flow</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620051873878-946defd2-9fbe-4c95-a37c-e8241d71c156.png#clientId=ud14d936f-bd46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=u623e853b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=842&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=37470&status=done&style=none&taskId=uc1e4e96a-5dfa-4a14-8735-f2eb7fb1c87&title=&width=842" alt="image.png"></p><p>TBD (Trunk-based Development) flow 是由 Paul Hammant 于 2013 年提出的模型。</p><p>TBD flow 最大的特点是所有开发都基于主干 trunk，不再有长期的开发分支，要求所有的提交尽快回到主干，这样可以共享最新的代码，并且能尽可能地减少合并冲突。<br>如果需要发布版本，可以基于 trunk 直接生成新的分支用于发布。</p><p>TBD flow 没有 pull 或者 push request，要求开发人员尽快把代码提交到主干分支，<br>但是 TBD flow 缺乏严格的流程来保证每一份提交代码的质量，如果一些项目开发人员众多且水平不一，同时工作在主分支上可能会在产品发布时才发现不可预知的问题，</p><p>所以 TBD flow 更适用于需要快速迭代的产品，如果在主干分支上发现问题，可以快速进行修复再合并回主干分支。</p><h3 id="5-TBD-flow"><a href="#5-TBD-flow" class="headerlink" title="5. TBD++ flow"></a>5. TBD++ flow</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1620052063951-d3f3cb4b-54b9-4338-a47a-1f29be6ab50f.png#clientId=ud14d936f-bd46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=466&id=u80bb996e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=466&originWidth=802&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=63993&status=done&style=none&taskId=ub1e0c551-f173-429d-8de5-da858740a64&title=&width=802" alt="image.png"></h2><p>TBD++ flow 是 Arrus 公司软件研发部门从 2015 年开始一直沿用的 Git 分支管理模型，<br>产品项目的客户主要是电信级服务运营商，每个国家或地区的需求在主要功能上一致，<br>但在客户定制化方面又存在不少差异，同时项目开发周期较长，整个周期一般在 3 个月到 2 年之间，软件产品在项目前期需要有快速的迭代，在项目后期需要有稳定的发布版本。</p><p>TBD++ flow 以敏捷开发为核心，同时吸收了以上几个主流模型的优点，主要特点如下</p><h4 id="1-基于功能的主分支"><a href="#1-基于功能的主分支" class="headerlink" title="1. 基于功能的主分支"></a>1. 基于功能的主分支</h4><p>只存在一个长期的独立分支，即主分支 master，主分支上功能齐全，通过自动测试保证基本功能运行正常，因为自动测试覆盖不全面或者手动测试不及时，所以无法保证主分支的每个版本都是质量稳定的发布版，但是可以根据功能的完成程度直接从主分支上创建迭代版本用于针对不同客户或者不同时期的功能演示。基于 master 开发功能或者修复问题需要用到以下两个辅助分支：</p><ul><li>Feature 分支：为了开发新模块或新功能以满足客户需求，从主分支上创建 Feature 分支，但是并不要求 Feature 分支上所有的提交尽快回到主分支，开发完成并且通过代码评审及功能测试后才能合并回 master 主分支。为了共用主分支上的最新代码以及避免合并代码时解决代码冲突引起的额外开销，在功能开发过程中 Feature 分支需要始终与 master 保持同步。</li><li>Bugfix 分支：基于主分支创建 Bugfix 分支修复主分支上发现的问题，修复完成并且通过代码评审后代码合并回 master 主分支。</li></ul><p>基于主分支的 Feature 分支和 Bugfix 分支完成后，开发者直接将代码合并回主分支 master，不需要像 GitLab 或 GitHub 那样依赖于少数几个有权限的管理员，这是因为如果一个项目中开发人员比较多的话，管理员没办法做到对每部分代码都熟悉或掌握，所以代码质量交由代码评审和功能测试来掌控，合并代码回主分支的操作由开发者自己完成。</p><p>主分支上的新代码有时候可能因为评审或测试不全面而带来新问题，例如破坏其他功能模块，甚至影响整体功能。为了能尽早发现问题，主分支上的每次提交都会触发系统级自动化测试，并且周期性地对主分支进行人工测试。一旦发现问题，主分支的专职配置管理员（Software Configuration Manager，SCM）将根据问题的严重性和紧迫性决定是否需要直接回退引起问题的提交，或者基于 master 创建 bugfix 分支进行问题修复。</p><p>####</p><h4 id="2-基于发布的-Release-分支"><a href="#2-基于发布的-Release-分支" class="headerlink" title="2. 基于发布的 Release 分支"></a>2. 基于发布的 Release 分支</h4><p>Release 分支负责对外发布软件产品，每个 Release 分支也会配备专职版本配置管理员 SCM，SCM 具有对 Release 分支的最高管理权限。当 master 上已经包含了某个发布所需要的所有功能，并且没有已知的严重问题，此时由 SCM 从主分支上创建 Release 分支准备系统集成测试，和 Git flow 相同，在此分支上不再进行新功能的开发，仅在这个分支上进行修复问题，创建文档，客户参数配置及其他与发布相关的工作，这些代码同时也需要合并回 master 以确保主分支功能的完整性。<br>在每个 Release 分支正式发布前可能还需要将主分支上的一部分关键问题的修复选择性地同步（Cherry-pick）到 Release 分支，这个操作也是由 SCM 完成。</p><p>Release 分支上的工作一切就绪并通过系统集成测试后，SCM 在 Release 分支上打上相应的版本号标签（Tag）进行发布，这点和 Git flow 在主分支上进行发布不同。</p><p>软件产品发布之后，如果发现紧急或者严重的问题，此时需要基于版本发布时的 Release 分支标签创建 Hotfix 分支来修复此类问题，问题修复后合并回该 Release 分支以及其他同样需要此修复的 Release 分支，并打上新的版本号标签（Tag）用于发布，同时代码也需要合并回 master 以确保主分支的健壮性。</p><h2 id="选择合适的分支模型"><a href="#选择合适的分支模型" class="headerlink" title="选择合适的分支模型"></a>选择合适的分支模型</h2><p>Git 代码分支管理模型各具特点，流程只是一个辅助工具，没有最好，只有最合适。<br>例如，</p><ul><li><strong>如果开发团队规模较小又比较分散，产品发布周期较短(例如:初创公司，或者开发的是一个网站或 Web 应用程序，在一天内可能需要发布多个版本)，可以选择 GitHub flow 或者 GitLab flow；</strong></li><li><strong>如果开发团队规模较大，产品发布周期较长(例如:团队超过 20 人，采用了月度或季度发布周期，并且由一个团队负责并行开发多个项目)，可以选择 Git flow，发布周期较短可以选择 TBD flow；</strong></li><li><strong>如果开发团队规模大，产品发布周期长，同时对敏捷的要求比较高，可以考虑 TBD++ flow。每个组织根据产品、项目、人员的特点找到最合适的模型才是共同的目标。</strong></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>无需分支基于主干的开发是团队健康的重要标志<a href="https://www.infoq.cn/article/tFwoy4gko3vJqp5oYYEO">https://www.infoq.cn/article/tFwoy4gko3vJqp5oYYEO</a></li><li>别再推荐 Git Flow 了：<a href="https://www.infoq.cn/article/i7m3UdTFLu1Lv2ai6abv">https://www.infoq.cn/article/i7m3UdTFLu1Lv2ai6abv</a></li><li>一个成功的 Git 分支模型(译文)：<a href="https://segmentfault.com/a/1190000018087325">https://segmentfault.com/a/1190000018087325</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>企业开始实践DevOps如何选择合适的工具平台？</title>
      <link href="2021/05/02/yuque/qpnkoi/"/>
      <url>2021/05/02/yuque/qpnkoi/</url>
      
        <content type="html"><![CDATA[<h2 id="Azure-DevOps-Pipeline"><a href="#Azure-DevOps-Pipeline" class="headerlink" title="Azure DevOps Pipeline"></a>Azure DevOps Pipeline</h2><p>Use Azure Pipelines with YAML<br>azure-pipelines.yml<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1619960451907-958f8aa5-bc3f-415d-94b2-97a3fddfa720.png#clientId=ueb0d6f26-d252-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=168&id=u697b86a7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=168&originWidth=761&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=37346&status=done&style=none&taskId=u24a39d67-b04b-4cf2-84ce-c5b65dbd71f&title=&width=761" alt="image.png"><br>Use Azure Pipelines in the visual designer<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1619960451934-cdc01038-ed8b-4269-b225-f0e8035107bb.png#clientId=ueb0d6f26-d252-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=320&id=u6fff21a5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=728&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=62973&status=done&style=none&taskId=uc3e239ca-b8a3-424c-9b4a-2df131c7904&title=&width=728" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何有效提升团队的微服务落地能力？</title>
      <link href="2021/05/02/yuque/pr6163/"/>
      <url>2021/05/02/yuque/pr6163/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基于单主干分支的持续交付"><a href="#1-基于单主干分支的持续交付" class="headerlink" title="1. 基于单主干分支的持续交付"></a>1. 基于单主干分支的持续交付</h2><p>对于微服务的成功实施，团队持续交付能力是至关重要的衡量指标。在由上百个服务组成的复杂系统中，如果所有服务都按照人为指定发布周期进行整体交付，很容易出现由于细小的失误导致大面积线上故障。</p><p>持续交付实践要求每个独立服务都具有完备的交付流水线，在流水线的末端随时能提供当时最新的可工作、可交付的产品。持续交付通常会配合自动化的测试和部署手段，从而减少功能代码提交到上线的端到端时间。这就使得每个独立服务能按照各自不同的节奏进行发布，并且将自己的发布状态可视化出来。</p><p>采用尽可能精简且稳定的分支策略也是使得持续交付流程能够顺利实施的关键，我们提倡使用单主干的分支策略（<a href="https://link.jianshu.com/?t=https://trunkbaseddevelopment.com/">Trunk Based Development</a>）。</p><p>在单主干的开发方式中，除了一个用于持续开发和集成的『主干分支』（通常即 Master 分支）和一系列依据发布周期创建的发布分支以外，应该避免创建其他的 Long-lived 分支。如果有多个功能需要开发，则推荐采用特性开关（Feature Toggle）的方法来控制它们的发布时机。当然，单主干策略是允许存在短生命周期特性分支的（短于一周），有时这些小分支甚至无需提交到远程仓库中。</p><p>下面这是一幅经典的单主干分支策略示意图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1619942916835-702a5e11-7ece-4623-906f-16f4b3810560.png#clientId=uec067d9d-881e-4&from=paste&height=355&id=NgNjz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=355&originWidth=509&originalType=url&size=118690&status=done&style=none&taskId=ue5efe7e2-2ef3-44ef-b705-af0094ba137&width=509" alt="image.png"></p><p>值得指出的是，在划分得当的微服务系统中，同一个服务需要同时进行开发的特性通常不会多于两到三个（否则应该考虑这个服务是否承担了过多的职责）。因此即使在不需要特性开关和其他额外开发工作量的情况下，已经可以比较好的实现每个功能点的独立发布和测试，这反向说明了微服务架构对于持续交付的实施也是十分友好的。</p><p>除了严格的单主干，一种常见的变式是多主干策略，典型的是一个开发分支加几个固定的发布分支，通常用于无需维护多个发布版本的 SaaS 服务交付。这种模式的优点是能够将发布流水线目标环境和分支显示的关联起来，例如『Develop 分支』对应集成环境，『Release 分支』对应验收环境和正式环境。下图展示了一组与此模式下的持续交付流水线。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1619943021968-d5a8bc8f-0191-4a53-9ddf-934cfbe9b8c3.png#clientId=uec067d9d-881e-4&from=paste&height=174&id=qyrAy&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=1000&originalType=url&size=221301&status=done&style=none&taskId=u0f47803e-16d7-4d78-b082-0e58cd1def7&width=523" alt="image.png"><br><strong>多主干的流水线</strong><br>保持每个服务高频率的集成和交付，会使得有故障的功能在很短的反馈周期内被发现，在快速迭代发布的前提下做到整个系统发布井然有序。这样的氛围不仅有利于改善代码的质量，而且能够提高开发士气，频繁的发布上线也有利于增强团队对产品的荣誉感和自信心</p><h2 id="2-全功能团队"><a href="#2-全功能团队" class="headerlink" title="2. 全功能团队"></a>2. 全功能团队</h2><p>全功能团队是 DevOps 运动所倡导的一种产品团队组织结构，通过将不同角色的业务和技术成员纳入到团队，组成具备端到端交付和运营能力的完整单元。</p><p>康威定律阐述了开发团队的组织结构和其设计的产品结构之间具有的相似关系。许多的实践结果也表明，将全功能团队实践应用在微服务产品中带来的收益，要远远超过它在传统模块化开发的产品中所带来的收益。这是因为<strong>微服务的架构中的所有服务真正具备独立运行和独立运营的能力，从本质上来说就是一个端到端的子业务产品。</strong></p><p>这种架构和团队的影响是双向的。一方面，微服务的运营结构要求团队具有高内聚的自主管理能力。另一方面，全功能团队也为特定服务进行独立技术选型提供了更灵活的发挥空间。服务与团队通常是多对一的关系，每个团队管理的是一组相互关联紧密的服务群，并且可以在必要的情况下对服务进行进一步拆分。在实际的实践中推荐采用例如接口网关（API Gateway）等方式对一组具有业务意义的服务接口进行聚合，从而保证局部服务结构变化不会直接影响服务的消费方的调用。</p><p>值得一说的是，在一些传统企业内的 IT 部门划分，往往已经按照职能分为开发团队、运维团队、运营团队，甚至单独的测试团队。在这样的企业中很难快速完成全功能团队的转变，因此在实施微服务架构过程中比较容易走偏。对于这种情况可以采用<strong>逐步演进</strong>的转换方式，具体途径主要有两种。</p><ul><li><p><strong>第一种方式是进行项目试点</strong>。对于习惯了按功能分层、分块的『实现接口开发』式的组织，即使勉强凑齐每个角色的人组在一起也难以成为真正具备端到端交付能力的团队。因此与其做得徒有其表，不如找出项目中一些全局意识比较到位的成员，对特定的项目进行试点，然后逐步扩大，将这种端到端的责任和意识带入到更多的项目中去。试点的项目应该是以实施现有系统的一个独立业务功能点为目标，而不是开发与企业主线系统无关的短期产品，否则容易出现试点项目很成功，但项目结束便不了了之的结果。</p></li><li><p><strong>第二种方式是先从分开发团队入手，纵向划分项目</strong>。这是对全功能团队的一种妥协式的引入方式，即在开发团队中首先改变系统架构横向分层、局部分块的开发模式，依据业务功能进行上至外部接口、下至业务数据的独立服务拆分，但并不急于在开发团队中引入诸如测试、运维、业务等角色的成员。这种项目划分虽然在一定程度上为微服务架构执行制造了条件，但从长远来看，并不能为团队进行自主的技术栈和基础设施选型、以及业务数据的利用提供足够的空间。</p></li></ul><h2 id="3-自动化运维"><a href="#3-自动化运维" class="headerlink" title="3. 自动化运维"></a>3. 自动化运维</h2><p>自动化运维是实施持续交付的必要前提，因此也可以说是采用微服务架构的必要前提。但这里所说的自动化运维，不仅仅包含持续交付所需的服务部署时『一键操作』能力，更重要的是运维基础设施构建的自动化、以及服务灾备、恢复的自动化。</p><p>微服务架构最初受到追捧的一个原因是它灵活的『局部 Scale Out』能力，以功能点为单元的扩展、收缩，这对于具有业务周期性的服务而言更加重要。但一些企业在自身基础设施自动化不到位的情况下盲目实施微服务，期望通过其实现复杂架构的解构，结果在面对突发线上事故时出现雪崩式的连锁反应，情急之下也只能手工恢复重建，耽误大量时间。</p><p>实施自动化运维涉及的工具有很多，例如 Ansible、SaltStack、Terraform，甚至 Docker 都可以看做是自动化运维的一部分。这当中大多数工具都提供有定义操作行为的领域 DSL，它们通常是一些配置式语言或脚本语言，因此自动化运维也涉及到代码的编写。与开发项目代码不同的地方在于，自动化运维的代码大多不是长期运行的，很多代码也许只在特定场景使用一次，然后就会非常长时间无人问津，直到某些紧急情况才会再次需要用到。此外，运维的代码本身并不直接具有业务价值，这些因素导致它们往往没有被很好的管理起来。</p><p>下面以采用 Ansible 或 SaltStack 这类通用自动化工具为例，介绍一些在实践中需要注意的地方。</p><ul><li><p>首先是运维脚本应该通过 Git 或 SVN 这样的版本管理工具进行归类和管理。通常来说，推荐将特定服务部署的 Ansible 或 SaltStack YAML 脚本文件与服务本身的代码放在同一个代码仓库中，方便开发人员在必要时候快速的修改它。然后将基础设施管理的 YAML 脚本文件放在单独的代码仓库，方便复用和查找。但这样可能带来的问题是，在实际使用时可能会需要同时获取两个代码仓库的脚本以获得完整的部署功能，因此如果使用的其他配套工具对多仓库支持不佳，也可以将所有运维脚本在同一个仓库管理。</p></li><li><p>其次，应该在持续交付流水线上使用服务部署的自动化工具，从而实现快速的交付上线。在条件允许的情况下，还应该在流水线上直接配备自动化的灾备恢复任务入口，以及定期的对这些恢复脚本进行测试和演练。</p></li><li><p>最后，虽然我们鼓励每个团队使用适合自身业务的技术栈进行开发，但对于运维工具的选择通常让同一个产品的各服务采用统一技术栈比较合适（例如不要混用 Ansible 和 SaltStack 的脚本）。这个建议主要考虑到运维工作可能会有较多跨团队协作，以及故障恢复场景下的快速救灾操作，统一的技术栈能为运维人员节约掉工具切换的时间。</p></li></ul><h2 id="4-服务高可用"><a href="#4-服务高可用" class="headerlink" title="4. 服务高可用"></a>4. 服务高可用</h2><p>由于微服务系统中存在着众多跨服务调用，任何一个服务都不能假设自己可以随意的停机一段时间而不对系统的整体功能造成影响。但在现实情况中，正常的服务升级或意外的故障都有可能造成服务短暂或长时间的中断，这种中断轻则引起局部功能不可用，重则导致连锁反应造成重大事故。这些都是在架构设计时候就应该予以考虑的问题。应对这两类情况的方法分别是对服务采用高可用的部署方式，和进行不离线的部署。</p><p>实现服务高可用的方法有很多，常见的有：L7 负载均衡、DNS 负载均衡、服务发现、同步/异步消息队列等。</p><ol><li><p>L7 负载均衡即在 OSI 网络模型应用层进行的软件负载均衡，例如 Nginx 和 HAProxy 都属于这类。这些 L7 负载均衡通常带有后端服务检查的能力，会自动屏蔽掉不可用的后端服务，从而在一部分服务出现故障时候，请求仍然能被正常运行的后端服务接收。</p></li><li><p>DNS 负载均衡是利用了 DNS 服务可以为同一个域名配置多个解析地址，且配置多个地址后，每次解析域名时轮询着将配置的地址返回给请求方，这个特性称为 DNS 轮询。实际上 DNS 轮询仅仅是一种特殊的负载均衡技术，本身并不具有检测服务状态、提供后端服务高可用的功能。但一些新出现的开源 DNS 产品，例如 SkyDNS 和 Consul 将 DNS 服务与服务发现技术进行了结合，具有自动移除不可访问的解析地址的功能，这使得 DNS 负载均衡也可以被用于实现服务的高可用了。</p></li><li><p>服务发现是一种基于注册和查询服务信息的键值数据库服务。提供服务的一方将自己的名称和 IP 地址注册到服务发现的服务端，使用服务的一方则通过服务发现的服务端进行查询，然后将实际请求发送给查询到的目标 IP 地址。服务发现的服务端会负责检测每个注册服务的运行状态，及时移除出现故障的服务，并在每次收到查询时从符合名称的服务中任意返回一个作为结果。</p></li><li><p>消息队列则是一种采用中间媒介解耦服务提供者和消费者的方法。服务之间通过发布和订阅消息进行交互，所有的消息通过队列进行分发和中转。这种结构使得消息队列本身成为所有数据通信的瓶颈，与微服务的去中心化思想相悖，因此并不推荐在大型微服务系统中采用。</p></li></ol><h2 id="5-不离线部署"><a href="#5-不离线部署" class="headerlink" title="5. 不离线部署"></a>5. 不离线部署</h2><p>不离线部署是确保服务随时能发布的必要措施，也是微服务架构团队需要关注的一种能力。在实际应用中，除了一些天生支持不离线部署的技术栈，如 Erlang，多数的服务是原生不支持热升级的。<strong>对于这些服务，通常来说可根据服务『是否能递进式升级』和『是否具有长任务』的特性，分成三种类型：『不能递进升级的服务』，『能递进升级、无长任务的服务』，以及『能递进升级、有长任务的服务』</strong>，分别采用不同策略进行。</p><p>这里先介绍一下服务的『递进式升级』和『具有长任务』。</p><p><strong>递进式升级（Rolling Update）</strong>是指将集群中的服务划成多个分组，每次只升级其中的一个分组，然后依次进行，直到所有服务都升级完成的过程。采用递进式升级会使得集群中的服务有一段时间同时存在新旧两个版本。</p><p><strong>长任务</strong>指是接收到请求后需要花费几秒、甚至几小时才能执行完的任务，例如一些涉及大量计算或需要远程同步调用的事务。具有长任务的服务都有『运行中』和『空闲』这样的运行状态。当服务处于『运行中』的时候，中断它可能导致意外的结果。一般来说在 Linux 中停止服务的流程是先向服务发送一个 TERM 信号，使其正常结束，若是信号发送几秒后，服务仍然在运行，才会发送 KILL 信号将它强行终止。处理短任务的服务通常可以在接收到 TERM 信号后及时停止，因此不存在这种风险。这里应该将『无长任务的服务』与『无状态的服务』加以区分，后者指的是服务对每次请求的处理，不依赖于其他请求。即服务处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息。通常来说，微服务架构中的服务一定是无状态的，但不一定是无长任务的。</p><p><strong>如果服务不能采用递进式的升级</strong>，不论其是否具有长任务，蓝绿部署都是一种十分推荐的部署方式。蓝绿部署的做法是同时准备一组线上运行的服务器，以及一组用于下次部署的服务器，两组服务器具有相同的数量和配置。执行部署时，先将新的服务部署到没有放到线上运行的那组服务器上，等到部署全部完成，直接将负载均衡的流量导向到刚刚这组服务器上，从而使得两组服务器的角色互换。下一次进行部署的时候，则换用另外一组服务器执行部署，然后将负载均衡切换回来。这个过程如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1619948703096-59fe9a4d-f3fd-490e-8a50-6999a7b6b39f.png#clientId=uec067d9d-881e-4&from=paste&height=277&id=pU73z&margin=%5Bobject%20Object%5D&name=image.png&originHeight=376&originWidth=1000&originalType=url&size=250919&status=done&style=none&taskId=u5b20efa7-0d3b-4ebc-99a5-2c2eb52cdb4&width=738" alt="image.png"></p><p><strong>蓝绿部署的过程</strong><br>蓝绿部署的优点在于新旧服务的切换是瞬间完成的，并且当流量切换到另一组服务器上之后，原先的那组服务器可以继续运行，这样即使上面有未完成的任务也不会被强行中断，如果升级后的版本发现了比较严重的问题，也可以快速的切换回原先的版本。而它的缺点也十分明显，那就是会占用比实际需要多一倍的服务器作为下次部署的备用机器。</p><p>一些前端服务可能会属于这类情况，我们也许不希望在升级的过程中，一部分用户看到是新的页面，另一部分看到还是旧的页面。另外对于 Nginx 这类负载均衡工具，后端服务的健康检查并非是实时生效的，有可能出现服务已经离线，但请求仍然被分发到这个主机的情况，因此采用负载均衡作为高可用方案的服务，蓝绿部署也是比较可取的方式。</p><p><strong>如果服务的数量比较多，并且允许同时存在两个运行的版本，那么采用递进式升级方式则会更加节省资源</strong>。以每次升级一个节点的递进方式为例，当升级开始后，我们首先停止所有服务节点中的任意一个，将它进行升级，然后让它重新加入集群，接着从剩下的服务节点从再任意选择一个，直到最后一个服务也被升级完成。这个过程不需要增加额外的服务器资源，只要待升级的服务具有两个以上的节点，就不会对服务的整体功能造成中断。递进式升级的过程如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1619951489336-97437006-be01-48e3-bd39-9b6a6052370d.png#clientId=uec067d9d-881e-4&from=paste&height=290&id=BMqtW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=379&originWidth=1000&originalType=url&size=184021&status=done&style=none&taskId=uad032d56-7ea4-42fb-9a49-c032b5fcb84&width=765" alt="image.png"><br><strong>递进式升级的过程</strong></p><p>显然如果服务本身是不能被随时停止的，那么这种简单的递进升级就不能很好的满足了。此时我们需要对服务的调度进行干涉，以采用服务发现的高可用方式为例，下图展示了一种『带状态检查的递进式升级』策略进行服务部署。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1619951608412-7accae8a-fcd3-4dd3-a3bf-81a7cf5ba528.png#clientId=uec067d9d-881e-4&from=paste&height=256&id=wvHCe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=1000&originalType=url&size=82297&status=done&style=none&taskId=ua254c746-108d-4e25-910d-85b4c681f52&width=845" alt="image.png"><br>带状态检查的递进式升级</p><p>这种升级方法具有普通递进式升级的相似优势，但在集群中有个别服务执行任务时间很长，始终处于『运行中』状态的情况下，将使得升级过程阻塞，大大的延长服务部署的时间。事实上，长任务的服务通常都可以被改造成为批处理式的服务（Batch-Task Service），批处理式服务的升级只需要直接将服务执行文件替换，从根本上简化了升级难度。</p><h2 id="6-监控告警"><a href="#6-监控告警" class="headerlink" title="6. 监控告警"></a>6. 监控告警</h2><p>内存不足、磁盘耗尽、网络中断、服务失效，这些天灾人祸随时可能殃及产品的服务集群。很难想象，在一个庞大的微服务系统中，如果没有合适的监控和告警设施，服务的运营会变得多么混乱不堪。</p><p>对微服务系统进行监控主要需要考虑两个方面：基础设施的监控和应用服务的监控。</p><ul><li><p>基础设施的监控通常由部署在每个节点上的数据采集端、集中式的数据汇聚端、以及数据展示、数据分析和告警通知等部分组成。而监控告警系统的实施中，还需要结合团队的运维自动化能力，选择合适的技术栈进行。开源的 Promethus 和 InfluxDB 都是值得考虑的工具。</p></li><li><p>应用服务的监控通常需要依据具体的开发技术栈进行选择，例如 Java Spring Boot 的服务可以用 Spring Boot Admin、Nodejs 的服务则可用 node-monitor 和 pm2 等，此外也有一些通用的开源工具，例如 Monit。应用服务的监控除了需要能够比较好完成故障的告警外，一些监控工具还能尝试自动恢复故障服务的运行，这些措施都能有效的增加服务的可靠性。</p></li></ul><h2 id="7-容器化"><a href="#7-容器化" class="headerlink" title="7. 容器化"></a>7. 容器化</h2><p>容器是一种能够加速促进团队 DevOps 水平的虚拟化技术。它通过把服务和系统依赖全量打包的镜像格式，将运行环境的设计提前到了开发阶段，并且实现了开发、测试、线上环境的高度一致。由于容器屏蔽了不同服务运行时的差异性，使得基于这种方式进行服务的大规模部署和调度变得简单。具体来说体现在以下几个方面：</p><ul><li><p>首先是运行环境的隔离。在虚拟机时代，由于每个业务依赖的系统环境不同，服务器之间无法通用。各个业务都需要独立管理服务运行环境，还往往造成多个服务同时运行的冲突，和各个运行环境不一致等问题。容器为每个服务提供隔离的运行环境，即使在同一个服务器上运行多种运行时相互有冲突的服务也不会出问题。</p></li><li><p>其次是精细的资源分配。通过虚拟机分配服务资源时，为了简化管理，通常不论服务实际使用多少 CPU 和内存资源，都只能从固定的主机类型中挑选一种，按主机的个数计费。容器能够很好的实现面向资源池的服务管理，各个服务可以根据并发进程数、CPU 和内存用量等资源计费，实现更加精细的资源管理。</p></li><li><p>此外，容器还有利于资源的动态调整。过去企业里的服务器资源一般是按计划分配的，有的部门为了避开繁琐的资源申请流程，一次性申请大量资源囤积备用，造成浪费。容器的面向资源池特性，使得企业能够将所有计算资源进行运行时动态调整，实现按计划分配到按需分配的转变。业务只需适应流量负载的变化。在负载高峰期快速增加资源，保证业务服务质量，在负载低峰期释放资源给其它服务，提高集群资源利用率。</p></li></ul><p>容器将部署、运行的方式和业务很好的进行了解耦，目前已经有许多成熟的基于容器设计的开源调度框架，例如 SwarmKit、Kubernetes、Mesos、Rancher 等。由于微服务架构天生具有集群的特性，采用这些框架能够极大的简化服务部署和运维的工作量。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端常见鉴权方式</title>
      <link href="2021/03/31/yuque/oggaga/"/>
      <url>2021/03/31/yuque/oggaga/</url>
      
        <content type="html"><![CDATA[<p>目前我们常用的鉴权有四种：</p><ol><li><strong>HTTP Basic Authentication</strong></li><li><strong>session-cookie</strong></li><li><strong>Token 验证</strong></li><li><strong>OAuth(开放授权)</strong></li></ol><h2 id="一-HTTP-Basic-Authentication"><a href="#一-HTTP-Basic-Authentication" class="headerlink" title="一. HTTP Basic Authentication"></a>一. HTTP Basic Authentication</h2><p>这种授权方式是浏览器遵守 http 协议实现的基本授权方式,HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。 <br>认证过程： <br>  1． 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器: <br>  Get /index.html HTTP/1.0<br>  Host:<a href="http://www.google.com/">www.google.com</a></p><p>2． 服务器向客户端发送验证请求代码 401,（WWW-Authenticate: Basic realm=”google.com”这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据大抵如下： <br><code> HTTP/1.0 401 Unauthorised</code><br><code> Server: SokEvo/1.0</code><br><code> WWW-Authenticate: Basic realm=”google.com”</code><br><code> Content-Type: text/html</code><br><code> Content-Length: xxx</code></p><p>3． 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。</p><p>4． 用户输入用户名和密码后，将用户名及密码以 BASE64 加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容： <br><code> Get /index.html HTTP/1.0</code><br><code> Host:www.google.com</code><br><code> Authorization: Basic d2FuZzp3YW5n</code></p><p>注：d2FuZzp3YW5n 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为<br>加密，我们只需要输入用户名密码即可）</p><p>5． 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端</p><p>** 效果：**  客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1617206638312-29a03c43-8660-4b20-b9f6-cf56fb9a5b01.png#crop=0&crop=0&crop=1&crop=1&height=258&id=GUiMW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=879&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23650&status=done&style=none&title=&width=879" alt="image.png"><br><strong>认证成功：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1617206673617-45804899-5264-4bb4-ab8d-af1e960a5809.png#crop=0&crop=0&crop=1&crop=1&height=362&id=jo9Nr&margin=%5Bobject%20Object%5D&name=image.png&originHeight=362&originWidth=635&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62578&status=done&style=none&title=&width=635" alt="image.png"><br><strong>server.js</strong><br><code>let express = require(&quot;express&quot;);</code><br><code>let app = express();</code></p><p><code> app.use(express.static(__dirname+&#39;/public&#39;));</code></p><p><code> app.get(&quot;/Authentication_base&quot;,function(req,res)&#123;</code><br><code> console.log(&#39;req.headers.authorization:&#39;,req.headers)</code><br><code> if(!req.headers.authorization)&#123;</code><br><code> res.set(&#123;</code><br><code> &#39;WWW-Authenticate&#39;:&#39;Basic realm=&quot;wang&quot;&#39;</code><br><code> &#125;);</code><br><code> res.status(401).end();</code><br><code> &#125;else&#123;</code><br><code> let base64 = req.headers.authorization.split(&quot; &quot;)[1];</code><br><code> let userPass = new Buffer(base64, &#39;base64&#39;).toString().split(&quot;:&quot;);</code><br><code> let user = userPass[0];</code><br><code> let pass = userPass[1];</code><br><code> `` if(user==&quot;wang&quot;&amp;&amp;pass=&quot;wang&quot;)&#123;</code><br><code> res.end(&quot;OK&quot;);</code><br><code> &#125;else&#123;</code><br><code> res.status(401).end();</code><br><code> &#125;</code><br><code> &#125;</code><br><code> &#125;)</code></p><p><code> app.listen(9090)</code></p><p><strong>index.html</strong><br><code>&lt;!DOCTYPE html&gt;</code><br><code>&lt;html&gt;</code><br><code> &lt;head&gt;</code><br><code> &lt;meta charset=&quot;UTF-8&quot;&gt;</code><br><code> &lt;title&gt;HTTP Basic Authentication&lt;/title&gt;</code><br><code> &lt;/head&gt;</code><br><code> &lt;body&gt;</code><br><code> &lt;div&gt;&lt;/div&gt;</code><br><code> &lt;script src=&quot;js/jquery-3.2.1.js&quot;&gt;&lt;/script&gt;</code><br><code> &lt;script&gt;</code><br><code> $(function()&#123;</code><br><code> send(&#39;./Authentication_base&#39;);</code><br><code> &#125;)</code><br><code> var send = function(url)&#123;</code><br><code>$.ajax(&#123;</code><br><code>url : url,</code><br><code>method : &#39;GET&#39;,</code><br><code> &#125;);</code><br><code> &#125;</code><br><code> &lt;/script&gt;</code><br><code> &lt;/body&gt;</code><br><code>&lt;/html&gt;</code></p><p>这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。<br>正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐</p><h2 id="二-session-cookie"><a href="#二-session-cookie" class="headerlink" title="二. session-cookie"></a>二. session-cookie</h2><p>第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。</p><p><strong>session-cookie 认证主要分四步：</strong></p><ol><li>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion(我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者)，然后给这个 session 生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。</li><li>签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）</li><li>浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求 de 请求头中会带上该域名下的 cookie 信息，</li><li>服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1617207070670-90c14816-aca3-4f6a-a97c-9355c5f6417c.png#crop=0&crop=0&crop=1&crop=1&height=464&id=xmdyK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=464&originWidth=777&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=38976&status=done&style=none&title=&width=777" alt="image.png"><br>server.js(nodejs+express+seesion+redis)</p><p><code>var express = require(&#39;express&#39;);</code><br><code>var RedisStore = require(&#39;connect-redis&#39;)(express.session);</code><br><code>var app = express();</code><br><code>var secret = &quot;wang839305939&quot;</code><br><code>// 设置 Cookie</code><br><code>app.use(express.cookieParser(secret));</code></p><p><code>// 设置 Session</code><br><code>app.use(express.session(&#123;</code><br><code> store: new RedisStore(&#123;</code><br><code> host: &quot;127.0.0.1&quot;,</code><br><code> port: 6379,</code><br><code> db: &quot;session_db&quot;</code><br><code> &#125;),</code><br><code> secret: secret</code><br><code>&#125;))</code></p><p><code>app.get(&quot;/&quot;, function(req, res) &#123;</code><br><code> var session = req.session;</code><br><code> session.time= session.time|| 0;</code><br><code> var n = session.time++;</code><br><code> res.send(&#39;hello, session id:&#39; + session.id + &#39; count:&#39; + n);</code><br><code>&#125;);</code></p><p><code>app.listen(9080);</code></p><h2 id="三-Token-验证"><a href="#三-Token-验证" class="headerlink" title="三.Token 验证"></a>三.Token 验证</h2><p>使用基于 Token 的身份验证方法，大概的流程是这样的：</p><ol><li>客户端使用用户名跟密码请求登录<br> 2. 服务端收到请求，去验证用户名与密码<br> 3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端<br> 4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里<br> 5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token<br> 6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><p>总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。</p><p>乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。</p><ol><li><p>sessionid 他只是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。</p></li><li><p>session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie,然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的(虽然可以，但是这基本上是属于吃饱没事干的人干的事)…，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie,storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。</p></li><li><p>时效性。session-cookie 的 sessionid 实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而 token 是可以在一段时间内动态改变的。</p></li><li><p>可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT, 二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。</p></li></ol><p>因为 jwt 的 payload 携带了过期时间、用户信息等，所以 JWT 有别于传统 Session 方案的一个最大不同就是 JWT 是无状态的，JWT 不用在内存或 DB 里维持 session 的状态，直接拿到 token 解析就可以了</p><p>下面就拿最常用的 JWT（<strong>JSON WEB TOKEN</strong>）来说：</p><p><strong>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案</strong>，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1617240352266-494610c4-eb86-4a57-86ed-0993c71238d8.png#crop=0&crop=0&crop=1&crop=1&height=455&id=lrDXE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=455&originWidth=699&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=183228&status=done&style=none&title=&width=699" alt="image.png"><br><strong>JWT 对象通常由三部分构成：</strong><br>Headers： 包括类别（typ）、加密算法（alg）<br>   {<br>     “alg”: “HS256”,<br>     “typ”: “JWT”<br>   }</p><p>Playload：包括需要传递的用户信息<br>   {<br>     “sub”: “1234567890”,<br>     “name”: “John Doe”,<br>     “admin”: true<br>   }</p><p>Signature： 根据 alg 算法与私有秘钥进行加密得到的签名字串， 这一段是最重要的敏感信息，只能在服务端解密；<br>HMACSHA256(  <br>   base64UrlEncode(Headers) + “.” +<br>   base64UrlEncode(Claims),<br>   SECREATE_KEY<br>)</p><p><em><strong>编码之后的 JWT 看起来是这样的一串字符：</strong></em><br>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p><p>nodejs+express+jwt-simple</p><p><strong>auth.js</strong><br><code>let jwt = require(&#39;jwt-simple&#39;);</code><br><code>let secret = &quot;wangyy&quot;;</code><br><code>let time = 10;</code><br><code>module.exports = &#123;</code><br><code> /*</code><br><code> *检验token合法性</code><br><code>*/</code><br><code>validate:function(req,res,next)&#123;</code><br><code> let token = req.body.token||req.headers[&quot;xssToken&quot;];</code><br><code> if(token)&#123;</code><br><code> let decodeToken = null;</code><br><code> try &#123; //防止假冒token解析報錯</code><br><code> decodeToken = jwt.decode(token,secret,&#39;HS256&#39;);</code><br><code> &#125; catch (err) &#123;</code><br><code> res.status(401).send(&quot;非法访问&quot;); return;</code><br><code> &#125;</code><br><code> let exp = decodeToken.exp; if(!exp)&#123;</code><br><code> res.status(401).send(&quot;非法访问&quot;);</code><br><code> &#125;</code><br><code> let now = new Date().getTime();</code><br><code> if(exp&gt;(now+time*60*1000))&#123;</code><br><code> res.send(&#123;code:&#39;002&#39;,&quot;errorMsg&quot;:&quot;授权超时&quot;&#125;)</code><br><code> &#125;</code><br><code> next();</code><br><code> &#125;else&#123;</code><br><code> res.status(401).send(&quot;非法访问&quot;);</code><br><code> &#125;</code><br><code> &#125;,</code><br><code> /* 生成token*/</code><br><code> ``**makeToken**``(``)&#123;</code><br><code> let Token = null;</code><br><code> let payload = &#123;</code><br><code> time:new Date().getTime(),</code><br><code> exp:this.makeExp(time)</code><br><code> &#125;</code><br><code> Token = jwt.encode(payload,secret,HS256) return Token;</code><br><code>&#125;,</code><br><code>/*生成token过期时间*/</code><br><code> makeExp:function(time)&#123;</code><br><code> let stam = time601000;</code><br><code> &#125;</code><br><code> &#125;</code></p><p><strong>server.js</strong><br><code>let express = require(&quot;express&quot;); </code><br><code>let app = express(); </code><br><code>let bodyParser = require(&#39;body-parser&#39;); </code><br><code>let auth = require(&#39;./lib/auth.js&#39;); </code><br><code>let chalk = require(&#39;chalk&#39;); app.use(bodyParser.json()); app.post(&#39;/login&#39;,function(req,res,next)&#123; </code><br><code> `` let Token = auth.makeToken();</code><br><code> res.json(&#123;result:&quot;success&quot;,token:Token&#125;,200)</code><br><code> &#125;);</code><br><code>app.use(&#39;*&#39;,[auth.validate],function(req,res,next)&#123; </code><br><code> res.send(&#39;success&#39;);</code><br><code> &#125;);</code><br><code>app.listen(&#39;9999&#39;)</code></p><p>上面只是一个简单的 token 生成和校验，如果有需要可以根据实际需要进行逻辑处理</p><h2 id="四-OAuth-开放授权"><a href="#四-OAuth-开放授权" class="headerlink" title="四. OAuth(开放授权)"></a>四. OAuth(开放授权)</h2><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝，QQ,微信。<br> OAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p><p>下面是一张 auth2.0 的流程图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1617207922357-98ac52a6-e990-4986-ad47-d1706099db44.png#crop=0&crop=0&crop=1&crop=1&height=322&id=ZQ7eI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=625&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=55213&status=done&style=none&title=&width=625" alt="image.png"><br>从图中我们可以看出，auth2.0 流程分为六布（我们就以 csdn 登陆为例）：</p><p><strong>第一步</strong>. 向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1617208008626-6c67f364-18b2-4a40-a0c5-9be9fb900fa1.png#crop=0&crop=0&crop=1&crop=1&height=194&id=a6T3r&margin=%5Bobject%20Object%5D&name=image.png&originHeight=194&originWidth=503&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=26766&status=done&style=none&title=&width=503" alt="image.png"></p><p>通过第三方请求授权页面的浏览器地址栏地址可以看出，</p><p><a href="https://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=100270989&redirect_uri=https%253A%252F%252Fpassport.csdn.net%252Faccount%252Flogin%253Foauth_provider%253DQQProvider&state=test">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&amp;state=test</a></p><p>这里的地址里面的%是浏览器强制编码后的显示,我们可以使用 decodeURIComponent 进行解码，解码后是这样：</p><p><a href="https://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=100270989&redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&state=test">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&amp;state=test</a></p><p>这个 url 地址我们可以看见 Auth2.0 常见的几个参数：</p><ul><li>response_type，返回类型</li><li>client_id，第三方应用 id,由授权服务器（qq）在第三方应用提交时颁发给第三方应用。</li><li>redirect_uri，登陆成功重定向页面</li><li>oauth_provider，第三方授权提供方</li><li>state，由第三方应用给出的随机码</li></ul><p><strong>第二步</strong>. 返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址 redirect_uri 的后面</p><p><a href="https://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&state=XXX">https://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&amp;state=XXX</a></p><p>第 3 步. 请求授权服务器授权:</p><p>经过第二部获取 code 后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来需要获取 Access Token，我们需要用他来向授权服务器获取用户信息等资源。<br>第三方应用后台通过第二步的凭证（code）向授权服务器请求 Access Token，这时候需要以下几个信息：</p><ul><li>client_id 标识第三方应用的 id，由授权服务器（Github）在第三方应用提交时颁发给第三方应用</li><li>client_secret 第三方应用和授权服务器之间的安全凭证，由授权服务器（Github）在第三方应用提交时颁发给第三方应用</li><li>code 第一步中返回的用户凭证 redirect_uri 第一步生成用户凭证后跳转到第二步时的地址</li><li>state 由第三方应用给出的随机码</li></ul><p>第四步. 授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。</p><p>第五步. 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。</p><p>第六步. 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。</p><p>从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册,同时不用记住各种账号密码。只需要记住自己常用的几个账号就 ok 了。<br>从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>授权方式多种多样，主要还是要取决于我们对于产品的定位。如果我们的产品只是在企业内部使用，token 和 session 就可以满足我们的需求，如果是面向互联网的大众用户，那么第三方授权在用户体验度上会有一个很大的提升</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对象存储服务-Minio</title>
      <link href="2021/03/25/yuque/oc2pz7/"/>
      <url>2021/03/25/yuque/oc2pz7/</url>
      
        <content type="html"><![CDATA[<p><strong>对象存储服务（Object Storage Service，OSS</strong>）是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多种存储类型供选择，全面优化存储成本。</p><h1 id="对象存储服务"><a href="#对象存储服务" class="headerlink" title="对象存储服务"></a>对象存储服务</h1><p>在项目开发过程中，我们会产生大量的对象数据，包括：日志文件，数据库脚本文件、安装包，容器镜像，图像、视频等等，我们不仅仅是需要有一个集中的地方来存储，还需要能基于 Web 的方式来访问它们，以往我们有以下几种方法来解决：</p><ul><li>阿里云、Azure 等云服务商提供的 SaaS 级别的 OSS 服务</li><li>自己搭建 NAS 网络存储通过 Samba 服务来访问</li><li>自己搭建 FTP 服务器来存储</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616687824999-55666588-2d09-46e9-bcfb-6de25befec39.png#align=left&display=inline&height=320&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=626&size=91754&status=done&style=none&width=626" alt="image.png"></p><p>本篇文章主要介绍下其中的 Minio 方案</p><h1 id="Minio"><a href="#Minio" class="headerlink" title="Minio"></a>Minio</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/5374140/1616841442916-a0aebceb-8506-441f-bc1b-2aa4b6e81318.jpeg#align=left&display=inline&height=128&margin=%5Bobject%20Object%5D&originHeight=400&originWidth=1200&size=0&status=done&style=none&width=385"><br>Minio 是 GlusterFS 创始人之一 Anand Babu Periasamy 发布新的开源项目。Minio 兼容 Amason 的 S3 分布式对象存储项目，采用 Golang 实现，客户端支持 Java,Python,Javacript, Golang 语言。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/svg/5374140/1616850954773-f56d6dad-f09f-48a2-8d68-698ab4f01d68.svg#align=left&display=inline&height=122&margin=%5Bobject%20Object%5D&originHeight=186&originWidth=800&size=0&status=done&style=none&width=524"></p><p>Minio 是建立在云原生的基础上；有分布式和共享存储等功能；旨在多租户环境中以可持续的方式进行扩展的对象存储服务。它最适合存储非结构化数据，如：照片、视频、日志文件、容器/虚拟机/映像等，单次存储对象的大小最大可达 5TB</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://min.io/">https://min.io/</a></li><li><a href="http://www.minio.org.cn/">http://www.minio.org.cn/</a></li><li><a href="https://github.com/minio/minio-service">minio/minio-service: Collection of MinIO server scripts for upstart, systemd, sysvinit, launchd. (github.com)</a></li></ul><h2 id="Minio-架构"><a href="#Minio-架构" class="headerlink" title="Minio 架构"></a>Minio 架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616687945743-43cf8f65-e12b-427d-85f5-22e731990a65.png#align=left&display=inline&height=452&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=740&size=137885&status=done&style=none&width=740" alt="image.png"></p><p><strong>左边是 MINIO 集群的示意图</strong>，整个集群是由多个角色完全相同的节点所组成的。因为没有特殊的节点，所以任何节点宕机都不会影响整个集群节点之间的通信。通过 rest 跟 RPC 去通信的，主要是实现分布式的锁跟文件的一些操作</p><p><strong>右边这张图是单个节点的示意图</strong>，每个节点都单独对外提供兼容 S3 的服务</p><h2 id="为什么要用-Minio"><a href="#为什么要用-Minio" class="headerlink" title="为什么要用 Minio"></a>为什么要用 Minio</h2><ul><li>1、Minio 有良好的存储机制</li><li>2、Minio 有很好纠删码的算法与擦除编码算法</li><li>3、拥有 RS code 编码数据恢复原理</li><li>4、公司做强做大时，数据的拥有重要性，对数据治理与大数据分析做准备。</li><li>5、搭建自己的一套文件系统服务,对文件数据进行安全保护。</li><li>6、拥有自己的平台，不限于其他方限制。</li></ul><p>###</p><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><ul><li>Minio 使用纠删码 erasure code 和校验和 checksum 来保护数据免受硬件故障和无声数据损坏。 即便丢失一半数量（N/2）的硬盘，仍然可以恢复数据。</li></ul><p>**</p><h3 id="纠删码"><a href="#纠删码" class="headerlink" title="纠删码"></a>纠删码</h3><ul><li>纠删码是一种恢复丢失和损坏数据的数学算法，目前，纠删码技术在分布式存储系统中的应用主要有三类，阵列纠删码（Array Code: RAID5、RAID6 等）、RS(Reed-Solomon)里德-所罗门类纠删码和 LDPC(LowDensity Parity Check Code)低密度奇偶校验纠删码。Erasure Code 是一种编码技术，它可以将 n 份原始数据，增加 m 份数据，并能通过 n+m 份中的任意 n 份数据，还原为原始数据。即如果有任意小于等于 m 份的数据失效，仍然能通过剩下的数据还原出来</li></ul><h2 id="MinIO-概念"><a href="#MinIO-概念" class="headerlink" title="MinIO 概念"></a>MinIO 概念</h2><p>如下图，<strong>每一行是一个机器节点</strong>，这里有 32 个集群，<strong>每个节点里有一个小方块，我们称之为 Drive，Drive 可简单地理解为磁盘</strong>。一个节点有 32 个 Drive，相当于 32 个磁盘。</p><p><strong>Set 是一组 Drive 的集合</strong>，所有红色标识的 Drive 组成了一个 Set。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616688028544-2d4661ff-7d44-427e-a7b2-4e98922fbaec.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=299&size=58821&status=done&style=none&width=299" alt="image.png"><br>一个对象存储在一个 Set 上; 一个集群划分为多个 Set<br>一个 Set 包含的 Drive 数量是固定的, 默认由系统根据集群规模自动计算得出 MINIO_ERASURE_SET_DRIVE_COUNT<br>一个 SET 中的 Drive 尽可能分布在不同的节点上</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>Minio 提供了两种部署方式：单机部署和分布式，两种部署方式都非常简单，其中分布式部署还提供了纠删码功能来降低数据丢失的风险</p><h3 id="单机部署："><a href="#单机部署：" class="headerlink" title="单机部署："></a>单机部署：</h3><p><code>wget </code><a href="https://dl.min.io/server/minio/release/linux-amd64/minio"><code>https://dl.min.io/server/minio/release/linux-amd64/minio</code></a><code> chmod +x minio ./minio server /data`` #``若``/data``目录不存在，要新建一个</code></p><h3 id="Docker-部署-Minio"><a href="#Docker-部署-Minio" class="headerlink" title="Docker 部署 Minio"></a>Docker 部署 Minio</h3><p><code>mkdir /data/minio-data&amp;&amp;mkdir /data/minio-config # 创建一个数据存储目录</code><br><code>docker run -p 9000:9000 --name minio \</code><br><code>-d --restart=always \</code><br><code>-e &quot;MINIO_ACCESS_KEY=admin&quot; \</code><br><code>-e &quot;MINIO_SECRET_KEY=admin123456&quot; \</code><br><code>-v /``data``/``minio-``data:/data \</code><br><code>-v /``d``ata``/``minio-``config:/root/.minio \</code><br><code>minio/minio server /data</code></p><p><a href="http://localhost:9000/">http://localhost:9000/</a> 即可登陆 Minio 的管理界面</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616688607585-b362ae32-41e7-40b0-a653-391015b514c3.png#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=1303&size=22817&status=done&style=none&width=1303" alt="image.png"></p><p>##</p><h2 id="分布式-Minio"><a href="#分布式-Minio" class="headerlink" title="分布式 Minio"></a>分布式 Minio</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616688683921-36c53272-58fe-43e1-98ef-060e091fdac2.png#align=left&display=inline&height=557&margin=%5Bobject%20Object%5D&name=image.png&originHeight=557&originWidth=1008&size=135743&status=done&style=none&width=1008" alt="image.png"><br>单机 Minio 服务存在单点故障，相反，如果是一个有 m 台服务器， n 块硬盘的分布式 Minio,只要有 m/2 台服务器或者 m*n/2 及更多硬盘在线，你的数据就是安全的。</p><p>例如，一个 16 节点的 Minio 集群，每个节点 200 块硬盘，就算 8 台服務器宕机，即大概有 1600 块硬盘，这个集群仍然是可读的，不过你需要 9 台服務器在线才能写数据。<br><code>export MINIO_ACCESS_KEY=&lt;ACCESS_KEY&gt;</code><br><code>export MINIO_SECRET_KEY=&lt;SECRET_KEY&gt;</code><br><code>minio server </code><a href="http://host/"><code>http://host</code></a><code>&#123;1...n&#125;/export&#123;1...m&#125; </code><a href="http://host/"><code>http://host</code></a><code>&#123;1...o&#125;/export&#123;1...m&#125;</code></p><p>当然如果我们只有一台机器，但是想用纠删码的功能，也可以直接配置使用多个本地盘<br><code>minio server /data1 /data2 /data3 ... /data8</code></p><p>##</p><h2 id="Minio-配置"><a href="#Minio-配置" class="headerlink" title="Minio 配置"></a>Minio 配置</h2><p>默认的配置目录是  ${HOME}/.minio，你可以使用–config-dir 命令行选项重写之。MinIO server 在首次启动时会生成一个新的 config.json，里面带有自动生成的访问凭据。<br><code>minio server --config-dir /etc/minio /data</code></p><ul><li><strong>证书目录</strong></li></ul><p>TLS 证书存在${HOME}/.minio/certs 目录下，你需要将证书放在该目录下来启用 HTTPS</p><ul><li><strong>凭据</strong></li></ul><p>只能通过环境变量 MINIO_ROOT_USER  和  MINIO_ROOT_PASSWORD  更改 MinIO 的 admin 凭据和 root 凭据。使用这两个值的组合，MinIO 加密存储在后端的配置</p><p><code>export MINIO_ROOT_USER=minio</code><br><code>export MINIO_ROOT_PASSWORD=minio13</code><br><code>minio server /data</code></p><h2 id="如何存储和访问对象"><a href="#如何存储和访问对象" class="headerlink" title="如何存储和访问对象"></a>如何存储和访问对象</h2><p>将对象数据存储到 Minio 中有以下几种方式：<br>• 通过  MINIO CLIENT<br>• 通过  MINIO SDK  目前支持的语言包括：Go，Java，Node.js，Python，.NET<br>• 通过浏览器访问 Web 管理界面，在管理界面中上传和下载对象<br>• 如果你有存储目录  minio-data  的账号和访问权限，可以直接使用 SCP 命令将数据写入磁盘</p><h3 id="MinIO-Client-mc"><a href="#MinIO-Client-mc" class="headerlink" title="MinIO Client (mc)"></a>MinIO Client (mc)</h3><p><code>wget </code><a href="https://dl.min.io/client/mc/release/linux-amd64/mc"><code>https://dl.min.io/client/mc/release/linux-amd64/mc</code></a><br><code>chmod +x mc</code></p><p>MinIO Client (mc)为 ls，cat，cp，mirror，diff，find 等 UNIX 命令提供了一种替代方案。它支持文件系统和兼容 Amazon S3 的云存储服务（AWS Signature v2 和 v4）。</p><h4 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h4><p><code>ls ``列出文件和文件夹。`` mb ``创建一个存储桶或一个文件夹。`` cat ``显示文件和对象内容。`` pipe ``将一个``STDIN``重定向到一个对象或者文件或者``STDOUT``。`` share ``生成用于共享的``URL``。`` cp ``拷贝文件和对象。`` mirror ``给存储桶和文件夹做镜像。`` find ``基于参数查找文件。`` diff ``对两个文件夹或者存储桶比较差异。`` rm ``删除文件和对象。`` events ``管理对象通知。`` watch ``监听文件和对象的事件。`` policy ``管理访问策略。`` session ``为``cp``命令管理保存的会话。`` config ``管理``mc``配置文件。`` update ``检查软件更新。`` version ``输出版本信息。</code></p><p>##</p><p><strong>列出 Mino 服务端</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616840462896-f6c5a2bd-562c-49c9-8d95-bc3f530ae95c.png#align=left&display=inline&height=379&margin=%5Bobject%20Object%5D&name=image.png&originHeight=379&originWidth=493&size=37287&status=done&style=none&width=493" alt="image.png"><br><strong>命令行创建 bucket</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616840502464-6155acbc-4744-4434-9a62-5ee3a346eeb5.png#align=left&display=inline&height=166&margin=%5Bobject%20Object%5D&name=image.png&originHeight=166&originWidth=477&size=26220&status=done&style=none&width=477" alt="image.png"></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616840510944-6e6085fd-2253-49bd-ac92-2cf932de3949.png#align=left&display=inline&height=414&margin=%5Bobject%20Object%5D&name=image.png&originHeight=414&originWidth=607&size=32039&status=done&style=none&width=607" alt="image.png"></h3><h3 id="通过代码存储对象"><a href="#通过代码存储对象" class="headerlink" title="通过代码存储对象"></a>通过代码存储对象</h3><p><code>// ``构造访问对象`` var minio = new MinioClient(&quot;localhost:9000&quot;,&quot;accessKey&quot;,&quot;secretKey&quot;);</code><br><code>// ``输出所有的`` Buckets `` var rs = minio.ListBucketsAsync(); foreach (varbucket in rs.Result.Buckets) &#123; Console.Out.WriteLine(bucket.Name + &quot; &quot; + bucket.CreationDateDateTime); &#125;</code><br><code>// ``存储对象`` var bucketName = &quot;logs&quot;; var objectName = &quot;logs.zip&quot;; var filePath = &quot;c:\\logs.zip&quot;; var contentType = &quot;application/zip&quot;; minio.PutObjectAsync(bucketName, objectName, filePath, contentType);</code><br><code>// ``获取对象`` var find = minio.GetObjectAsync(bucketName, objectName);</code></p><p>##</p><p>##</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“if __name__==&#39;__main__&#39;:”</title>
      <link href="2021/03/19/yuque/sehau1/"/>
      <url>2021/03/19/yuque/sehau1/</url>
      
        <content type="html"><![CDATA[<p>已剪辑自:<a href="https://www.cnblogs.com/chenhuabin/p/10118199.html">https://www.cnblogs.com/chenhuabin/p/10118199.html</a></p><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>在 Python 当中，如果代码写得规范一些，通常会写上一句“if <strong>name</strong>==’<strong>main</strong>:”作为程序的入口，但似乎没有这么一句代码，程序也能正常运行。这句代码多余吗？原理又在哪里？本篇博文对此进行总结说明。</p><h1 id="2-程序入口"><a href="#2-程序入口" class="headerlink" title="2 程序入口"></a>2 程序入口</h1><p>学过 Java、C、C++的程序员应该都知道，每次开启一个程序，都必须写一个主函数作为程序的入口，也就是我们常说的 main 函数。如下所示， main()就是 Java 中的一个 main 函数。<br><code>public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;HelloWorld&quot;); &#125; &#125;</code></p><p>与 Java、C、C++等几种语言不同的是，Python 是一种解释型脚本语言，在执行之前不同要将所有代码先编译成中间代码，Python 程序运行时是从模块顶行开始，逐行进行翻译执行，所以，最顶层（没有被缩进）的代码都会被执行，所以 Python 中并不需要一个统一的 main()作为程序的入口。</p><p>在某种意义上讲，“if <strong>name</strong>==’<strong>main</strong>:”也像是一个标志，象征着 Java 等语言中的程序主入口，告诉其他程序员，代码入口在此——这是“if <strong>name</strong>==’<strong>main</strong>:”这条代码的意义之一。</p><h1 id="3-模块导入"><a href="#3-模块导入" class="headerlink" title="3 模块导入"></a>3 模块导入</h1><p>我们知道，当我们把模块 A 中的代码在模块 B 中进行 import A 时，只要 B 模块代码运行到该 import 语句，模块 A 的代码会被执行。<br><code># ``模块``B ``from package01 import A b = 200 print(&#39;``你好，我是模块``B……&#39;) print(b) </code><br><code> 运行模块B时，输出结果如下：</code><br><code> 你好，我是模块A……</code><br><code> 100</code><br><code> 你好，我是模块B……</code><br><code> 200</code></p><p>如果在模块 A 中，我们有部分的代码不想在被导入到 B 时直接被运行，但在直接运行 A 时可直接运行，那该怎么做呢？那就可以用到“if <strong>name</strong>==’<strong>main</strong>:”这行代码了，我们队上面用到的 A 模块代码进行修改：</p><p>A 模块代码修改为：<br><code># ``模块``A a = 100 print(&#39;``你好，我是模块``A……&#39;) if __name__==&#39;__main__&#39;:</code><br><code>print(a)</code></p><p><code> B模块不做修改，直接执行B模块，输出结果如下：</code><br><code> 你好，我是模块A……</code><br><code> 你好，我是模块B……</code><br><code> 200</code><br>看到了吗，A 模块中的 a 的值就没有再被输出了。所以，当你要导入某个模块，但又不想改模块的部分代码被直接执行，那就可以这一部分代码放在“if <strong>name</strong>==’<strong>main</strong>‘:”内部。</p><p>#</p><h1 id="4-“name”与“main”"><a href="#4-“name”与“main”" class="headerlink" title="4 “name”与“main”"></a>4 “<strong>name</strong>”与“<strong>main</strong>”</h1><p>看到现在也许心中还是疑惑，为什么会这样，那么现在我们来说一说“if <strong>name</strong>==’<strong>main</strong>‘:”的原理。<br>** **<strong>“*</strong>*<strong>name</strong>**<strong>”*</strong>*是**<strong>Python*</strong>*的内置变量，用于指代当前模块**。我们修改上面用到的 A 模块和 B 模块，在模块中分别输出模块的名称：</p><p><code># ``模块``A print(&#39;``你好，我是模块``A……&#39;) print(&#39;``模块``A``中``__name__``的值：``&#123;&#125;&#39;.format(__name__)) print(&#39;-------------------------&#39;) </code></p><p><code># ``模块``B from package01 import A print(&#39;``你好，我是模块``B……&#39;) print(&#39;``模块``B``中``__name__``的值：``&#123;&#125;&#39;.format(__name__)) </code></p><p><code>执行``A``模块时，输出结果：</code><br><code> 你好，我是模块``A……</code><br><code> 模块``A``中``__name__``的值：``__main__</code><br><code> ``-------------------------</code><br><code> 执行``B``模块时，输出结果：</code><br><code> 你好，我是模块``A……</code><br><code> 模块``A``中``__name__``的值：``package01.A</code><br><code> ``-------------------------</code><br><code> 你好，我是模块``B……</code><br><code> 模块``B``中``__name__``的值：``__main__</code></p><p>发现神奇之处了吗？当哪个模块被直接执行时，该模块“<strong>name</strong>”的值就是“<strong>main</strong>”，当被导入另一模块时，“<strong>name</strong>”的值就是模块的真实名称。</p><p>用一个类比来解释一下：记得小时候要轮流打算教室，轮到自己的时候（模块被直接执行的时候），我们会说今天是“我”（<strong>main</strong>）值日，称呼其他人时，我们就会直接喊他们的名字。所以，“<strong>main</strong>”就相当于当事人，或者说第一人称的“我”。</p><p>所以，当运行“if <strong>name</strong>==’<strong>main</strong>‘:”语句时，如果当前模块时被直接执行，<strong>name</strong>的值就是<strong>main</strong>，条件判断的结果为 True，“if <strong>name</strong>==’<strong>main</strong>‘:”下面的代码块就会被执行。</p><p>#</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>“if <strong>name</strong>==’<strong>main</strong>‘:”语句的用处与原理大概也讲清楚了，如果没说明白，或者是我没理解到位，请给我留言。另外多说一句，“if <strong>name</strong>==’<strong>main</strong>‘:”很多时候看似无用，但是，出于代码的规范性，还是有必要的。</p><p>‘<strong>main</strong>’ is the name of the scope in which top-level code executes. A module’s <strong>name</strong> is set equal to ‘<strong>main</strong>’ when read from standard input, a script, or from an interactive prompt.<br>A module can discover whether or not it is running in the main scope by checking its own <strong>name</strong>, which allows a common idiom for conditionally executing code in a module when it is run as a script or with python -m but not when it is imported:</p><p><strong>main</strong>就是最顶级代码的名字，而<strong>name</strong>是代码本身的名字。<br><strong>通过判断二者是否相等，可以判断该代码是被 imported 还是直接执行的。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DevOps-让我们从CI/CD开始吧~</title>
      <link href="2021/03/15/yuque/ll50ub/"/>
      <url>2021/03/15/yuque/ll50ub/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><p>对于一个准备开始 DevOps 实践的团队，从哪里出发呢？根据我的实践经验，可以先从 CI/CD 开始，一步步过渡，从一个项目开始，慢慢覆盖到更多的项目</p></blockquote></blockquote><p>我从各个阶段列出了实践之前需要考虑的点，仅供参考：</p><p>##</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615820506977-9182b557-4ee4-4bd6-8b5d-661639513bc5.png#crop=0&crop=0&crop=1&crop=1&height=196&id=Q0RIv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=690&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=190909&status=done&style=none&title=&width=394" alt="image.png"></h2><h2 id="1-代码管理-分支策略"><a href="#1-代码管理-分支策略" class="headerlink" title="1. 代码管理/分支策略"></a>1. 代码管理/分支策略</h2><ul><li>代码托管在哪里？</li><li>使用 git or svn?</li><li>分支策略/分支模型？</li><li>CI 服务可以访问您的代码库吗？</li><li>代码结构如何？需要一个库，还是多个库？</li><li>版本号定义？</li><li>依赖管理？命名规则？</li><li>Code Review ?</li></ul><h2 id="2-持续集成服务器"><a href="#2-持续集成服务器" class="headerlink" title="2. 持续集成服务器"></a>2. 持续集成服务器</h2><ul><li>选好你需要的 CI server 了吗？ jenkins, Teamcity,GoCD or AuzreDevOps</li><li>CI Server 使用的学习</li><li>CI Server 如何部署，需要多少资源，需要多少并发 job ?</li><li>Pipeline 编写，如何标准化？是否需要参数化？</li><li>与代码仓库，制品库集成？</li><li>静态代码检查？SonarQube</li><li>多分支/多个仓库，相互依赖？</li></ul><h2 id="3-制品库"><a href="#3-制品库" class="headerlink" title="3. 制品库"></a>3. 制品库</h2><ul><li>选择合适的制品库服务器 (jar, npm, nuget, docker or other package ?)</li><li>制品的版本？ 如何与 code commit id 关联？</li><li>制品库保存策略/tag 管理</li></ul><h2 id="4-测试类型"><a href="#4-测试类型" class="headerlink" title="4. 测试类型"></a>4. 测试类型</h2><p>CI 阶段除了保证代码没有冲突，编译通过之外，最重要的就是测试 。每次代码变更后，我们需要自动运行测试用例。<br>在初始阶段并不需要实现所有的测试类型。一开始可以以单元测试入手，随着时间扩展覆盖面。</p><ul><li>单元测试：范围非常小，验证每个独立方法级别的操作。</li><li>集成测试：保证模块间运行正常，包括多个模块、多个服务。</li><li>验收测试：与集成测试类似，但是仅关注业务 case，而不是模块内部本身。</li><li>UI 测试：从用户的角度保证呈现正确运行。</li></ul><p>并不是所有的测试都是对等的，实际运行中可以做些取舍。</p><h3 id="4-级测试规划"><a href="#4-级测试规划" class="headerlink" title="4 级测试规划"></a>4 级测试规划</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/5374140/1615820356472-8b8bc641-bace-4ede-be6d-01c75bcfdd89.webp#crop=0&crop=0&crop=1&crop=1&height=334&id=PmUoo&originHeight=400&originWidth=1022&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=853"></p><ul><li>单元测试实现起来既快成本又低，因为它们主要是对小代码块进行检查。</li><li>UI 测试实施起来很复杂，运行起来很慢，因为它通常需要启动一个完整的环境以及多个服务来模拟浏览器或移动行为。实际情况可能希望限制复杂的 UI 测试的数量，并依赖基础上良好的单元测试来快速构建，并尽快获得开发人员的反馈。</li><li>单元测试前期投入少，短期内可以看到效果，对开发人员要求高；UI 测试前期人员成本投入大，需要很长时间看到效果</li></ul><h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><ul><li>使用代码覆盖率查找未测试的代码。一旦您采用了自动化测试，最好将它与一个测试覆盖工具结合起来，帮助了解测试套件覆盖了多少代码库。代码覆盖率定在 80%以上是很好的，但要注意不要将高覆盖率与良好的测试套件混淆。代码覆盖工具将帮助您找到未经测试的代码，但在一天结束的时候，测试的质量会产生影响。如果刚开始，不要急于获得代码库的 100%覆盖率，而是使用测试覆盖率工具来找出应用程序的关键部分，这些部分还没有测试并从那里开始。</li><li>重构是一个添加测试的机会。如果您将要对应用程序进行重大更改，那么应该首先围绕可能受到影响的特性编写验收测试。这将为您提供一个安全网，以确保在重构代码或添加新功能后，原始行为不会受到影响。</li></ul><h2 id="5-测试-部署环境准备"><a href="#5-测试-部署环境准备" class="headerlink" title="5. 测试/部署环境准备"></a>5. 测试/部署环境准备</h2><ul><li>测试需要多少资源 ？</li><li>编写自动化部署脚本？ python,shell, powershell, or ansible ?</li><li>多环境/多分支 配置？</li></ul><h2 id="6-团队-CI-文化"><a href="#6-团队-CI-文化" class="headerlink" title="6. 团队 CI 文化"></a>6. 团队 CI 文化</h2><ul><li>当团队实践 CI 时，需要了解分支模型，按照定义的 commit 策略，进行频繁提交</li><li>提交冲突了，如何处理？</li><li>怎么反馈冲突 或者 build break ? 谁处理？</li><li>推广普及 CI 文化<ol><li>尽早集成。如果很长时间不合并代码，代码冲突的风险就越高，代码冲突的范围就越广。如果发现某些分支会影响已经存在的分支，需要增加发布关闭标签，避免发布时两个分支冲突。</li><li>保证编译时时刻刻畅通。一旦发现任何编译问题，立刻修复，否则可能会带来更多的错误。测试套件需要尽快反馈测试结果，或者优先返回短时间测试（单元测试）的结果，否则开发者可能就切换回开发了。一旦编译出错，需要通知给开发者，或者更进一步给出一个 dashboard，每个人都可以在这里查看编译结果。</li><li>把测试用例纳入流程的一部分。确保每个分支都有自动化测试用例。似乎编写测试用例拖慢了项目节奏，但是它可以减少回归时间，减少每次迭代带来的 bug。而且每次测试通过后，将会非常有信息合并到主干分支，因为新增的内容不影响以前的功能。</li><li>修 bug 的时候编写测试用例。把 bug 的每个场景都编写成测试用例，避免再次出现。</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云原生</title>
      <link href="2021/03/13/yuque/vog4m0/"/>
      <url>2021/03/13/yuque/vog4m0/</url>
      
        <content type="html"><![CDATA[<p>IBM 认为云计算有三大优势：</p><ol><li><strong>更灵活</strong>。用户可以根据需要，“弹性地”获得 IT 服务。</li><li><strong>更高效</strong>。减少 IT 团队管理和维护底层基础设施的工作量，IT 服务可以更快推向市场。</li><li><strong>战略价值</strong>。通过灵活组合现有 IT 资产与新兴数字渠道，支撑企业业务创新。</li></ol><h2 id="云计算与虚拟化的区别"><a href="#云计算与虚拟化的区别" class="headerlink" title="云计算与虚拟化的区别"></a>云计算与虚拟化的区别</h2><p>有很多企业已经采用了虚拟化技术：将企业的计算资源（服务器、存储等）集中管理，以虚拟机的形式分配给使用者。虚拟化与云计算的区别在于：虚拟化是指“用软件管理硬件资源”，而云计算是指以虚拟化方式管理硬件资源之后能够对外提供的服务。</p><p>除去这个概念上的差异，我们注意到一些企业在谈论“虚拟化”的时候，背后隐含着一个自动化程度不高的、需要人工参与的虚拟机申请和开通的流程。在这样的流程下，获得一台虚拟主机需要的时间通常以天计。因此，虚拟机的使用者倾向于预先申请虚拟主机并长期占用。在这种情况下，“虚拟化”往往意味着缺乏弹性（elasticity）的计算资源分配——尽管虚拟化技术本身并不妨碍弹性。</p><p>为了兑现云计算的三大优势，<strong>企业 IT 系统必须云化</strong>：软件的<strong>形态由从前需要在本地安装的软件包，转变为透过网络在线使用的服务</strong>，让使用者随时能够获得；<strong>原来体型巨大的单体（monolithic）应用，需要转变为细粒度的服务</strong>，从而支持灵活的组合与复用。</p><h2 id="云时代的研发环境"><a href="#云时代的研发环境" class="headerlink" title="云时代的研发环境"></a>云时代的研发环境</h2><p><strong>原来习惯了开发本地安装的软件包和/或巨大的单体应用的研发团队，现在要转为开发云化的软件服务</strong>，这个转变并非总是无痛的。首先，研发交付物的形态应该是对云环境友好的。从前研发交付物通常是以软件包的形式提供给用户或是运维团队，例如平台特定的 JAR、WAR、EGG 等软件包，或是 RPM、DEB、MSI 等操作系统特定的软件包。软件包是一种对云环境不友好的交付形式，因为它没有包含软件运行的环境。例如一个软件需要用到 PostgreSQL 数据库和 monit 作为监控工具，平台特定的软件包无法确保这些软件依赖的存在；某些操作系统特定的软件包可以描述软件依赖，但也无法确保依赖软件被正确地配置。过去一段时间里，自动化的配置工具（例如 Chef/Puppet/Ansible）被用于解决运行时环境的问题。而在今天的技术背景下，理想的研发交付物应该是容器镜像（很可能是一组彼此连接的容器镜像），可以在云上直接运行。</p><p>对研发交付物的要求随即会影响到研发过程。<strong>为了在研发流程的出口得到服务化友好的交付物，最好是在整个开发过程中一直使用与生产环境近似的环境。</strong>例如开发人员应该使用全套环境随时验证，自动化测试和手工测试都基于全套环境开展。在这种情况下，环境的设置、管理、更新不可能由每个开发人员和测试人员自己进行，所以环境的管理更新必定是集中进行的，环境的设置必定是自动化的。而且，如果环境固定分配、长期使用，对计算资源的占用可能很大，所以环境应该是云化的、弹性的、按需获得的。</p><p><strong>云计算的大背景还会影响研发实践。</strong>为了降低搭建研发环境的技术难度，云化的研发环境应该内建研发工具链（包含开发工具、质量保障工具、持续集成/持续交付工具、DevOps 工具、项目管理工具等）。为了规范团队研发质量水平，良好的研发实践（例如代码静态检查、自动化测试等）和流程要求应该固化在工具的日常操作中。理想的情况下，研发团队应该只聚焦关注业务功能开发。开发工具的组合、生产环境的配置、持续集成和持续交付流水线的搭建等工作都应该被标准化和自动化。</p><p>综上所述，<strong>在云计算的大背景下，IT 组织需要将更多的软件应用部署在云上。</strong>云化的 IT 系统对软件研发的交付物、研发过程、研发实践都提出了新的要求。我们认为：现代 IT 组织应该从研发环节开始，以原生支持云计算的方式提供、管理和维护研发环境，从而在研发过程中利用云环境的弹性，确保研发交付物对云环境友好，并把优秀的研发实践和流程要求内嵌到研发环境之中。</p><p>IT 组织可以通过以下方式管理其研发环境：</p><ul><li>将标准的研发环境封装为虚拟化、云化的技术栈，由技术专家管理维护；</li><li>核心业务价值与技术支撑解耦，工程师专注于业务系统的开发；</li><li>自动化研发流程，降低研发管理成本。</li></ul><hr><p>假设你有 100 台物理机，其实规模不是太大，用 Excel 人工管理是没问题的，但是一台上面开 10 台虚拟机，虚拟机的个数就是 1000 台，人工管理已经很困难了，但是一台虚拟机里面开 10 个容器，就是 10000 个容器，你是不是已经彻底放弃人工运维的想法了。所以容器层面的管理平台是一个新的挑战，关键字就是自动化</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615620829686-9b52407a-61f6-4c31-9c90-b293dcf5736a.png#crop=0&crop=0&crop=1&crop=1&height=199&id=QXLWa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=193&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=50238&status=done&style=none&title=&width=193" alt="image.png"></p><ul><li><p>自发现：容器与容器之间的相互配置还能像虚拟机一样，记住 IP 地址然后互相配置吗？这么多容器，一旦一台虚拟机挂了重启，IP 改变，你怎么记得住应该改哪些配置，列表长度至少万行级别的啊。所以容器之间的配置通过名称来的，无论容器跑到哪台机器上，名称不变，就能访问到。</p></li><li><p>自修复：容器挂了，或是进程宕机了，能像虚拟机那样登陆上去查看一下进程状态，如果不正常可以重启一下么？那你要登陆万台 docker 了。所以容器的进程挂了，容器就自动挂掉了，然后自动重启。</p></li><li><p>弹性自伸缩 Auto Scaling：当容器的性能不足的时候，需要手动伸缩、手动部署么？当然也要自动来。</p></li></ul><p>一个是 <strong>Kubernetes</strong>，我们称为段誉型。<br>段誉(Kubernetes)的父亲 (Borg)武功高强，出身皇族 (Google)，管理过偌大的一个大理国 (Borg 是 Google 数据中心的容器管理平台)。作为大理段式后裔，段誉的武功基因良好 (Kubernetes 的理念设计比较完善)，周围的高手云集，习武环境也好 (Kubernetes 生态活跃，热度高)，虽然刚刚出道的段誉武功不及其父亲，但是只要跟着周围的高手不断切磋，武功即可飞速提升。</p><p>一个是 <strong>Mesos</strong>，我们称为乔峰型。乔峰 (Mesos)的主要功夫降龙十八掌 (Mesos 的调度功能)独步武林，为其他帮派所无。而且乔峰也管理过人数众多的丐帮 (Mesos 管理过 Tweeter 的容器集群)。后来乔峰从丐帮出来，在江湖中特例独行 (Mesos 的创始人成立了公司 Mesosphere)。乔峰的优势在于，乔峰的降龙十八掌 (Mesos)就是在丐帮中使用的降龙十八掌，相比于段誉初学其父的武功来说，要成熟很多。但是缺点是，降龙十八掌只掌握在少数的几个丐帮帮主手中 (Mesos 社区还是以 Mesosphere 为主导)，其他丐帮兄弟只能远远崇拜乔峰，而无法相互切磋(社区热度不足)。</p><p>一个是 <strong>Swarm</strong>，我们称为慕容型。慕容家族(Swarm 是 Docker 家族的集群管理软件)的个人功夫是非常棒的 (Docker 可以说称为容器的事实标准)，但是看到段誉和乔峰能够管理的组织规模越来越大，有一统江湖的趋势，着实眼红了，于是开始想创建自己的慕容鲜卑帝国(推出 Swarm 容器集群管理软件)。但是个人功夫好，并不代表着组织能力强 (Swarm 的集群管理能力)，好在慕容家族可以借鉴段誉和乔峰的组织管理经验，学习各家公司，以彼之道，还施彼身，使得慕容公子的组织能力 (Swarm 借鉴了很多前面的集群管理思想)也在逐渐的成熟中。</p><p>容器能够把服务打包成基本单元，你可以把它部署到任何地方：本地机器、测试环境或者生产系统。但是在生产环境中，你却不能把所有容器都运行在一台机器上，因为会用光系统的资源。你需要多个机器（或者节点）以集群（不同机器通过网络通信）的方式运行，然后把容器部署到集群中。现在问题变成，如果我有多个机器/节点组成的集群，我该如何决定容器运行在哪台机器上呢？有了编排软件，你只需要告诉它我要部署容器，剩下的事情交给编排软件即可。<br><strong>编排软件负责以下几点：</strong></p><ul><li>选择最适合部署容器的机器。最适合指的是拥有最多空闲资源，或者说如果容器能获得更多的运行内存，比如 Redis。</li><li>发生机器故障，能自动把故障机器上的容器部署到其它节点。</li><li>如果集群添加了新的机器，重新平衡容器的分配情况。</li><li>如果容器故障了，重启它。</li><li>……</li></ul><p>现在你已经理解为什么需要容器编排了，下面我们一起看下当下最流行的两个选择以及它们间的对比。</p><p><strong>Docker Swarm</strong><br>Swarm 是为 Docker 开发原生的集群管理引擎。任何适配 Docker container 的工具、服务或软件都可以很好地兼容 Swarm。下面是一些 Docker Swarm 的优缺点：<br><strong>优点</strong></p><ul><li>容易上手，“开箱即用”的用户体验。</li><li>零“单点故障”（single-point-of-failure）架构。</li><li>自动生成证书，默认提供安全机制。</li><li>向后兼容组件。</li><li>开源</li></ul><p><strong>缺点</strong></p><ul><li>处于项目启动/早期开发阶段。我们不推荐商业应用上使用。随着时间推移，它会更加成熟。</li><li>功能简单有限。</li></ul><p><strong>Kubernetes</strong><br>Kubernetes 是一个 Google 主导的生产就绪、企业级、成熟的编排平台。它的利弊有<br><strong>优点</strong></p><ul><li>生产就绪、企业级。它被很多公司用于规模生产环境。</li><li>相比 Docker Swarm，它更成熟。</li><li>可用于公有云、私有云、混合云等多种云环境。</li></ul><p>模块化。</p><ul><li>自愈能力：自动布局、自动重启、自动备份、自动伸缩。</li><li>开源。</li><li>因为模块化设计，可被用于部署任何架构。</li></ul><p><strong>缺点</strong></p><ul><li>难于部署。如果不使用云服务商 Azure、Google 或者 Amazon，在你的集群中搭建 Kubernetes 环境非常困难。大部分云服务商都提供了一键安装功能。</li><li>比 Docker Swarm 更陡峭的学习曲线。它不使用 Docker CLI。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>语雀-用户初体验</title>
      <link href="2021/03/12/yuque/xqn5e9/"/>
      <url>2021/03/12/yuque/xqn5e9/</url>
      
        <content type="html"><![CDATA[<p>语雀，一款非常适合做知识管理的工具，告别印象笔记</p><p>平时喜欢做知识积累和整理，有道笔记，印象笔记，OneNote, Markdown 都有用，但是都只是满足一部分要求，最近发现了阿里巴巴的一款知识整理工具 “语雀”，确实感觉很好，推荐给大家~ 这针对不是广告</p><h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><h3 id="1-丰富的知识库类型"><a href="#1-丰富的知识库类型" class="headerlink" title="1. 丰富的知识库类型"></a>1. 丰富的知识库类型</h3><p>在这里你可以根据自己需要创建不通的知识库类型，不管你是文档还是博客专栏，还是其他什么<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615561425042-36849ca6-5540-4c46-92e1-bb038f7ee32f.png#align=left&display=inline&height=595&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=475&size=35330&status=done&style=none&width=458" alt="image.png"></p><h3 id="2-丰富的文件导入"><a href="#2-丰富的文件导入" class="headerlink" title="2. 丰富的文件导入"></a>2. 丰富的文件导入</h3><p>假如你之前有很多文档记录，不管是目前流行的 markdown,还是 docs/wps, 包括印象笔记，到可以导入进来进行管理<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615562012793-7f9033f5-89b9-4706-a205-633740e3fc86.png#align=left&display=inline&height=611&margin=%5Bobject%20Object%5D&name=image.png&originHeight=611&originWidth=863&size=64963&status=done&style=none&width=863" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615562145901-796fe279-afb4-4f9a-aaa8-02fec2d39cbb.png#align=left&display=inline&height=476&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=599&size=35140&status=done&style=none&width=599" alt="image.png"></p><h3 id="3-知识库内文档分级管理，更清晰"><a href="#3-知识库内文档分级管理，更清晰" class="headerlink" title="3. 知识库内文档分级管理，更清晰"></a>3. 知识库内文档分级管理，更清晰</h3><p>大部分写技术文档的，都会用 docsify/gitbook 这样的，都会有目录分级，但是需要自己组织，加链接，很麻烦，语雀很方便，可以随意编排目录结构<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615562320016-d442bfb5-09c7-49b6-be37-8475fd5eef0f.png#align=left&display=inline&height=532&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=246&size=14461&status=done&style=none&width=246" alt="image.png"></p><p>对于没有整理好的文件可以放在目录之外，但是仍然在知识库内<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615562518523-c2aeed2e-5020-460d-8322-f6621310c64c.png#align=left&display=inline&height=460&margin=%5Bobject%20Object%5D&name=image.png&originHeight=460&originWidth=631&size=29855&status=done&style=none&width=631" alt="image.png"></p><h3 id="4-文档内容支持各种类别，比如脑图，docs-exec-markdown"><a href="#4-文档内容支持各种类别，比如脑图，docs-exec-markdown" class="headerlink" title="4. 文档内容支持各种类别，比如脑图，docs,exec, markdown"></a>4. 文档内容支持各种类别，比如脑图，docs,exec, markdown</h3><p>就是说各种类型，都可以集中在一个知识库里，有时候知识可能以不同的方式存放，但是转换格式又很麻烦，这个地方是最吸引我的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615562746526-899c8450-93ed-4534-919e-69df29f51cbb.png#align=left&display=inline&height=545&margin=%5Bobject%20Object%5D&name=image.png&originHeight=545&originWidth=999&size=52219&status=done&style=none&width=999" alt="image.png"></p><h3 id="5-开发者模式-通过-webhook-来进行自动化的更新"><a href="#5-开发者模式-通过-webhook-来进行自动化的更新" class="headerlink" title="5. 开发者模式- 通过 webhook 来进行自动化的更新"></a>5. 开发者模式- 通过 webhook 来进行自动化的更新</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615563089697-1662a19f-c165-4190-a7e4-2cdc0100d8b4.png#align=left&display=inline&height=391&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=868&size=30127&status=done&style=none&width=868" alt="image.png"></p><h3 id="6-支持对外发布，知识订阅"><a href="#6-支持对外发布，知识订阅" class="headerlink" title="6. 支持对外发布，知识订阅"></a>6. 支持对外发布，知识订阅</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615563533467-9dc3bfb4-a0da-4845-a568-8b7093cf8aa8.png#align=left&display=inline&height=467&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=539&size=53943&status=done&style=none&width=539" alt="image.png"></p><h3 id="7-知识库的在线-PPT-演示"><a href="#7-知识库的在线-PPT-演示" class="headerlink" title="7. 知识库的在线 PPT 演示"></a>7. 知识库的在线 PPT 演示</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615565089589-1f378d92-7dac-4a5a-bf52-d4cf3f148910.png#align=left&display=inline&height=507&margin=%5Bobject%20Object%5D&name=image.png&originHeight=507&originWidth=1306&size=87958&status=done&style=none&width=1306" alt="image.png"></p><h3 id="8-编辑记录保存，支持在线协同"><a href="#8-编辑记录保存，支持在线协同" class="headerlink" title="8. 编辑记录保存，支持在线协同"></a>8. 编辑记录保存，支持在线协同</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615565188879-cd23e0f4-d9b9-4155-bf38-51fb0da50e27.png#align=left&display=inline&height=423&margin=%5Bobject%20Object%5D&name=image.png&originHeight=423&originWidth=403&size=15352&status=done&style=none&width=403" alt="image.png"></p><h3 id="9-文档本身只是各种类型资源，视频，图片"><a href="#9-文档本身只是各种类型资源，视频，图片" class="headerlink" title="9. 文档本身只是各种类型资源，视频，图片"></a>9. 文档本身只是各种类型资源，视频，图片</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1615564193906-c87119be-2323-4247-9186-a2a20120047c.png#align=left&display=inline&height=497&margin=%5Bobject%20Object%5D&name=image.png&originHeight=497&originWidth=1015&size=52685&status=done&style=none&width=1015" alt="image.png"></p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ol><li>如果 markdown 内有图片链接（图床），无法展示图片</li><li>目前文档加载速度有点慢</li><li>在线协同功能看上去有点偏弱</li><li>操作上还是有些不简洁</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前刚开始用，但是感觉产品使用场景很丰富，假如你用过 gitbook/git, 印象笔记、有道笔记，写过 markdown,在线协同办公（金山文档）， 在这个产品中都可以找到它们的影子。</p><p>说真的，语雀包括了 个人专栏，博客，知识管理，在线协同各个产品线的特点，唯一可能缺少一个好的客户端，加上一个 OneNote 的功能，支持自由的记录。</p><p>确实，这个是个不错的知识管理工具，甚至已经超出了知识管理的范畴，值得推荐。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>区分wsgi、uWSGI、uwsgi、php-fpm、CGI、FastCGI</title>
      <link href="2021/02/24/yuque/ny150b/"/>
      <url>2021/02/24/yuque/ny150b/</url>
      
        <content type="html"><![CDATA[<p>在学习 Python web 开发时候，可能会遇到诸如 uwsgi,wsgi 等名词，下面通过梳理总结探究它们之间的关系。</p><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>CGI，（Common Gateway Interface）通用网关接口，是一个协议，是外部应用程序（CGI 程序）与 WEB 服务器之间的接口标准，该协议定义了 Web 服务器调用外部应用程序的时候需要输入的参数和给 Web 服务器的返回结果。通俗来说，规定一个程序该如何与 web 服务器程序之间通信，从而可以让这个程序跑在 web 服务器上</p><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>最早的 Web 服务器简单地响应浏览器发来的 HTTP 请求，并将存储在服务器上的 HTML 文件返回给浏览器，也就是静态 html。这个场景下的服务器一般被称为 HTTP 服务器，常见的有 Apache 的 httpd 和 Nginx</p><p>事物总是不 断发展，网站也越来越复杂，所以出现动态技术。但是服务器并不能直接运行 php，asp 这样的文件，自己不能做，外包给别人吧，但是要与第三做个约定，我给你什么，然后你给我什么，就是握把请求参数发送给你，然后我接收你的处 理结果给客户端。那这个约定就是 common gateway interface，简称 cgi。这个协议可以用 vb，c，php，python 来实现。cgi 只是接口协议，根本不是什么语言。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616078223921-caeb1da8-42cb-41cc-9061-974035c06f7e.png#crop=0&crop=0&crop=1&crop=1&height=414&id=HYmgS&name=image.png&originHeight=414&originWidth=255&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10784&status=done&style=none&title=&width=255" alt="image.png"></p><p>引入 CGI 以便客户端请求能够触发 Web 服务器运行另一个外部程序，客户端所输入的数据也会传给这个外部程序，该程序运行结束后会将生成的 HTML 和其他数据通过 Web 服务器再返回给客户端（即动态请求，比如基于 PHP、Python、Java 实现的应用）。利用 CGI 可以针对用户请求动态返回给客户端各种各样动态变化的信息</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>Web 服务器与 CGI 程序的交互</strong><br>WEB 服务器将根据 CGI 程序的类型决定数据向 CGI 程序的传送方式，一般是通过标准输入/输出流和环境变量来与 CGI 程序间传递数据。 如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616078294721-4ac9733f-672c-4975-a3da-7a230139b0f9.png#crop=0&crop=0&crop=1&crop=1&height=341&id=RHNDa&name=image.png&originHeight=341&originWidth=454&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16818&status=done&style=none&title=&width=454" alt="image.png"></p><p>CGI 程序通过标准输入（STDIN）和标准输出（STDOUT）来进行输入输出。此外 CGI 程序还通过环境变量来得到输入，操作系统提供了许多环境变量，它们定义了程序的执行环境，应用程序可以存取它们。Web 服务器和 CGI 接口又另外设置了一些环境变量，用来向 CGI 程序传递一些重要的参数。</p><p><strong>常用 CGI 环境变量：</strong></p><table><thead><tr><th>**  变量名**</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>CONTENT_TYPE</td><td>这个环境变量的值指示所传递来的信息的 MIME 类型。目前，环境变量 CONTENT_TYPE 一般都是：application/x-www-form-urlencoded,他表示数据来自于 HTML 表单。</td></tr><tr><td>CONTENT_LENGTH</td><td>如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即使从标准输入 STDIN 中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。</td></tr><tr><td>HTTP_COOKIE</td><td>客户机内的 COOKIE 内容。</td></tr><tr><td>HTTP_USER_AGENT</td><td>提供包含了版本数或其他专有数据的客户浏览器信息。</td></tr><tr><td>PATH_INFO</td><td>这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现。</td></tr><tr><td>QUERY_STRING</td><td>如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在 CGI 程序名的后面，两者中间用一个问号’?’分隔。</td></tr><tr><td>REMOTE_ADDR</td><td>这个环境变量的值是发送请求的客户机的 IP 地址，例如上面的 192.168.1.67。这个值总是存在的。而且它是 Web 客户机需要提供给 Web 服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web 客户机。</td></tr><tr><td>REMOTE_HOST</td><td>这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。</td></tr><tr><td>REQUEST_METHOD</td><td>提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。</td></tr><tr><td>SCRIPT_FILENAME</td><td>CGI 脚本的完整路径</td></tr><tr><td>SCRIPT_NAME</td><td>CGI 脚本的的名称</td></tr><tr><td>SERVER_NAME</td><td>这是你的 WEB 服务器的主机名、别名或 IP 地址。</td></tr><tr><td>SERVER_SOFTWARE</td><td>这个环境变量的值包含了调用 CGI 程序的 HTTP 服务器的名称和版本号。例如，上面的值为 Apache/2.2.14(Unix)</td></tr></tbody></table><p>##</p><p>每当客户请求 CGI 的时候，WEB 服务器就请求操作系统生成一个新的 CGI 解释器进程(如 php-cgi.exe)，CGI 的一个进程则处理完一个请求后退出，下一个请求来时再创建新进程。当然，这样在访问量很少没有并发的情况也行。但当访问量增大，并发存在，这种方式就不适合了，于是就有了 FastCGI</p><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><p>FASTCGI 是 Web 服务器（ex:nginx）和语言解释器(ex:uWsgi)两者底层的通信协议的规范，是对 CGI 的开放的扩展。</p><p>CGI 的一个扩展，像是一个常驻(long-live)型的 CGI ，废除了 CGI fork-and-execute （来一个请求 fork 一个新进程处理，处理完再把进程 kill 掉）的工作方式，转而使用一种长生存期的方法，减少了进程消耗，提升了性能。</p><p>而 FastCGI 则会先 fork 一个 master 进程，解析配置文件，初始化执行环境，然后再 fork 多个 worker 进程（与 Nginx 有点像），当 HTTP 请求过来时，master 进程将其会传递给一个 worker 进程，然后立即可以接受下一个请求，这样就避免了重复的初始化操作，效率自然也就提高了。而且当 worker 进程不够用时，master 进程还可以根据配置预先启动几个 worker 进程等着；当空闲 worker 进程太多时，也会关掉一些，这样不仅提高了性能，还节约了系统资源</p><h2 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h2><p>FastCGI 只是一个协议规范，需要每个语言具体去实现，<strong>PHP-FPM 就是 PHP 版本的 FastCGI 协议实现</strong>，有了它，就是实现 PHP 脚本与 Web 服务器（通常是 Nginx）之间的通信，同时它也是一个 PHP SAPI，从而构建起 PHP 解释器与 Web 服务器之间的桥梁</p><p>Php-fpm 全称是 php fastcgi process manager 即 php fastcgi 进程管理器，相比 fastcgi 静态的唤起 cgi，fpm 能根据访问的压力动态的唤起 cgi 进程和销毁以到达动态的调整 cgi 数量，这样可以有效的使用内存。除此之外还有其它的一些优点，比如，fpm 还可以平滑的重载 php 配置；由于 fpm 是使用 Unix-Socket 来和服务器通讯，所以也不用再配置 cgi 端口；fpm 有更好的状态输出和 slowlog 日志，502 的时候能给出更多的错误细节。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1617120408842-18290e71-b2ad-4fe9-9958-29180e5754e1.png#crop=0&crop=0&crop=1&crop=1&height=274&id=jDhf6&originHeight=274&originWidth=902&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=902"></p><p>PHP-FPM 负责管理一个进程池来处理来自 Web 服务器的 HTTP 动态请求，在 PHP-FPM 中，master 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 worker 进程进行处理，worker 进程主要负责动态执行 PHP 代码，处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。这就是 PHP-FPM 的基本工作原理</p><h2 id="WSGI-uwsgi-uWSGI"><a href="#WSGI-uwsgi-uWSGI" class="headerlink" title="WSGI / uwsgi / uWSGI"></a>WSGI / uwsgi / uWSGI</h2><p>在 python web 开发中，我们经常使用 uwsgi 配合 nginx 部署一个 web 框架，如 Django 或 flask。同时我们又会说，框架和 web 服务器之间要符合 WSGI 协议</p><p>那就来厘清一下这几个概念。</p><p><strong>web 服务器和 web 框架</strong><br>在讲 uWSGI 和 WSGI 之前，先要弄清楚 web 开发的两大块，web 服务器和 web 框架。<br>web 服务器即用来接受客户端请求，建立连接，转发响应的程序。至于转发的内容是什么，交由 web 框架来处理，即处理这些业务逻辑。如查询数据库、生成实时信息等。Nginx 就是一个 web 服务器，Django 或 flask 就是 web 框架。</p><p>那么如何实现 uWSGI 和 WSGI 的配合呢？如何做到任意一个 web 服务器，都能搭配任意一个框架呢？这就产生了 WSGI 协议。只要 web 服务器和 web 框架满足 WSGI 协议，它们就能相互搭配。所以 WSGI 只是一个协议，一个约定。而不是 python 的模块、框架等具体的功能。</p><p>而 uWSGI，则是实现了 WSGI 协议的一个 web 服务器。即用来接受客户端请求，转发响应的程序。实际上，一个 uWSGI 的 web 服务器，再加上 Django 这样的 web 框架，就已经可以实现网站的功能了。</p><h3 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h3><p>WSGI，（WEB SERVER GATEWAY INTERFACE），Web 服务器网关接口，是一种 Web 服务器网关接口，它是一个 Web 服务器（如 Nginx，uWSGI 等服务器）与 web 应用（如 Flask 框架写的程序）通信的一种规范。<strong>当前运行在 WSGI 协议之上的 Web 框架有 Bottle，Flask，Django</strong></p><p>实现了 python web 程序与服务器之间交互的通用性。有了这个东西，web.py 或者 bottle 或者 django 等等的 python web 开发框架，就可以轻松地部署在不同的 web server 上了，不需要做任何特殊配置（也需要一些小小的配置调整）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616079598776-3f18d2f8-842c-44da-acd5-52833f513c72.png#crop=0&crop=0&crop=1&crop=1&height=120&id=Cl1Ee&name=image.png&originHeight=120&originWidth=313&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23494&status=done&style=none&title=&width=313" alt="image.png"></p><p>##</p><p>WSGI 协议其实是定义了一种 server 与 application 解耦的规范，即可以有多个实现 WSGI server 的服务器，也可以有多个实现 WSGI application 的框架，那么就可以选择任意的 server 和 application 组合实现自己的 web 应用。例如 uWSGI 和 Gunicorn 都是实现了 WSGI server 协议的服务器，Django，Flask 是实现了 WSGI application 协议的 web 框架，可以根据项目实际情况搭配使用。</p><p>像 Django，Flask 框架都有自己实现的简单的 WSGI server，一般用于服务器调试，生产环境下建议用其他 WSGI server，WSGI 服务器的选择很多，包括 uWSGI 和 gunicorn</p><h3 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h3><p>同 WSGI 一样是一种通信协议<br>uwsgi 协议是一个 uWSGI 服务器自有的协议，它用于定义传输信息的类型（type of information），每一个 uwsgi packet 前 4byte 为传输信息类型描述，它与 WSGI 相比是两样东西。</p><h3 id="uWSGI-服务器"><a href="#uWSGI-服务器" class="headerlink" title="uWSGI (服务器)"></a>uWSGI (服务器)</h3><p>它是一个 Web 服务器，它实现了 WSGI 协议、uwsgi、http 等协议。用于接收前端服务器转发的动态请求并处理后发给 web 应用程序。<br>因为 apache 也好，nginx 也罢，它们自己都没有解析动态语言如 php 的功能，而是分派给其他模块来做，比如 apache 就可以说内置了 php 模块，支持的非常爽，让人感觉好像 apache 就支持 php 一样。uwsgi 实现了 WSGI 协议、uwsgi、http 等协议。 Nginx 中 HttpUwsgiModule 的作用是与 uWSGI 服务器进行交换。</p><p>uWSGI 是使用 C 编写的，显示了自有的 uwsgi 协议的 Web 服务器。它自带丰富的组件，其中核心组件包含进程管理、监控、IPC 等功能，实现应用服务器接口的请求插件支持多种语言和平台，比如 WSGI、Rack、Lua WSAPI，网管组件实现了负载均衡、代理和理由功能</p><p>uWSGI 也可以当做中间件。</p><ul><li>如果是 Nginx+uWSGI+App，那 uWSGI 就是一个中间件</li><li>如果是 uWSGI+App，那它就是服务器</li></ul><h3 id="Nginx-uWGSI"><a href="#Nginx-uWGSI" class="headerlink" title="Nginx+uWGSI"></a>Nginx+uWGSI</h3><p>假设我们使用 python 的 Django 框架写了一个网站，现在要将它挂在网上运行，我们一般需要：</p><ul><li>Nginx 做为代理服务器：负责静态资源发送（js、css、图片等）、动态请求转发以及结果的回复。</li><li>uWSGI 做为后端服务器：负责接收 Nginx 转发的请求并处理后发给 Django 应用以及接收 Django 应用返回信息转发给 Nginx。</li><li>Django 应用收到请求后处理数据并渲染相应的返回页面给 uWSGI 服务器。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616077881390-3e148c74-910a-40f7-84d8-975a6ed752eb.png#crop=0&crop=0&crop=1&crop=1&height=178&id=hEJjd&name=image.png&originHeight=178&originWidth=616&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13163&status=done&style=none&title=&width=616" alt="image.png"><br>一个 Django 应用，通过 WSGI 协议连接 uWSGI 服务器，uWSGI 服务器实现 WSGI、http 等协议，通过 uwsgi 协议和 Nginx 服务器实现 http 的动态请求和转发以及结果</p><p><strong>问题：有 uWGSI 了 Django 为什么还需要 Nginx？</strong><br>一个普通的个人网站，访问量不大的话，当然可以由 uWSGI 和 Django 构成。但是一旦访问量过大，客户端请求连接就要进行长时间的等待。这个时候就出来了分布式服务器，我们可以多来几台 web 服务器，都能处理请求。但是谁来分配客户端的请求连接和 web 服务器呢？Nginx 就是这样一个管家的存在，由它来分配。这也就是由 Nginx 实现反向代理，即代理服务器。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/5374140/1616079509341-0a5ff5cc-8811-4cbc-93e9-26aefb4d4b9e.png#crop=0&crop=0&crop=1&crop=1&height=343&id=q0Qtl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=366&originWidth=386&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=35037&status=done&style=none&title=&width=362" alt="image.png"></p><p>Nginx 是一个 HTTP 和反向代理服务器</p><ul><li><p>正向代理</p><pre><code>正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器</code></pre></li><li><p>反向代理</p><p>反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器</p></li></ul><p>使用 Nginx 作为反向代理服务器的好处：</p><ul><li>安全</li></ul><p>不管什么请求都要经过代理服务器，可以避免外部程序直接攻击 Web 服务器</p><ul><li>负载均衡</li></ul><p>根据请求情况和服务器负载情况，将请求分配给不同的 Web 服务器，保证服务器性能</p><ul><li>提高 Web 服务器的 IO 性能</li></ul><p>请求从客户端传到 Web 服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以由反向代理完整接受该请求，然后再传给 Web 服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过 Web 服务器</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>WSGI 是一种通信协议</li><li>uwsgi 是一种通信协议，常用于在 uWSGI 服务器与其他网络服务器的数据通信</li><li>而 uWSGI 是实现了 uwsgi 和 WSGI 两种协议的 Web 服务器</li></ul><p>百度百科上说 uwsgi 是一种线路协议而不是通信协议，个人更倾向于 uwsgi 是类似 WSGI 的通信协议的说法，uwsgi 和 WSGI 都是基于 CGI 扩展出来的。</p><h2 id="ASGI"><a href="#ASGI" class="headerlink" title="ASGI"></a>ASGI</h2><p><strong>异步网关协议接口</strong>，一个介于网络协议服务和 Python 应用之间的标准接口，能够处理多种通用的协议类型，包括 HTTP，HTTP2 和 WebSocket。<br>然而目前的常用的 WSGI 主要是针对 HTTP 风格的请求响应模型做的设计，并且越来越多的不遵循这种模式的协议逐渐成为 Web 变成的标准之一，例如 WebSocket。</p><p>ASGI 尝试保持在一个简单的应用接口的前提下，提供允许数据能够在任意的时候、被任意应用进程发送和接受的抽象。并且同样描述了一个新的，兼容 HTTP 请求响应以及 WebSocket 数据帧的序列格式。允许这些协议能通过网络或本地 socket 进行传输，以及让不同的协议被分配到不同的进程中。</p><h3 id="WSGI-和-ASGI-的区别"><a href="#WSGI-和-ASGI-的区别" class="headerlink" title="WSGI 和 ASGI 的区别"></a>WSGI 和 ASGI 的区别</h3><p>WSGI 是基于 HTTP 协议模式的，不支持 WebSocket，而 ASGI 的诞生则是为了解决 Python 常用的 WSGI 不支持当前 Web 开发中的一些新的协议标准。同时，ASGI 对于 WSGI 原有的模式的支持和 WebSocket 的扩展，即 ASGI 是 WSGI 的扩展。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wanghetao/p/3934350.html">https://www.cnblogs.com/wanghetao/p/3934350.html</a><br><a href="https://baike.baidu.com/item/fastcgi/10880685">https://baike.baidu.com/item/fastcgi/10880685</a><br><a href="https://www.jianshu.com/p/679dee0a4193">https://www.jianshu.com/p/679dee0a4193</a><br><a href="https://baijiahao.baidu.com/s?id=1590941335729952485%ED%94%B4=spider&for=pc">https://baijiahao.baidu.com/s?id=1590941335729952485픴=spider&amp;for=pc</a><br><a href="https://blog.csdn.net/qq_35318838/article/details/61198183">https://blog.csdn.net/qq_35318838/article/details/61198183</a></p><p>#</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DevOps 实战</title>
      <link href="2020/09/05/devops/"/>
      <url>2020/09/05/devops/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>维基百科的定义</p><blockquote><p>DevOps（开发 Development 与运维 Operations 的组合词）是一种文化、一场运动或实践，强调在自动化软件交付流程及基础设施变更过程中，软件开发人员与其他信息技术（IT）专业人员彼此之间的协作与沟通。它旨在建立一种文化与环境，使构建、测试、软件发布得以快速、频繁以及更加稳定地进行。</p></blockquote><p><strong>DevOps 是通过平台（Platform）、流程（Process）和人（People）的有机整合，以C（协作）A（自动化）L（精益）M（度量）S（共享）文化为指引，旨在建立一种可以快速交付价值并且具有持续改进能力的现代化 IT 组织。</strong></p><h2 id="DevOps-的价值"><a href="#DevOps-的价值" class="headerlink" title="DevOps 的价值"></a>DevOps 的价值</h2><p><strong>高效的软件交付方式</strong></p><p>根据DevOps现状报告，可以得出 DevOps 的 4 个结果指标。</p><ol><li><strong>部署频率</strong>：指应用和服务向生产环境部署代码的频率。</li><li><strong>变更前置时间</strong>：指代码从提交到成功运行在生产环境的时长。</li><li><strong>服务恢复时间</strong>：指线上应用和服务出现故障到恢复运行的时长。</li><li><strong>变更失败率</strong>：指应用和服务在生产环境部署失败或者部署后导致服务降级的比例。</li></ol><p>每年，这个报告都会基于这 4 个核心指标统计行业内高效能团队和低效能团队之间的差距。从去年的数据来看，与低效能团队相比，高效能团队的部署频率高了 46 倍，变更前置时间快了 2500 多倍，服务恢复时间也快了 2600 多倍，失败率低了 7 倍。</p><p>DevOps 状态报告中提到的四项结果指标，分别代表了软件交付的两个最重要的方面，也就是交付效率和交付质量。而且，从数据结果中，我们还能得到一个惊人的发现，那就是高效能的组织不仅做到了高效率，还实现了高质量，由此可见，鱼与熊掌可以兼得。</p><blockquote><p>DevOps 状态报告合集 <a href="https://pan.baidu.com/s/1W7-_et-wulD7AueBU2KTow">https://pan.baidu.com/s/1W7-_et-wulD7AueBU2KTow</a> 提取码：mgl1</p></blockquote><p><strong>激发团队的创造力</strong></p><p>实施 DevOps，一方面可以通过种种流程优化和自动化能力，改善软件开发团队的工作节奏，另一方面，也可以让大家关注同一个目标，彼此信任，高效协作，调动员工的积极性和创新能力，从而让整个团队进入一种积极创造价值的状态，而这所带来的影响远非建设一两个工具平台可比拟的。</p><h2 id="DevOps-的实施"><a href="#DevOps-的实施" class="headerlink" title="DevOps 的实施"></a>DevOps 的实施</h2><h3 id="DevOps-工具"><a href="#DevOps-工具" class="headerlink" title="DevOps 工具"></a>DevOps 工具</h3><p><strong>一切软件交付过程中的手动环节，都是未来可以尝试进行优化的方向。</strong>即便在运维圈里面，<strong>ITIL（IT 基础架构库)</strong> 一直是运维赖以生存的基石，也并不妨碍自动化的理念逐步深入到ITIL 流程之中，从而在受控的基础上不断优化流程流转效率。</p><p>工具平台的引入和建设就成为了 DevOps 打动人的关键因素之一。但是大量的引入这类工具，会造成企业内部的工具平台泛滥，很多同质化的工具在完成从0 到 1 的过程后就停滞不前，陷入重复的怪圈，显然也是一种资源浪费。也有很多公司引入了完整的敏捷项目管理工具，但是却以传统项目管理的方式来使用这套工具，效率跟以前相比并没有明显的提升。对于自研平台来说，也是同样的道理。如果仅仅是把线下的审批流程搬到线上执行，固然能提升一部分执行效率，但是对于企业期望的质变来说，却是相距甚远。</p><p>说到底，工具没法解决人的问题，这样一条看似取巧的路径，却没法解决企业的根本问题。这时候，就需要文化闪亮登场了。</p><h3 id="DevOps-文化"><a href="#DevOps-文化" class="headerlink" title="DevOps 文化"></a>DevOps 文化</h3><p>首先要建立一套DevOps的机制，包括 OKR 指标的设定、关键指标达成后的激励、成立专项的工作小组、引入外部的咨询顾问，以及一套客观的评判标准，这一切都保证了团队走在正确的道路上。而承载这套客观标准的就是一套通用的度量平台，说到底，还是需要将<strong>规则内建于工具之中，并通过工具来指导实践。</strong></p><p>这样一来，当团队通过 DevOps 获得了实实在在的改变，那么 <strong>DevOps 所倡导的职责共担、持续改进的文化</strong>自然也会生根发芽。</p><p>所以你看，DevOps 中的文化和工具，本身就是一体两面，我们既不能盲目地奉行工具决定论，上来就大干快干地采购和建设工具，也不能盲目地空谈文化，在内部形成一种脱离实际的风气。</p><h3 id="DevOps-的-3-个支柱"><a href="#DevOps-的-3-个支柱" class="headerlink" title="DevOps 的 3 个支柱"></a>DevOps 的 3 个支柱</h3><p>对工具和文化的体系化认知，可以归纳到 DevOps 的 3 个支柱之中，即<strong>人（People）、流程（Process）和平台（Platform）</strong>。3 个支柱之间两两组合，构成了我们实施 DevOps的”正确姿势”，只强调其中一个维度的重要性，明显是很片面的。</p><ul><li><p><strong>人 + 流程 = 文化</strong></p><p>在具体的流程之下，人会形成一套行为准则，而这套行为准则会潜移默化地影响软件交付效率和质量的方方面面。这些行为准则组合到一起，就构成了企业内部的文化。</p><p><strong>指导 DevOps 落地发展的思想，就是 DevOps 的文化</strong>。</p><ul><li><strong>责任共担和质量导向的文化：</strong>在谷歌 SRE 的实践中，研发交付的应用需要自运维一段时间，并且要在达到一定的质量指标之后才会交接给 SRE 进行运维。但是，为了避免出现“研发一走，运维背锅”的情况，他们还建立了“打回”的流程，也就是当 SRE 运维一段时间后，如果发现应用稳定性不达标，就会重新交还给开发自己负责维护，这样一来，研发就会主动地保障线上应用的质量。</li><li><strong>线上安全点数的文化：</strong>在一定的额度范围内，允许团队出现问题，并且不追究责任。这就可以激励团队更加主动地完成交付活动，不必每一次都战战兢兢，生怕出错。通过流程和行为的改变，团队的文化也在慢慢地改进。</li></ul></li><li><p><strong>流程 + 平台 = 工具</strong></p><p><strong>平台的最大意义，就是承载企业内部的标准化流程。</strong>当这些标准化流程被固化在平台之中时，所有人都能够按照一套规则沟通，沟通效率显然会大幅提升。</p><p><strong>平台上固化的每一种流程，其实都是可以用来解决实际问题的工具。</strong>很多人分不清工具和平台的关系，好像只要引入或者开发了一个工具，都可以称之为平台，也正因为这样，企业内部的平台比比皆是。</p><p>实际上，平台除了有<strong>用户量、认可度、老板加持</strong>等因素之外，还会有 3 个显著特征。</p><ol><li><strong>吸附效应</strong>：平台会不断地吸收中小型的工具，逐渐成为一个能力集合体。</li><li><strong>规模效应</strong>：平台的成本不会随着使用方的扩展而线性增加，能够实现规模化。</li><li><strong>积木效应</strong>：平台具备基础通用共享能力，能够快速搭建新的业务实现。</li></ol></li><li><p><strong>平台 + 人 = 培训赋能</strong></p><p>平台是标准化流程的载体，一方面可以规范和约束员工的行为，另一方面，通过平台赋能，所有人都能以相同的操作，获得相同的结果。这样一来，跨领域之间的交接和专家就被平台所取代，当一件事情不再依赖于个人的时候，等待的浪费就会大大降低，平台就成了组织内部的能力集合体。</p><p>但与此同时，当我们定义了期望达到的目标，并提供了平台工具，那么对人的培训就变得至关重要，因为只有这样，才能让工具平台发挥最大的效用。更加重要的是，通过最终的用户使用验证，可以发现大量的可改进空间，进一步推动平台能力的提升，从而带动组织整体的飞轮效应，加速组织的进化。</p></li></ul><p>所以你看，<strong>文化、工具和培训</strong>作为 DevOps 建设的 3 个重心，折射出来的是对<strong>组织流程、平台和人</strong>的关注，<strong>三位一体，缺一不可</strong>。</p><h2 id="DevOps的实施路线图"><a href="#DevOps的实施路线图" class="headerlink" title="DevOps的实施路线图"></a>DevOps的实施路线图</h2><p>通过模型和框架，来帮助企业识别当前的 DevOps 能力水平并加以改进。</p><p>下列是DevOps的熟练度模型：</p><p><img src="/assets/images/ops/devops/devops-model.png" alt="devops-model"></p><blockquote><p>研发运营一体化（DevOps）能力成熟度模型</p></blockquote><p>在实际参考模型和框架的时候，我认为应该尽量遵循以下步骤和原则：</p><ul><li><strong>1.识别差距。</strong> 通过和模型、框架进行对标，可以快速识别出企业当前存在的短板和差距，并建立企业当前的能力状态基线，用于对比改进后所取得的效果。</li><li><strong>2.锚定目标。</strong>数字化转型的核心在于优化软件交付效率。通过对标模型框架，企业需要明确什么是影响软件交付效率进一步提升的最大瓶颈，当前存在的最大痛点是什么，哪些能力的改善有助于企业达成预定的目标……同时，要根据企业的现状，甄别对标的差距结果，识别出哪些是真实有效的，哪些可以通过平台能力快速补齐。</li><li><strong>3.关注能力。</strong>模型和框架是能力和实践的集合，也就是道法术器的“术”这个层面，所以在应用模型的过程中，核心的关注点应该在能力本身，而不是单纯地比较数字和结果。根据锚定的目标识别所需要的能力，再导入与能力相匹配的实践，不断强化实践，从而使能力本身得到提升。</li><li><strong>4.持续改进。</strong>模型和框架本身也不是一成不变的，也需要像 DevOps 一样不断迭代更新，以适应更高的软件交付需要。</li></ul><p>下面是以模型为指导，对示例企业进行了全面梳理，汇总了一张大盘图</p><p><img src="/assets/images/ops/devops/devops-model-use.png" alt="devops-model-use"></p><p>接下来，针对识别出来的这些差距点，找到需要改进的目标和预期效果，并分析哪些关键能力制约了交付效率的提升，对问题进行逐个优化。</p><p>由此可以看出，<strong>DevOps 的能力实践和能力框架模型相辅相成</strong>：能力实践定义了企业落地DevOps 的路线图和主要建设顺序，能力模型可以指导支撑方法的各类实践的落地建设；能力实践时刻跟随企业价值交付的导向，而能力模型的积累和沉淀，能够让企业游刃有余地面对未来的各种挑战。</p><p>至于 ITIL 和 CMMI，这些过往的框架体系自身也在跟随 DevOps 的大潮在持续演进，比如以流程合规为代表的 ITIL 最近推出了第 4 个版本。我们引用一下 <strong>ITIL V4 的指导原则，包括：关注价值、关注现状、交互式流程和反馈、协作和可视化、自动化和持续优化、极简原则和关注实践。</strong></p><h2 id="价值流分析"><a href="#价值流分析" class="headerlink" title="价值流分析"></a>价值流分析</h2><p><strong>什么是价值？</strong>简单来说，价值就是<strong>那些带给企业生存发展的核心资源</strong>，比如生产力、盈利能力、市场份额、用户满意度等。</p><p><strong>VSM</strong> 是 Value Stream Mapping 的缩写，也就是我们常说的<strong>价值流图</strong>。它起源于传统制造业的精益思想，用于分析和管理一个产品交付给用户所经历的业务流、信息流，以及各个阶段的移交过程。</p><p>说白了，VSM 就是要说清楚在需求提出后，怎么一步步地加工原材料，进行层层的质量检查，最终将产品交付给用户的过程。通过观察完整流程中各个环节的流动效率和交付质量，识别不合理的、低效率的环节，进行优化，从而实现整体效率的提升。</p><p>通过使用价值流图对软件交付过程进行建模，使整个过程可视化，从而识别出交付的瓶颈和各个环节之间的依赖关系，这恰恰是“DevOps 三步工作法”的第一步“流动”所要解决的问题。</p><p><strong>DevOps 三步工作法:</strong></p><p><strong>第一步：流动。</strong>通过工作可视化，限制在制品数量，并注入一系列的工程实践，从而加速从开发到运营的流动过程，实现低风险的发布。<br><strong>第二步：反馈。</strong>通过注入流动各个过程的反馈能力，使缺陷在第一时间被发现，用户和运营数据第一时间展示，从而提升组织的响应能力。<br><strong>第三步：持续学习和试验。</strong>没有任何文化和流程是天生完美的，通过团队激励学习分享，将持续改进注入日常工作，使组织不断进步。</p><h3 id="VSM关键要素"><a href="#VSM关键要素" class="headerlink" title="VSM关键要素"></a>VSM关键要素</h3><ol><li><strong>前置时间（Lead Time，简称 LT）</strong>。前置时间在 DevOps 中是一项非常重要的指标。具体来说，它是指一个需求从提出（典型的就是创建一个需求任务）的时间点开始，一直到最终上线交付给用户为止的时间周期。这部分时间直接体现了软件开发团队的<strong>交付速率</strong>，并且可以用来计算<strong>交付吞吐量</strong>。DevOps 的核心使命之一就是优化这段时长。</li><li><strong>增值活动时间和不增值活动时间（Value Added Time/Non-Value Added Time，简称VAT/NVAT）</strong>。在精益思想中，最重要的就是<strong>消除浪费</strong>，也就是说最大化流程中那些增值活动的时长，降低不增值活动的时长。在软件开发行业中，典型的不增值活动有很多，比如无意义的会议、需求的反复变更、开发的缺陷流向下游带来的返工等。</li><li><strong>完成度和准确度（% Complete/Accurate，简称 %C/A）</strong>。这个指标用来表明工作的质量，也就是有多少工作因为质量不符合要求而被下游打回。这里面蕴含了大量的沟通和返工成本，从精益的视角来看，也是一种浪费。</li></ol><p>关于前置时间，有很多种解释，一般建议采用需求前置时间和开发前置时间两个指标进行衡量</p><ul><li><p>需求前置时间：从需求提出（创建任务），到完成开发、测试、上线，最终验收通过的时间周期，考查的是团队整体的交付能力，也是用户核心感知的周期。</p></li><li><p>开发前置时间：从需求开始开发（进入开发中状态），到完成开发、测试、上线，最终验收通过的时间周期，考查的是团队的开发能力和工程能力。</p></li></ul><h3 id="开展-VSM"><a href="#开展-VSM" class="headerlink" title="开展 VSM"></a>开展 VSM</h3><p>如何开展一次成功的 VSM 活动呢？一般来说，有 2 种方式。</p><ol><li><strong>召开一次企业内部价值流程梳理的工作坊或者会议。</strong></li></ol><p>​    选取改进项目对象中某个核心的业务模块，参加会议的人员需要覆盖软件交付的所有环节，包括工具平台提供方。而且，参会人员要尽量是相对资深的，因为他们对自身所负责的业务和上下游都有比较深刻的理解，比较容易识别出问题背后的根本原因。</p><ol start="2"><li><strong>内部人员走访。</strong></li></ol><p>​    通常来说，企业内部的DevOps 转型工作都会有牵头人，甚至会成立转型小组，那么可以由这个小组中的成员对<br>软件交付的各个环节的团队进行走访。这种方式在时间上是比较灵活的，但对走访人的要求比较高，最好是 DevOps 领域的专家，同时是企业内部的老员工，这样可以跟受访人有比较深入坦诚的交流。</p><p>沟通时，要建立一个问题列表，避免东拉西扯。</p><ul><li>在价值交付过程中，你所在团队的主要职责是什么？</li><li>你所在团队的上下游团队有哪些？</li><li>价值在当前环节的处理方式，时长是怎样的？</li><li>有哪些关键系统支持了价值交付工作？</li><li>是否存在等待或其他类型的浪费？</li><li>工作向下游流转后被打回的比例是多少？</li></ul><p>为了方便你更好地理解这些问题，我给你提供一份测试团队的访谈示例。</p><table><thead><tr><th>关键问题</th><th>参考答案</th></tr></thead><tbody><tr><td>在价值交付的过程中，你所在团队的主要职责是什么?</td><td>我们是软件质量的把关人，负责交付软件的功能质量验收工作，避免缺陷流入线上环节。</td></tr><tr><td>你所在团队的上下游团队有哪些?</td><td>我们的上游是开发团队，下游是运维团队，另外还跟项目管理团队和安全团队有关系。</td></tr><tr><td>价值在当前环节的处理方式，时长是怎样的?</td><td>从迭代需求开始，我们就会参与需求评审，并进行测试设计。研发提测后，我们就会按照测试计划和案例对功能进行验收，如果验收通过，就给出测试报告并流转下游，如果存在问题，就提出缺陷。—般来说，平均测试流转周期为2.5天。</td></tr><tr><td>有哪些关键系统支持了价值交付工作?</td><td>包括研发提测系统，测试管理平台，缺陷系统。</td></tr><tr><td>是否存在等待和其他类型的浪费?</td><td>开发提测后一般都需要开发人员在测试环境部署，有时候开发人员不在就要等待，另外每次申请测试环境也需要向环境部门申请，往往几天才能下来。</td></tr><tr><td>工作向下游流转后被打回的比例有多少?</td><td>这个要看缺陷漏测率和线上缺陷逃逸率指标，我们有相关的数据，人概漏测率0.15%。</td></tr></tbody></table><p>通过访谈交流，我们就可以对整个软件交付过程有一个全面的认识，并根据交付中的环节、上下游关系、处理时长、识别出来的等待浪费时长等，按照 VSM 模型图画出当前部门的价值流交付图，以及各个阶段的典型工具，如下图所示：</p><p><img src="/assets/images/ops/devops/image-20200821102924116.png" alt="image-20200821102924116"></p><h3 id="VSM的价值"><a href="#VSM的价值" class="headerlink" title="VSM的价值"></a>VSM的价值</h3><p>实际上，它的价值绝不仅限于输出了一幅价值流交付图而已。VSM 具有非常丰富的价值，包括以下几个方面：</p><ol><li><p><strong>看见全貌。</strong></p><p>如果只关注单点问题，我们会很容易陷入局部优化的怪圈。DevOps 追求的是价值流动效率最大化，也就是说，就算单点能力再强，单点之间的割裂和浪费对于价值交付效率的影响也是超乎想象的。所以，对于流程改进来说，第一步，也是最重要的一步，就是能够看见全貌，这样才能从全局视角找到可优化的瓶颈点，从而提升整体的交付效率。</p><p>另外，<strong>对于全局交付的建模，最终也会体现到软件持续交付流水线的建设上</strong>，因为流水线反映的就是企业客观的交付流程。</p></li><li><p><strong>识别问题。</strong></p><p>VSM 中的几个关键指标，也就是前置时长、增值和不增值时长，以及完成度和准确度，都是可以客观量化改进的指标。当面对这样一幅价值流图的时候，我们很容易就能识别出当前最重要的问题和改进事项。</p></li><li><p><strong>促进沟通。</strong></p><p>在我们开展 VSM 梳理的时候，团队才第一次真正了解上下游团队的职责、工作方式，以及让他们痛苦低效的事情。这时，我们通常会设身处地地想：“只要我们多做一点点，就能大大改善兄弟团队的生存状况了。”实际上，这种<strong>同理心对打破协作的壁垒很有帮助</strong>，可以为改善团队内部文化带来非常正面的影响。实际上，这也是我推荐你用会议或者工作坊的方式推进 VSM 的根本原因。</p></li><li><p><strong>驱动度量。</strong></p><p>在 VSM 访谈的时候，我们要问一个团队的交付周期、准确率等指标问题，如果你发现这个团队支支吾吾，只能给出模糊的回答，这时你就要注意啦，这里本身就大有问题。因为这就表示当前环节的度量指标不够清晰，或者指标过于复杂，团队不清楚关键的结果指标。<br>另外，如果数据的提取需要大量时间，比如需要采用人为统计算数的方式，那么这就体现了这个环节的平台建设能力不足，无法自动化地收集和统计数据，甚至有些关键数据还没有沉淀到数据系统中，只能通过人工本地化的方式进行管理。<br>这些都是 DevOps 转型的过程中需要解决的问题，可以优先处理。可以说，<strong>VSM 是一场团队协作的试炼</strong>。收集 VSM 数据的过程本身，就需要平台间的打通和数据共享，以及自动化的推进，这有助于度量活动的开展。</p></li><li><p><strong>价值展现。</strong></p><p>如何让高层领导明白企业交付效率改善所带来的价值呢？价值流梳理就是一种很好的方式。因为 <strong>VSM 从价值分析而来，到价值优化而去</strong>，本身就是在回答 DevOps 对于企业的价值问题。</p></li></ol><h2 id="DevOps的实施路径"><a href="#DevOps的实施路径" class="headerlink" title="DevOps的实施路径"></a>DevOps的实施路径</h2><p>如果想在企业内部推行一种新的模式，无外乎有两种可行的轨迹：一种是<strong>自底向上</strong>，一种是<strong>自顶向下</strong>。</p><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p>在这种模式下，企业内部的 DevOps 引入和实践源自于一个小部门或者小团队，他们可能是 DevOps 的早期倡导者和实践者，为了解决自身团队内部，以及上下游团队交互过程中的问题，开始尝试使用 DevOps 模式。由于团队比较小，而且内部的相关资源调动起来相对简单，所以这种模式比较容易在局部获得效果。</p><p>采用“<strong>羽化原则</strong>”，也就是首先在自己团队内部，以及和自己团队所负责的业务范围有强依赖关系的上下游团队之间建立联系，<strong>一方面不断扩展自己团队的能力范围，另一方面，逐步模糊上下游团队的边界，由点及面地打造 DevOps 共同体</strong>。</p><p>当然，如果想让 DevOps 转型的效果最大化，你一定要想方设法地让<strong>高层知晓局部改进的效果</strong>，让他们认可这样的尝试，最终实现横向扩展，在企业内部逐步铺开。</p><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>企业高层基于自己对于行业趋势发展的把握和团队现状的了解，以行政命令的方式下达任务目标。在这种模式下，公司领导有足够的意愿来推动 DevOps 转型并投入资源，各个团队也有足够清晰的目标。</p><p>那么，这样是不是就万事大吉了呢？其实不然。在企业内部有这样一种说法：只要有目标，就一定能达成。因为公司领导对于细节的把握很难做到面面俱到，团队为了达成上层目标，总是能想到一些视角或数据来证明目标已经达成，这样的 DevOps 转型说不定对公司业务和团队而言反而是一种伤害。</p><p>无论企业的 DevOps 转型采用哪条轨迹，<strong>寻求管理层的认可和支持都是一个必选项</strong>。如果没有管理层的支持，DevOps 转型之路将困难重重。因为无论在什么时代，变革一直都是一场勇敢者的游戏。对于一家成熟的企业而言，无论是组织架构、团队文化，还是工程能力、协作精神，都是长期沉淀的结果，而不是在一朝一夕间建立的。</p><p>除此之外，转型工作还需要持续的资源投入，这些必须借助企业内部相对比较 high level 的管理层的推动，才能最终达成共识并快速落地。如果你所在的公司恰好有这样一位具备前瞻性视角的高层领导，那么恭喜你，你已经获得了 DevOps 转型道路上至关重要的资源。</p><h3 id="通用路径"><a href="#通用路径" class="headerlink" title="通用路径"></a>通用路径</h3><h4 id="第-1-步：寻找合适的试点项目"><a href="#第-1-步：寻找合适的试点项目" class="headerlink" title="第 1 步：寻找合适的试点项目"></a>第 1 步：寻找合适的试点项目</h4><p>一个合适的项目应该具备以下几个特征：</p><ul><li><strong>贴近核心业务</strong>。DevOps 要以业务价值为导向。对于核心业务，管理层的关注度足够高，各项业务指标也相对比较完善，如果改进效果可以通过核心业务指标来呈现，会更有说服力。同时，核心业务的资源投入会有长期保障。毕竟，你肯定不希望 DevOps 转型落地项目因为业务调整而半途而废吧。</li><li><strong>倾向敏捷业务</strong>。敏捷性质的业务需求量和变更都比较频繁，更加容易验证 DevOps 改造所带来的效果。如果一个业务以稳定为主要诉求，整体处于维护阶段，变更的诉求和意愿都比较低，那么这对于 DevOps 而言，就不是一个好的选择。我之前在跟一家军工企业沟通的时候，了解到他们每年就固定上线两次，那么在这种情况下，你说还有没有必要搞 DevOps 呢？</li><li><strong>改进意愿优先</strong>。如果公司内部的团队心比天高，完全瞧不上 DevOps，觉得自己当前的流程是最完美的，那么，你再跟他们费力强调 DevOps 的价值，结果很可能事倍功半。相反，那些目前绩效一般般的团队都有非常强烈的改进诉求，也更加愿意配合转型工作。这时，团队的精力就可以聚焦于做事本身，而不会浪费在反复拉锯的沟通上。</li></ul><h4 id="第-2-步：寻找团队痛点"><a href="#第-2-步：寻找团队痛点" class="headerlink" title="第 2 步：寻找团队痛点"></a>第 2 步：寻找团队痛点</h4><p>所谓痛点，就是当前最影响团队效率的事情，同时也是改进之后可以产生最大效益的事情。</p><p>可以通过<strong>价值流分析活动</strong>来寻找团队痛点。</p><h4 id="第-3-步：快速建立初期成功"><a href="#第-3-步：快速建立初期成功" class="headerlink" title="第 3 步：快速建立初期成功"></a>第 3 步：快速建立初期成功</h4><p>在进行的转型初期，切记不要把面铺得太广，把战线拉得太长。 <strong>首先识别一个改进点，定义一个目标。</strong>比如，环境申请和准备时间过程，那么就可以定义这样一个指标：优化 50% 的环境准备时长。这样一来，团队的目标会更加明确，方便任务的拆解和细化，可以在几周内见到明显的成果。</p><h4 id="第-4-步：快速展示和持续改进"><a href="#第-4-步：快速展示和持续改进" class="headerlink" title="第 4 步：快速展示和持续改进"></a>第 4 步：快速展示和持续改进</h4><p>取得阶段性的成果之后，要及时向管理层汇报，并且在团队内部进行总结。这样，一方面可以增强管理层和团队的信心，逐步加大资源投入；另一方面，也能够及时发现改进过程中的问题，在团队内部形成持续学习的氛围，激发团队成员的积极性，可以从侧面改善团队的文化。</p><p>在这条路径之下，也隐藏着一些可以预见的问题，最典型的就是DevOps 转型的 J 型曲线，这也是在 2018 年 DevOps 状态报告中的一个重点发现。</p><p><img src="/assets/images/ops/devops/image-20200825110138146.png" alt="image-20200825110138146"></p><p>在转型之初，团队需要快速识别出主要问题，并给出解决方案。在这个阶段，整个团队的效能水平比较低，可以通过一些实践引入和工具的落地，快速提升自动化的能力和水平，从而帮助团队获得初期的成功。</p><p>但是，随着交付能力的提升，质量能力和技术债务的问题开始显现。比如，由于大量的手工回归测试，团队难以压缩测试周期，从而导致交付周期陷入瓶颈；项目架构的问题带来的技术债务导致集成问题增多，耦合性太强导致改动牵一发而动全身……</p><p>这个时候，团队开始面临选择：是继续推进呢？还是停滞不前呢？继续推进意味着团队需要分出额外的精力来加强自动化核心能力的预研和建设，比如优化构建时长、提升自动化测试覆盖率等，这些都需要长期的投入，甚至有可能会导致一段时间内团队交付能力的下降。</p><p>与此同时，与组织的固有流程和边界问题相关的人为因素，也会制约企业效率的进一步提升。如何让团队能够有信心减少评审和审批流程，同样依赖于质量保障体系的建设。如果团队迫于业务压力，暂缓 DevOps 改进工作，那就意味着 DevOps 难以真正落地发挥价值，很多 DevOps 项目就是这样“死”掉的。</p><p>在转型初期，建立一个<strong>专职的转型工作小组</strong>还是很有必要的。这个团队主要由 DevOps 转型关联团队的主要负责人、DevOps 专家和外部咨询顾问等牵头组成，一般是各自领域的专家或者资深成员，相当于 DevOps 实施的“大脑”，主要负责制定 DevOps 转型项目计划、改进目标识别、技术方案设计和流程改造等。</p><p><img src="/assets/images/ops/devops/image-20200825110241851.png" alt="image-20200825110241851"></p><blockquote><p>转型小组的团队组成示意图</p></blockquote><h2 id="业务敏捷"><a href="#业务敏捷" class="headerlink" title="业务敏捷"></a>业务敏捷</h2><p>在现在这个多变的时代，没人能够准确地预测需求的价值。所以，交付能力的提升，可以帮助业务以最小的成本进行试错，将新功能快速交付给用户。同时，用户和市场的情况又能够快速地反馈给业务方，从而帮助业务校准方向。而业务的敏捷能力高低，恰恰体现在对功能的设计和需求的把握上，如果不能灵活地调整需求，专注于最有价值的事情，同样会拖累交付能力，导致整体效率的下降。</p><p>也就是说，在这样一种快速迭代交付的模式下，业务敏捷和交付能力二者缺一不可。</p><p><strong>所以开发更少的功能，聚焦用户价值，持续快速验证，就成了产品需求管理的核心思想。</strong></p><h3 id="开发更少的功能"><a href="#开发更少的功能" class="headerlink" title="开发更少的功能"></a>开发更少的功能</h3><p>在把握需求质量的前提下，如何尽可能地减小需求交付批次，采用最小的实现方案，保证高优先级的需求可以快速交付，从而提升上线实验和反馈的频率，就成了最关键的问题。</p><p>关于需求分析，比较常见的方法就是 <strong>影响地图</strong>。</p><p>影响地图是通过简单的“Why-Who-How-What”分析方法，实现业务目标和产品功能之间的映射关系。</p><ul><li>Why 代表目标，它可以是一个核心的业务目标，也可以是一个实际的用户需求。</li><li>Who 代表影响对象，也就是通过影响谁来实现这个目标。</li><li>How 代表影响，也就是怎样影响用户以实现我们的目标。</li><li>What 代表需要交付什么样的功能，可以带来期望的影响。</li></ul><p>如果你是第一次接触影响地图，可能会听起来有点晕。没关系，我给你举个例子，来帮你理解这套分析方法。</p><p>比如，一个专栏希望可以在上线 3 个月内吸引 1 万名用户，那么，这个 Why，也就是最核心的业务目标。为了达成这个目标，需要影响的角色包含哪些呢？其实就包含了作者、平台提供方、渠道方和最终用户。需要对他们施加哪些影响呢？对作者来说，需要快速地回答用户的问题，提升内容的质量；对平台来说，需要对专栏进行重点曝光，增加营销活动；对渠道方来说，需要提高推广力度和渠道引流；对于用户来说，增加分享有礼、免费试读和个人积分等活动。</p><p>那么基于以上这些影响方式，转化为最终的实际需求，就形成了一张完整的影响地图，如下图所示：</p><p><img src="/assets/images/ops/devops/image-20200826104543898.png" alt="image-20200826104543898"></p><p>需求这么多，优先级要怎么安排呢？别急，现在我就给你介绍一下 “<strong>卡诺模型</strong>“。</p><blockquote><p>卡诺模型（Kano Model），是日本大师授野纪昭博士提出的一套需求分析方法，它对理解用户需求，对其进行分类和排序方面有着很深刻的洞察。</p></blockquote><p>卡诺模型将产品需求划分为五种类型：</p><ol><li><p><strong>兴奋型</strong>：指超乎用户想象的需求，是可遇不可求的功能。比如用户想要一个更好的功能手机，乔布斯带来了 iPhone，这会给用户带来极大的满足感。</p></li><li><p><strong>期望型</strong>：用户的满意度会随着这类需求数量的增多而线性增长，做得越多，效果越好，但难以有质的突破。比如，一个电商平台最开始是卖书，后面逐步扩展到卖电脑、家居用品等多个类别。用户更多的线性需求被满足，满意度自然也会提升。</p></li><li><p><strong>必备型</strong>：这些是产品必须要有的功能，如果没有的话，会带来非常大的影响。不过有这些功能的话，也没人会夸你做得有多好，比如安全机制和风控机制等。</p></li><li><p><strong>无差别型</strong>：做了跟没做一样，这就是典型的无用功。比如你花了好大力气做了一个需求，但是几乎没有用户使用，这个需求就属于无差别型。</p></li><li><p><strong>反向型</strong>：无中生有类需求，实际上根本不具备使用条件，或者用户压根不这么想。这类需求做出来以后，通常会给用户带来很大的困扰，成为被吐槽的对象。</p></li></ol><p>对于五类需求来说，核心要做到 3 点：</p><ul><li><strong>优先规划期望型和必备型需求</strong>，将其纳入日常的交付迭代中，保持一定的交付节奏；识别无差别型和反向型需求，这些对于用户来说并没有产生价值。如果团队对需求的分类有争议，可以进一步开展用户调研和分析。</li><li><strong>追求兴奋型需求</strong>，因为它会带来产品的竞争壁垒和差异化。不过，对于大公司而言，经常会遇到创新者的窘境，也就是坚持固有的商业模式，而很难真正投入资源创新和自我</li><li><strong>颠覆</strong>。这就要采用精益创业的思想，采用 MVP（最小可行产品）的思路，进行快速验证，并且降低试错成本，以抓住新的机遇。</li></ul><h3 id="聚焦用户价值"><a href="#聚焦用户价值" class="headerlink" title="聚焦用户价值"></a>聚焦用户价值</h3><p>而<strong>用户故事则是以用户的价值为核心，圈定一种角色，表明通过什么样的活动，最终达到什么样的价值</strong>。团队在讨论需求的时候，采用一种讲故事的形式，代入到设定的用户场景之中，跟随用户的操作路径，从而达成用户的目标，解决用户的实际问题。这样做的好处在于，经过团队的共同讨论和沟通，产品、研发和测试对需求目标可以达成共识，尤其是对想要带给用户的价值达成共识。</p><p>在这个过程中，团队不断探索更好的实现方案和实现路径，并补充关联的用户故事，从而形成完整的待办事项。更重要的是，团队成员逐渐培养了用户和产品思维，不再拘泥于技术实现本身，增强了彼此之间的信任，积极性方面也会有所改善，从而提升整个团队的敏捷性。用户故事的粒度同样需要进行拆分，拆分的原则是针对一类用户角色，交付一个完整的用户价值，也就是说用户故事不能再继续拆分的粒度。当然，在实际工作中，拆分的粒度还是以迭代周期为参考，在一个迭代周期内交付完成即可，一般建议是 3～5 天。检验用户故事拆分粒度是否合适，可以遵循 <strong>INVEST 原则</strong>。</p><ul><li><p><strong>Independent（独立的）</strong>：减少用户故事之间的依赖，可以让用户故事更加灵活地验证和交付，而避免大批量交付对于业务敏捷性而言至关重要。</p></li><li><p><strong>Negotiable（可协商的）</strong>：用户故事不应该是滴水不漏、行政命令式的，而是要抛出一个场景描述，并在需求沟通阶段不断细化完成。</p></li><li><p><strong>Valuable（有价值的）</strong>：用户故事是以用户价值为核心的，所以每个故事都是在对用户交付价值，所以要站在用户的视角思考问题，避免像最近特别火的那句话一样：“我不要你觉得，我要我觉得。”</p></li><li><p><strong>Estimatable（可评估的）</strong>：用户故事应该可以粗略评估工作量，无论是故事点数还是时间，都可以。如果是一个预研性质的故事，则需要进一步深挖可行性，避免不知道为什么做而做。</p></li><li><p><strong>Small（小的）</strong>：用户故事应该是最小的交付颗粒度，所以按照敏捷开发方式，无论迭代还是看板，都需要在一个交付周期内完成。</p></li><li><p><strong>Testable（可测试的）</strong>：也就是验收条件，如果没有办法证明需求已经完成，也就没有办法进行验收和交付。</p></li></ul><h3 id="持续快速验证"><a href="#持续快速验证" class="headerlink" title="持续快速验证"></a>持续快速验证</h3><p><strong>需求的价值难以预测，但是需求的价值却可以定义。</strong></p><p>需求价值的定义，可以理解为需求价值的度量，分为客观指标和主观 2 个方面。</p><ul><li>客观指标：也就是客观数据能够表明的指标，比如对电商行业来说，可以从购买流程角度，识别商品到达率、详情到达率、加入购物车率、完成订单率等等；</li><li>主观指标：也就是用户体验、用户满意度、用户推荐率等等，无法直接度量，只能通过侧面数据关联得出。</li></ul><p>但是无论是客观指标，还是主观指标，每一个需求在提出的时候，可以在这些指标中选择需求上线后的预期，并定义相关的指标。一方面加强价值导向，让产品交付更有价值的需求，另外一方面，也强调数据导向，尽量客观地展现实际结果。</p><p>从技术层面来说，一个业务需求的背后，一般都会关联一个埋点需求。所谓埋点分析，是网站分析的一种常用的数据采集方法。设计良好的埋点功能，不仅能帮助采集用户操作行为，还能识别完整的上下文操作路径，甚至进行用户画像的聚类和分析，帮助识别不同类型用户的行为习惯。从用户层面来说，众测机制和用户反馈渠道是比较常见的两种方式，核心就是既要听用户怎么说，也要看用户怎么做。</p><p>最后，引入业务的 DevOps，就成了 BizDevOps。 BizDevOps 的核心理念：</p><ul><li>对齐业务和开发目标、指标；</li><li>把握安全、合规指标；</li><li>及时对齐需求，减少无用开发；</li><li>体现 DevOps 的价值；</li><li>让开发团队开始接触业务，不单单是执行，调动积极性。</li></ul><h2 id="精益看板"><a href="#精益看板" class="headerlink" title="精益看板"></a>精益看板</h2><p>如果没有在制品限制的拉动系统，只能说是一个可视化系统，而不是看板系统，这一点非常重要。</p><p>加快价值流动是精益看板的核心。在软件开发中，这个价值可能是一个新功能，也可能是缺陷修复，体验优化。根据利特尔法则，我们知道：平均吞吐率 = 在制品数量 / 平均前置时间。其中，在制品数量就是当前团队并行处理的工作事项的数量。</p><p>在<strong>制品数量会影响前置时间，并行的任务数量越多，前置时间就会越长</strong>，也就是交付周期变长，这显然不是理想的状态。</p><p>不仅如此，前置时间还会影响交付质量，前置时间增长，则质量下降。</p><p><strong>精益看板的实践方法</strong>分为了五个步骤。</p><ul><li>第一步：可视化流程；</li><li>第二步：定义清晰的规则；</li><li>第三步：限制在制品数量；</li><li>第四步：管理工作流程；</li><li>第五步：建立反馈和持续改进。</li></ul><h3 id="可视化流程"><a href="#可视化流程" class="headerlink" title="可视化流程"></a>可视化流程</h3><p>在最开始，我们只需要忠实客观地把这个现有流程呈现出来就可以了，而无需对现有流程进行优化和调整。也正因为如此，看板方法的引入初期给组织带来的冲击相对较小，不会因为剧烈变革引起组织的强烈不适甚至是反弹。所以，看板方法是一种相对温和的渐进式改进方法。</p><p>看板的主要构成元素可以简单概括成“<strong>一列一行</strong>”。</p><p><strong>一列</strong>是指看板的竖向队列，是按照价值流转的各个主要阶段进行划分的，比如常见的需求、开发、测试、发布等。</p><p>竖向队列划分的标准主要有两点：</p><ul><li><strong>是否构成一个独立的环节。</strong>比如对于前后端分离的开发来说，前端开发和后端开发就是两个独立的环节，一般由不同的角色负责，这种就比较适合独立阶段。</li><li><strong>是否存在状态的流转和移交。</strong>看板是驱动上下游协同的信号卡，所以，我们需要重点关注存在上下游交付和评审的环节，这也是提示交付吞吐率和前置时长的关键节点。</li></ul><p>除此之外，看板的设计需要定义明确的起点和终点。对于精益看板来说，覆盖端到端的完整价值交付环节是比较理想的状态。</p><p><img src="/assets/images/ops/devops/image-20200827100321071.png" alt="image-20200827100321071"></p><p><strong>一行</strong>是指看板横向的泳道。泳道用于<strong>需求与需求之间划清界限</strong>，尤其在使用物理看板的时候，经常会因为便利贴贴的位置随意等原因导致混乱，而定义泳道就可以很好地解决这个问题。</p><p><img src="/assets/images/ops/devops/image-20200827100514357.png" alt="image-20200827100514357"></p><h3 id="定义清晰的规则"><a href="#定义清晰的规则" class="headerlink" title="定义清晰的规则"></a>定义清晰的规则</h3><p>沟通的成本甚至要大于工作的成本。而规则可以大大地降低团队成员之间的沟通成本，统一团队的沟通语言，形成团队成员之间的默契。看板的规则包含两个方面，一个是可视化规则，另一个是显式化规则，我分别来介绍一下。</p><ul><li><p>可视化规则。</p><p>看板中的主要构成元素是“一列一行”。实际上，看板中卡片的设计也有讲究，主要有 3 点。</p><ul><li><strong>卡片的颜色</strong>：用于区分不同的任务类型，比如需求（绿色）、缺陷（红色）和改进事项（蓝色）；</li><li><strong>卡片的内容</strong>：用于显示任务的主要信息，比如电子看板 ID 号，需求的名称、描述、负责人、预估工作量和停留时长等；</li><li><strong>卡片的依赖和阻塞状态</strong>：用于提起关注，比如在卡片上通过张贴不同的标志，表示当前卡片的健康程度，对于存在依赖和阻塞状态的卡片，需要团队高优先级协调和处理。这样一来，看板就显得主次分明啦。</li></ul></li><li><p>显式化规则。</p><p>看板除了要让人看得懂，还要让人会操作，这一点非常重要。</p><ul><li>谁来负责整理和移动卡片？</li><li>什么时间点进行卡片操作？</li><li>卡片的操作步骤是怎样的？（比如，卡片每停留一天需要做一次标记。）</li><li>什么时候需要线下沟通？（比如缺陷和阻塞）</li><li>哪些标识代表当前最高优先级的任务？</li><li>看板卡片的填充规则是怎样的？</li><li>谁来保障线下和线上看板的状态一致性？</li></ul></li></ul><h3 id="限制在制品数量"><a href="#限制在制品数量" class="headerlink" title="限制在制品数量"></a>限制在制品数量</h3><p><strong>应用看板方法只能暴露团队的现有问题，而不能解决团队的现有问题。</strong></p><p><strong>看板方法的好处在于，通过降低在制品数量，可以将这些潜在的问题逐步暴露出来。</strong></p><p>限制在制品数量有两个关键节点：一个是需求流入节点，一个是需求交付节点。</p><ul><li><p><strong>需求流入节点</strong></p><p>根据需求的优先级限制并行任务数量。</p></li><li><p><strong>需求交付节点</strong></p><p>关键在于加速需求的流出。</p></li></ul><h3 id="管理工作流程"><a href="#管理工作流程" class="headerlink" title="管理工作流程"></a>管理工作流程</h3><p>需要配套的管理流程，来保障看板机制的顺畅运转。在看板方法中，常见的有三种会议，分别是每日站会、队列填充会议和发布规划会议。</p><ol><li><p><strong>每日站会。</strong></p><p>与 Scrum 方法的“夺命三连问”（昨天做了什么？今天计划做什么？有什么困难或者阻塞？）不同，看板方法更加关注两点：<br><strong>待交付的任务。</strong>看板追求价值的快速流动，所以，对于在交付环节阻塞的任务，你要重点关注是什么原因导致的。<br><strong>紧急、缺陷、阻塞和长期没有更新的任务。</strong>这些任务在规则中也有相应的定义，如果出现了这些问题，团队需要最高优先级进行处理。这里有一个小技巧，就是当卡片放置在看板之中时，每停留一天，卡片的负责人就会手动增加一个小圆点标记，通过这个标记的数量，就可以看出哪些任务已经停留了太长时间。而对于使用电子看板的团队来说，这就更加简单了。比如，Jira 本身就支持停留时长的显示。当然，你也可以自建过滤器，按照停留时长排序，重点关注 Top 问题的情况。</p><p>每日站会要尽量<strong>保持高效</strong>，对于一些存在争议的问题，或者是技术细节的讨论，可以放在会后单独进行</p></li><li><p><strong>队列填充会议。</strong></p><p>队列填充会议的目标有两点：<strong>一个是对任务的优先级进行排序</strong>，<strong>一个是展示需求开发的状态</strong>。一般情况下，队列填充会议需要业务方、技术方和产品项目负责人参与进来，对需求的优先级达成一致，并填充到看板的就绪状态中。</p></li><li><p><strong>发布规划会议</strong>。</p><p>发布规划会议以最终交付为目标。一般情况下，项目的交付节奏会影响队列填充的节奏，二者最好保持同步。另外，随着部署和发布的分离，研发团队越来越趋近于持续开发持续部署，而发布由业务方统一规划把控，发布规划会议有助于研发团队和业务方的信息同步，从而实现按节奏部署和按需发布的理想状态。</p></li></ol><h3 id="建立反馈和持续改进"><a href="#建立反馈和持续改进" class="headerlink" title="建立反馈和持续改进"></a>建立反馈和持续改进</h3><p>实际上，无论是 DevOps 还是精益看板，任何一套方法框架的终点都是持续改进。因为，作为一种新的研发思想和研发方法，只有结合业务实际，并根据自身的情况持续优化规则、节奏、工具和流程，才能更好地为业务服务。</p><p>看板方法的实践是一个循序渐进的过程。为此看板创始人 David J Anderson 总结了看板方法的成熟度模型，用于指导中大型团队实践看板方法，如下图所示：</p><p><img src="/assets/images/ops/devops/KMM-Image.png" alt="img"></p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>配置管理的四个核心理念： <strong>版本变更标准化，将一切纳入版本控制，全流程可追溯和单一可信数据源。</strong></p><h3 id="1-版本变更标准化"><a href="#1-版本变更标准化" class="headerlink" title="1. 版本变更标准化"></a>1. 版本变更标准化</h3><p>版本控制是配置管理中的一个非常核心的概念，而对于软件来说，最核心的资产就是源代码。</p><p>配置管理中的另一个核心概念是<strong>变更</strong>。我们对软件做的任何改变都可以称之为一次变更，比如一个需求，一行代码，甚至是一个环境配置。<strong>版本来源于变更</strong>。对于变更而言，核心就是要记录：<strong>谁，在什么时间，做了什么改动，具体改了哪些内容，又是谁批准的。</strong></p><p>用好版本控制系统也需要有一套规则和行为规范。比如，版本控制系统需要打通公司的统一认证系统，也就是任何人想要访问版本控制系统，都需要经过公司统一登录的认证。同时，在使用 Git 的时候，你需要正确配置本地信息，尤其是用户名和邮箱信息，这样才能在提交时生成完整的用户信息。另外，系统本身也需要增加相关的校验机制，避免由于员工配置错误导致无效信息被提交入库。</p><p>软件改动说明一般就是版本控制系统的提交记录，一个完整的提交记录应该至少包括以下几个方面的内容：</p><ul><li>提交概要信息：简明扼要地用一句话说明这个改动实现了哪些功能，修复了哪些问题；</li><li>提交详细信息：详细说明改动的细节和改动方式，是否有潜在的风险和遗留问题等；</li><li>提交关联需求：是哪次变更导致的这次提交修改，还需要添加上游系统编号以关联提交和原始变更。</li></ul><p>一套标准化的规则和行为习惯，可以降低协作过程中的沟通成本，一次性把事情做对，这也是标准和规范的重要意义。</p><p><strong>标准化是自动化的前提，自动化又是 DevOps 最核心的实践。</strong></p><h3 id="2-将一切纳入版本控制"><a href="#2-将一切纳入版本控制" class="headerlink" title="2. 将一切纳入版本控制"></a>2. 将一切纳入版本控制</h3><p>软件源代码、配置文件、测试编译脚本、流水线配置、环境配置、数据库变更等等，你能想到的一切，皆有版本皆要被纳入管控。</p><p>这是因为，软件本身就是一个复杂的集合体，任何变更都可能带来问题，所以，全程版本控制赋予了我们全流程追溯的能力，并且可以快速回退到某个时间点的版本状态，这对于定位和修复问题是非常重要的。</p><p><strong>如果这个产物可以通过其他产物来重现，那么就可以作为制品管理，而无需纳入版本控制。</strong>如软件包可以通过源代码和工具重新打包生成，那么，代码、工具和打包环境就需要纳入管控，而生成的软件包可以作为制品。</p><h3 id="3-全流程可追溯"><a href="#3-全流程可追溯" class="headerlink" title="3. 全流程可追溯"></a>3. 全流程可追溯</h3><p>在出现问题时，就要追溯当时的全部数据，像软件源代码、测试报告、运行环境等等。</p><p>对于配置管理来说，除了追溯能力以外，还有一个重要的价值，就是记录关联和依赖关系。</p><h3 id="4-单一可信数据源"><a href="#4-单一可信数据源" class="headerlink" title="4. 单一可信数据源"></a>4. 单一可信数据源</h3><p>对于软件开发来说，必须要有统一的管控：</p><ul><li>对于代码来说，要有统一的版本控制系统，不能代码满天飞；</li><li>对于版本来说，要有统一的渠道，不能让人随便本地打个包就传到线上去了；</li><li>对于开发依赖的组件来说，要有统一的源头，不能让来路不明的组件直接集成到系统中。这不仅对于安全管控来说至关重要，对于企业内部的信息一致性也是不可或缺的。</li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支策略就是软件协作模式和发布模式的风向标。</p><h3 id="主干开发，分支发布"><a href="#主干开发，分支发布" class="headerlink" title="主干开发，分支发布"></a>主干开发，分支发布</h3><p>在这种分支策略下，开发团队共享一条主干分支，所有的代码都直接提交到主干分支上，主干分支就相当于是一个代码的全量合集。在软件版本发布之前，会基于主干拉出一条以发布为目的的短分支。</p><p><img src="/assets/images/ops/devops/wiybm_tbd.png" alt="img"></p><p>需要注意的两点：</p><ul><li><p><strong>以发布为目的。</strong>这条分支存在的意义不是开发新功能，而是对现有功能进行验收，并在达到一定的质量标准后对外发布</p></li><li><p><strong>短分支。</strong>这条发布分支一般不会存在太长时间，只要经过回归验证，满足发布标准后，就可以直接对外发布，这时，这条分支的历史使命也就结束了。只要在主干分支和发布分支并行存在的时间段内，所有发布分支上的改动都需要同步回主分支，这也是我们不希望这条分支存在时间过长的原因，因为这会导致重复工作量的线性累计。</p></li></ul><p>优势：</p><ol><li>对于研发团队来说，只有一条主线分支，不需要在多条分支间切换。</li><li>在发布分支拉出之后，主干分支依然处于可集成状态，研发节奏可以保持在一个相对平稳的状态。</li><li>发布分支一般以版本号命名，清晰易懂，线上哪个版本出了问题，就在哪个分支上修复。</li></ol><p>缺点：</p><ol><li><strong>它对主线分支的质量要求很高。</strong>如果主线分支出了问题，就会 block 所有开发团队的工作。对于一个百人团队、每日千次的提交规模来说，如果不对提交加以约束，这种情况的发生频率就会非常高。</li><li><strong>它对团队协作的节奏要求很高。</strong>如果主线分支上的功能没有及时合入，但是业务方又坚持要在指定版本上线这个功能，这就会导致发布分支“难产”。甚至有些时候，会被迫允许部分未开发完成的功能在发布分支上继续开发，这会给发布分支的质量和稳定性造成很大的挑战。</li><li><strong>在主线和发布分支并存期间，有可能会导致两边提交不同步的情况。</strong>比如，发布分支修复了一个线上问题，但是由于没有同步回主线，导致同样的问题在下一个版本中复现。测试出来的问题越多，这种情况出现的概率就越大，更不要说多版本并存的情况了。</li></ol><p>这些问题的解决方法包括以下几点：</p><ol><li>建立提交的准入门禁，不允许不符合质量标准的代码合入主线。</li><li>采用版本火车的方式，加快版本的迭代速度，功能“持票上车”，如果跟不上这个版本就随下个版本上线。另外，可以采用功能开关、热修复等手段，打破版本发布的固定节奏，以一种更加灵活的方式对外发布。</li><li>通过自动化手段扫描主线和发布分支的差异，建立一种规则。比如 Hotfix 必须主线和发布分支同时提交，或者发布分支上线后，由专人反向同步等</li></ol><h3 id="分支开发，主干发布"><a href="#分支开发，主干发布" class="headerlink" title="分支开发，主干发布"></a>分支开发，主干发布</h3><p>当开发接到一个任务后，会基于主干拉出一条特性开发分支，在特性分支上完成功能开发验证之后，通过 Merge request 或者 Pull request 的方式发起合并请求，在评审通过后合入主干，并在主干完成功能的回归测试</p><p><img src="/assets/images/ops/devops/wiybm_slfb.png" alt="img"></p><p>根据特性和团队的实际情况，还可以进一步细分为两种情况：</p><ul><li>每条特性分支以特性编号或需求编号命名，在这条分支上，只完成一个功能的开发；</li><li>以开发模块为单位，拉出一条长线的特性分支，并在这条分支上进行开发协作。</li></ul><p><strong>两者的区别就在于特性分支存活的周期，拉出时间越长，跟主干分支的差异就越大，分支合并回去的冲突也就越大。</strong>所以，对于长线模式来说，要么是模块拆分得比较清晰，不会有其他人动这块功能，要么就是保持同主干的频繁同步。<strong>随着需求拆分粒度的变小，短分支的方式其实更合适。</strong></p><p><strong>优点：</strong></p><ul><li>分支开发相对比较独立，不会因为并行导致互相干扰。同时，特性只有在开发完成并验收通过后才会合入主干，对主干分支的质量起到了保护作用；</li><li>随着特性分支的流行，在这种模式下，分支成了特性天然的载体。一个特性所关联的所有代码可以保存在一条特性分支上，这为以特性为粒度进行发布的模式来说提供了一种新的可能性。也就是说，如果你想要发布哪个特性，就可以直接将特性分支合并到发布分支上，这就让某一个特性变得“可上可下”，而不是混在一大堆代码当中，想拆也拆不出来。</li></ul><p>特性发布虽然看起来很好，但是有三个前置条件：第一个是特性拆分得足够小，第二是有强大的测试环境作支撑，可以满足灵活的特性组合验证需求，第三是要有一套自动化的特性管理工具。</p><p>缺点：</p><ol><li>非常考验团队特性拆分的能力。如果一个特性过大，会导致大量并行开发的分支存在，分支的集成周期拉长，潜在的冲突也会增多。另外，分支长期存在也会造成跟主线差异过大的问题。所以，特性的粒度和分支存活的周期是关键要素。根据经验来看，分支存活的周期一般不要超过一周。</li><li>对特性分支的命名规范要求很高。由于大量特性分支的拉出，整个代码仓库会显得非常乱。面对一大堆分支，谁也说不清到底哪个还活着，哪个已经没用了。所以，如果能够跟变更管理系统打通，自动化创建分支就最好了。</li><li>特性分支的原子性和完整性，保证一个特性的关联改动需要提交到一条分支上，而不是到处都是。同时，特性分支上的提交也需要尽量清晰，典型的就是原子性提交。</li></ol><h3 id="主干开发，主干发布"><a href="#主干开发，主干发布" class="headerlink" title="主干开发，主干发布"></a>主干开发，主干发布</h3><p>团队只有一条分支，开发人员的代码改动都直接集成到这条主干分支上，同时，软件的发布也基于这条主干分支进行。</p><p><img src="/assets/images/ops/devops/wiybm_cd.png" alt="img"></p><p>Facebook 最早采用的也是主干开发、分支发布的策略，每天固定发布两次。但是，随着业务发展的压力增大，团队对于发布频率有了更高的要求，这种分支策略已经无法满足每天多次发布的需求了。于是，他们开始着手改变分支策略，从主干开发、分支发布的模式，演变成了主干开发、主干发布的模式。</p><p>为了保证主干分支的质量，自动化验收手段是必不可少的，因此，每一次代码提交都会触发完整的编译构建、单元测试、代码扫描、自动化测试等过程。在代码合入主干后，会进行按需发布，先是发布到内部环境，也就是只有 Facebook 的员工才能看到这个版本，如果发现问题就立刻修复，如果没有问题，再进一步开放发布给 2% 的线上生产用户，同时自动化检测线上的反馈数据。直到确认一切正常，才会对所有用户开放。</p><p>最后，通过分支策略和发布策略的整合，注入自动化质量验收和线上数据反馈能力，最终将发布频率从固定的每天 2 次，提升到每天多次，甚至实现了按需发布的模式。Facebook最新的分支策略如图所示：</p><p><img src="/assets/images/ops/devops//GIYNPgGn5SctXdIGAAAAAAAkALkybj0JAAAB.jpg" alt="img"></p><p><strong>推荐： 主干开发结合特性分支的模式</strong></p><p>团队共享一条开发主干，特性开发基于主干拉出特性分支，快速开发验收并回归主干，同时，在特性分支和主干分别建立不同的质量门禁和自动化验收能力。</p><p>这样做的好处在于，可以加快代码集成频率，特性相对独立清晰，并且主干分支又可以保持一定的质量水平。不过，在执行的过程中，你需要遵守以下原则：</p><ol><li>团队共享一条主干分支；</li><li>特性分支的存活周期要尽量短，最好不要超过 3 天；</li><li>每天向主干合并一次代码，如果特性分支存在超过 1 天，那么每天都要同步主干代码；</li><li>谨慎使用功能开关等技术手段，保持代码干净和历史清晰；</li><li>并行分支越少越好，如果可能的话，尽量采用主干发布。</li></ol><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>CI 是 Continuous Integration 的缩写，也就是我们熟悉的持续集成，顾名思义，这里面有两个关键的问题：集成什么东西？为什么要持续？要回答这两个问题，就得从 CI 诞生的历史说起了。</p><p>CI 本身源于肯特·贝克（Kent Beck）在 1996 年提出的极限编程方法（ExtremeProgramming，简称 XP）。顾名思义，极限编程是一种软件开发方法，作为敏捷开发的方法之一，目的在于通过缩短开发周期，提高发布频率来提<br>升软件质量，改善用户需求响应速度。</p><p>关于 CI 的定义，我在这里引用一下马丁·福勒（Martin Fowler）的一篇博客中的内容，这也是当前最为业界公认的定义之一：</p><blockquote><p> CI 是一种软件开发实践，团队成员频繁地将他们的工作成果集成到一起（通常每人每天至少提交一次，这样每天就会有多次集成），并且在每次提交后，自动触发运行一次包含自动化验证集的构建任务，以便尽早地发现集成问题。</p></blockquote><p>践行 CI的三个问题：</p><ol><li><p>每一次代码提交，是否都会触发一次完整的流水线？</p></li><li><p>每次流水线是否会触发自动化的测试环节？</p></li><li><p>如果流水线出现了问题，是否能够在 10 分钟之内修复？</p></li></ol><h3 id="第一阶段：每次提交触发完整的流水线"><a href="#第一阶段：每次提交触发完整的流水线" class="headerlink" title="第一阶段：每次提交触发完整的流水线"></a>第一阶段：每次提交触发完整的流水线</h3><p>第一个阶段的关键词是：<strong>快速集成</strong>。这是对 CI 核心理念的最好诠释，也就是集成速度做到极致，每次变更都会触发 CI。</p><p>如果想做到每次提交都触发持续集成的话，首先就需要打通版本控制系统和持续集成系统</p><p>实施提交触发流水线，还需要一些前置条件。</p><ol><li><p>统一的分支策略。</p><p>​    既然 CI 的目的是集成，那么首先就需要有一条以集成为目的的分支。这条分支可以是研发主线，也可以是专门的集成分支，一旦这条分支上发生任何变更，就会触发相应的 CI 过程。</p></li><li><p>清晰的集成规则。</p><p>​    对于研发特性分支而言，目的主要是快速验证和反馈，那么速度就是不可忽视的因素，所以这个层面的持续集成，主要以验证打包和代码质量为主；而对于系统集成分支而言，它的目的不仅是验证打包和代码质量，还要关注接口和业务层面的正确性，所以集成的步骤会更加复杂，成本也会随之上升。所以，根据分支策略选择合适的集成规则，对于 CI的有效运转来说非常重要。</p></li><li><p>标准化的资源池。</p><p>​    首先，资源池需要实现环境标准化，也就是任何任务在任何节点都具备可运行的能力，这个能力就包括了工具、配置等一系列要素。如果 CI 任务在一个节点可以运行，跑到另外一个节点就运行失败，那么 CI 的公信力就会受到影响。<br>​    另外，资源池的并发吞吐量应该可以满足集中提交的场景，可以动态按需初始化的资源池就成了最佳选择。当然，同时还要兼顾成本因素，因为大量资源的投入如果没有被有效利用，那么造成的浪费是巨大的。</p></li><li><p>足够快的反馈周期。</p><p>​    越是初级 CI，对速度的敏感性就越强。一般来讲，如果 CI 环节超过 10～15 分钟还没有反馈结果，那么研发人员就会失去耐心，所以 CI 的运行速度是一个需要纳入监控的重要指标。对于不同的系统而言，要约定能够容忍的 CI 最大时长，如果超过这个时长，同样会导致 CI 失败。所以，这就需要环境、平台、开发团队共同维护。</p></li></ol><h3 id="第二阶段：每次流水线触发自动化测试"><a href="#第二阶段：每次流水线触发自动化测试" class="headerlink" title="第二阶段：每次流水线触发自动化测试"></a>第二阶段：每次流水线触发自动化测试</h3><p>第二个阶段的关键词是：<strong>质量内建</strong>。实际上，CI 的目的是尽早发现问题，这些问题既包括构建失败，也包括质量不达标，比如测试不通过，或者代码规约静态扫描等不符合标准。</p><ol><li><p>匹配合适的测试活动。</p><p>​    对于不同层级的 CI 而言，同样需要根据集成规则来确定需要注入的质量活动。比如，最初级的提交集成就不适合那些运行过于复杂、时间太长的测试活动，快速的代码检查和冒烟测试就足以证明这个版本已经达到了最基本的要求。而对于系统层的集成来说，质量要求会更高，这样一来，一些接口测试、UI 测试等就可以纳入到 CI 里面来。</p></li><li><p>树立测试结果的公信度。</p><p>​    自动化测试的目标是帮助研发提前发现问题，但是，如果因为自动化测试能力自身的缺陷或者环境不稳定等因素，造成了 CI 的大量失败，那么，这个 CI 对于研发来说就可有可无了。所以，我们要对 CI 失败进行分类分级，重点关注那些异常和误报的情况，并进行相应的持续优化和改善。</p></li><li><p>提升测试活动的有效性。</p><p>考虑到 CI 对于速度的敏感性，那么如何在最短的时间内运行最有效的测试任务，就成了一个关键问题。显然，大而全的测试套件是不合时宜的，只有在基础功能验证的基础上，结合与本次 CI 的变更点相关的测试任务，发现问题的概率才会大大提升。所以，根据 CI 变更，自动识别匹配对应的测试任务也是一个挑战。</p></li></ol><h3 id="第三阶段：出了问题可以在第一时间修复"><a href="#第三阶段：出了问题可以在第一时间修复" class="headerlink" title="第三阶段：出了问题可以在第一时间修复"></a>第三阶段：出了问题可以在第一时间修复</h3><p>利用现有的开源工具和框架快速搭建一套 CI 平台并不困难，<strong>真正让 CI 发挥价值的关键，还是在于团队面对持续集成的态度，以及团队内是否建立了持续集成的文化。</strong></p><p>在CI 的修复时间中，<strong>人不是关键，建立机制才是关键。</strong></p><p>什么是机制呢？<strong>机制就是一种约定，人们愿意遵守这样的行为，并且做了会得到好处。</strong>对于CI 而言，保证集成主线的可用性，其实就是团队成员间的一种约定。这不在于谁出的问题谁去修复，而在于我们是否能够保证 CI 的稳定性，足够清楚问题的降级路径，并且主动关注、分析和推动问题解决。</p><p>另外，团队要建立清晰的规则，比如 10 分钟内没有修复则自动回滚代码，比如当 CI“亮红灯”的时候，团队不再提交新的代码，因为在错误的基础上没有办法验证新的提交，这时需要集体放下手中的工作，共同恢复 CI 的状态。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>自动化测试要解决什么问题？</p><p>产品交付速度的提升，给测试工作带来了很大的挑战。一方面，测试时间被不断压缩，以前三天的测试工作要在一天内完成。另一方面，需求的变化也给测试工作的开展带来了很大的不确定性。这背后核心的问题是，<strong>业务功能的累加导致测试范围不断扩大，但这跟测试时长的压缩是矛盾的。</strong>说白了，就是要测试的内容越来越多，但是测试的时间却越来越短。</p><p>要想提升测试效率，自然就会联想到自动化手段。</p><p>自动化测试适用于以下几种典型场景：</p><ol><li>有大量机械的重复操作，并且会反复执行的场景，比如批量的回归测试；</li><li>有明确的设计规范且相对稳定的场景，比如接口测试；</li><li>大批量、跨平台的兼容性测试，比如覆盖多种版本和多种机型的测试，几十个机型还可以接受，如果覆盖成百上千个机型，就只能依靠自动化了；</li><li>长时间不间断执行的测试，比如压力测试、可用性测试等。</li></ol><p>自动化测试建设也面临着一些问题:</p><ol><li><p>投入产出比：很多需求基本上只会上线一次（比如促销活动类需求），那么，实现自动化测试的成本要比手动测试高得多，而且以后也不会再用了，这显然有点得不偿失。</p></li><li><p>上手门槛：自动化测试依赖代码方式实现，要开发一套配置化的测试框架和平台，对架构设计和编码能力都有很大的要求。但是，测试人员的编码能力一般相对较弱。</p></li><li><p>维护成本高：无论是测试环境、测试用例还是测试数据，都需要随着需求的变化不断进行调整，否则就很容易因为自动化测试过时，导致执行失败。</p></li><li><p>测试设备投入高：比如，移动 App 的测试需要有大量的手机资源，想要覆盖所有的手机型号、操作系统版本，本身就不太现实。更何况，有限的机器还经常被测试人员拿去做本地调试，这就进一步加剧了线上测试没有可用资源的情况。</p></li></ol><h3 id="自动化测试的设计"><a href="#自动化测试的设计" class="headerlink" title="自动化测试的设计"></a>自动化测试的设计</h3><p>介绍一下经典的测试三角形。这个模型描述了从单元测试、集成测试到 UI测试的渐进式测试过程。越是靠近底层，用例的执行速度就越快，维护成本也越低。而在最上层的 UI 层，执行速度要比单元测试和接口测试要慢，比手工测试要快，相应的维护成本要远高于单元测试和接口测试</p><p><img src="/assets/images/ops/devops/image-20200902103530850.png" alt="image-20200902103530850"></p><p>这样看来，从靠近底层的单元测试入手是一个投入产出相对比较高的选择。但实际上，单元测试的执行情况因公司而异，有的公司能做到 80% 的覆盖率，但有的公司却寸步难行。毕竟，单元测试更多是由开发主导的，开发领导的态度就决定了运行的效果。但不可否认的是，单元测试还是非常必要的，尤其是针对核心服务，比如核心交易模块的覆盖率。当然，好的单元测试需要研发投入大量的精力。</p><p>对于 UI 层来说，执行速度和维护成本走向了另外一个极端，这也并不意味着就没有必要投入 UI 自动化建设。<strong>UI 层是唯一能够模拟用户真实操作场景的端到端测试</strong>，页面上的一个按钮可能触发内部几十个函数调用，和单元测试每次只检查一个函数的逻辑不同，UI 测试更加关注模块集成后的联动逻辑，<strong>是集成测试最有效的手段。</strong></p><p>在实际应用中，UI 自动化可以帮助我们节省人工测试成本，提高功能测试的测试效率。不过，它的缺点也是比较明显的：<strong>随着敏捷迭代的速度越来越快，UI 控件的频繁变更会导致控件定位不稳定，提高了用例脚本的维护成本。</strong></p><p>对于基于 Web 的应用来说，我更推荐椭圆形模型，也就是以中间层的 API接口测试为主，以单元测试和 UI 测试为辅。你可以参考一下分层自动化测试模型图。</p><p><img src="/assets/images/ops/devops/image-20200902104308158.png" alt="image-20200902104308158"></p><h3 id="自动化测试的开发"><a href="#自动化测试的开发" class="headerlink" title="自动化测试的开发"></a>自动化测试的开发</h3><p>有效的自动化测试离不开工具和平台的支持。以接口测试为例，最早都是通过 cURL、Postman、JMeter 等工具单机执行的。但是，一次成功的接口测试，除了能够发起服务请求之外，还需要前置的测试数据准备和后置的测试结果校验。对于企业的实际业务来说，不仅需要单接口的执行，还需要相对复杂的多接口，而且带有逻辑的执行，这就依赖于调用接口的编排能力，甚至是内建的 Mock 服务。</p><p>不仅如此，测试数据、用例、脚本的管理，测试过程中数据的收集、度量、分析和展示，以及测试报告的发送等，都是一个成熟的自动化测试框架应该具备的功能。</p><h3 id="自动化测试结果分析"><a href="#自动化测试结果分析" class="headerlink" title="自动化测试结果分析"></a>自动化测试结果分析</h3><p>那么，我们该如何衡量自动化测试的结果呢？当前比较常用的方式是覆盖率，不过问题是，测试覆盖率提升就能发现更多的缺陷吗？</p><p>在实际项目中，手工测试发现的缺陷数量要比自动化测试发现的缺陷数量多得多。自动化测试更多是在帮助守住软件质量的底线，尤其是应用在回归测试中，自动化测试可以确保工作正常的已有功能不会因为新功能的引入而带来质量回退。可以这么说，<strong>如果自动化测试覆盖率足够高，那么软件质量一定不会差到哪儿去。</strong></p><p>关于测试误报，是指由于非开发代码变更导致的自动化测试用例执行失败的情况。业界对于误报率的普遍定义是：</p><blockquote><p> 自动化测试误报率 = 非开发变更引入的问题用例数量 / 测试失败的用例数量</p></blockquote><p><strong>测试误报率是体现自动化测试稳定性的一个核心指标。</strong>对于不同测试类型和产品形态，误报的的原因有很多。比如测试环境的网络不稳定导致的连接超时、测试脚本和测试工具本身的固有缺陷导致的执行失败、测试数据不齐备、测试资源不可用等等。</p><p>如何解决自动化测试并给出了测试结果，但还是需要人工审查判断之后，才能将真正的问题上报缺陷系统的问题？这就要依赖于自动化测试结果的分析啦。</p><ol><li><p>对自动化测试的问题进行分类。你要弄清楚一次失败是环境问题、网络问题、功能变更，还是系统缺陷？你需要将失败的用例归纳到这些分类之中。当一个类别的问题非常多的时候，你可以考虑进行拆分，比如网络问题，你可以拆分为网络不可达、延迟超时、域名解析错误等等。</p></li><li><p>增加已有分类的自动识别能力。比如，对于捕获到的常见异常，可以根据异常信息自动上报到对应的错误分类，从而简化人工识别和归类错误的工作量。</p></li><li><p>提升自动化测试工具和环境的健壮性，对已知问题增加一定的重试机制。</p></li><li><p>持续积累和丰富错误分类，有针对性地开展改进工作，从而不断提升自动化测试的稳定性。</p></li></ol><h2 id="内建质量"><a href="#内建质量" class="headerlink" title="内建质量"></a>内建质量</h2><p><strong>不应该将质量依赖于检验工作，因为检验工作既昂贵，又不可靠。最重要的是，检验工作并不直接提升产品质量，只是为了证明质量有缺陷。</strong>而正确的做法是将质量内建于整个流程之中，并通过有效的控制手段来证明流程自身的有效性。</p><p>内建质量有两个核心原则：</p><ul><li>问题发现得越早，修复成本就越低；</li><li>质量是每个人的责任，而不是质量团队的责任。</li></ul><h3 id="内建质量的实施思路"><a href="#内建质量的实施思路" class="headerlink" title="内建质量的实施思路"></a>内建质量的实施思路</h3><p><strong>在需求环节，可以定义清晰的需求准入规则</strong>，比如需求的价值衡量指标是否客观、需求的技术可行性是否经过了验证、需求的依赖是否充分评估、需求描述是否清晰、需求拆分是否合理、需求验收条件是否明确等等。</p><p><strong>在开发阶段，代码评审和持续集成就是一个非常好的内建质量的实践。</strong>在代码评审中，要尽量确认编码是否和需求相匹配，业务逻辑是否清晰。另外，通过一系列的自动化检查机制，来验证编码风格、风险、安全漏洞等。</p><p><strong>在测试阶段，可以通过各类自动化测试，以及手工探索测试，覆盖安全、性能、可靠性等，来保障产品质量</strong>；在部署和发布阶段，可以增加数据库监控、危险操作扫描、线上业务监控等多种手段。</p><p><strong>研发环节作为整个软件产品的源头，是内建质量的最佳选择。</strong></p><h3 id="内建质量的实施步骤"><a href="#内建质量的实施步骤" class="headerlink" title="内建质量的实施步骤"></a>内建质量的实施步骤</h3><h4 id="第一步：选择适合的检查类型"><a href="#第一步：选择适合的检查类型" class="headerlink" title="第一步：选择适合的检查类型"></a>第一步：选择适合的检查类型</h4><p><strong>选择投入产出比相对比较高的检查类型，是一种合理的策略。</strong>比如代码风格与缺陷漏洞相比，检查缺陷漏洞显然更加重要，因为一旦发生代码缺陷和漏洞，就会引发线上事故。所以，这么看来，如果是客户端业务，Infer 扫描就可以优先实施起来。虽然我们不能忽视编码风格问题，但这并不是需要第一时间强制执行的。</p><h4 id="第二步：定义指标并达成一致"><a href="#第二步：定义指标并达成一致" class="headerlink" title="第二步：定义指标并达成一致"></a>第二步：定义指标并达成一致</h4><p><strong>指标项是针对检查类型所采纳的具体指标，</strong>比如单元测试覆盖率这个检查项，可采纳的指标就包括行、指令、类、函数等。那么，我们要以哪个为准呢？这个一般需要同研发负责人达成一致，并兼顾行业的一些典型做法，比如单测行覆盖率就是一个比较好的选择。</p><p><strong>参考值的定义是一门艺术。</strong>对于不同的项目，甚至是同一个项目的不同模块来说，我们很难用“一刀切”的方式定义数值。我比较推荐的做法是将静态指标和动态指标结合起来使用。</p><p><strong>静态指标就是固定值</strong>，对于漏洞、安全等问题来说，采取零容忍的态度，只要存在就绝不放过。<strong>而动态指标是以考查增量和趋势为主</strong>，比如基线值是 100，你就可以将参考值定义成小于等于 100，也就是不允许增加。你还可以根据不同的问题等级，定义不同的参考值，比如严格检查致命和阻塞问题，其余的不做限制。</p><p>最后，对于这个指标，你一定要跟研发团队达成共识，也就是说，团队要能够认可并且执行下去。所以，定义指标的时候要充分采纳对方的建议。</p><h4 id="第三步：建立自动化执行和检查能力"><a href="#第三步：建立自动化执行和检查能力" class="headerlink" title="第三步：建立自动化执行和检查能力"></a>第三步：建立自动化执行和检查能力</h4><p><strong>按照快速失败的原则，质量门禁的生效节点要尽量靠近指标数据的产生环节。</strong>比如，如果要检查编码风格，最佳的时间点是在研发本地的 IDE 中进行，其次是在版本控制系统中进行并反馈结果，而不是到了最后发布的时间点再反馈失败。</p><p>现代持续交付流水线平台都具备质量门禁的功能，常见的配置和生效方式有两种：</p><ul><li>在持续交付平台上配置规则，也就是不同指标和参考值组合起来，形成一组规则，并将规则关联到具体的执行任务中。这样做的好处是，各个生成指标数据的子系统只需要将数据提供给持续交付平台就行了，至于门禁是否通过，完全依靠持续交付平台进行判断。另外，一般配置规则的都是质量人员，提供这样一个单独的入口，可以简化配置成本。</li><li>在各个子系统中配置质量门禁。比如，在 UI 自动化测试平台上配置门禁的指标，当持续交付平台调用 UI 自动化测试的时候，直接反馈门禁判断的结果。如果检查不通过，则流水线直接失败。</li></ul><h4 id="第四步：定义问题处理方式"><a href="#第四步：定义问题处理方式" class="headerlink" title="第四步：定义问题处理方式"></a>第四步：定义问题处理方式</h4><p>一般来说，质量门禁都具有强制属性，也就是说，如果没有达到检查指标，就会立即停止并给予反馈。</p><p>在实际执行的过程中，质量门禁的结果可能存在多种选项，比如失败、告警、人工确认等。这些都需要在制定规则的时候定义清楚，通过一定的告警值和人工确认方式，可以对质量进行渐进式管控，以达到持续优化的目标。</p><p>另外，你需要对所有软件交付团队成员宣导质量规则和门禁标准，并明确通知方式、失败的处理方式等。否则，检查出问题却没人处理，这个门禁就形同虚设了。</p><h4 id="第五步：持续优化和改进"><a href="#第五步：持续优化和改进" class="headerlink" title="第五步：持续优化和改进"></a>第五步：持续优化和改进</h4><p>无论是检查能力、指标、参考值，还是处理方式，只有在运行起来后才能知道是否有问题。所以，在推行的初期，也应该具备一定程度的灵活性，比如对指标规则的修订、指标级别和参考值的调整等，<strong>核心目标不是为了通过质量门禁，而是为了质量提升，这才是最重要的。</strong></p><h3 id="内建质量的常见问题"><a href="#内建质量的常见问题" class="headerlink" title="内建质量的常见问题"></a>内建质量的常见问题</h3><table><thead><tr><th>常见问题</th><th>处理建议</th></tr></thead><tbody><tr><td>虽然有质量门禁，但是并没有强制生效。</td><td>分析不强制的原因，选择核心检查项启用强制规则，比如Critical和Blocker级别的问题，必须要解决。</td></tr><tr><td>规则有效性存在争议。</td><td>重新评审规则库，支持规则库自定义或者分级调整。在评审规则库时，核心就是要有务实的态度和开放的心态。务实是对真正对团队有用的规则达成共识，开放是允许团队针对规则提出意见。</td></tr><tr><td>采用人工审批的方式绕过门禁。</td><td>尽量减少让不了解详情的人员进行审批，因为这样做除了出问题一起背锅，并没有什么实质作用。</td></tr><tr><td>质量规则长期不更新。</td><td>建立定期质量规则更新机制，根据实际执行效果不断优化。</td></tr><tr><td>检查时间过长。</td><td>调整扫描频率和检查项内容，优化检查效率。</td></tr><tr><td>检查失败率高。</td><td>优化系统的稳定性。</td></tr><tr><td>质量数据丢失。</td><td>对每一次的执行数据进行归档，保证历史数据可见。</td></tr></tbody></table><h2 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h2><p>技术债务，就是指团队在开发过程中，为了实现短期目标选择了一种权宜之计，而非更好的解决方案，所要付出的代价。这个代价就是团队后续维护这套代码的额外工作成本，并且只要是债务就会有利息，债务偿还得越晚，代价也就越高。</p><p>如何对代码的技术债务进行分类呢？我们可以借用“Sonar Code QualityTesting Essentials”一书中的代码“七宗罪”，也就是<strong>复杂性、重复代码、代码规范、注释有效性、测试覆盖度、潜在缺陷和系统架构</strong>七种典型问题。你可以参考一下这七种类型对应的解释和描述：</p><table><thead><tr><th>类型</th><th>影响</th></tr></thead><tbody><tr><td>不能均匀分布的复杂性</td><td>较高的圈复杂度需要更多的测试才能覆盖到全路径，导致潜在的功能质量风险。</td></tr><tr><td>重复代码</td><td>重复代码是最严重的问题，会导致潜在缺陷。另外，重复也会带来维护成本的增加。</td></tr><tr><td>不合适的注释</td><td>代码的注释没有明确标准。缺少关键环节的注释或者是注释难以理解，都会导致代码的可读性变差。</td></tr><tr><td>违反代码规范</td><td>影像团队基于共同的规范进行写作，会增加潜在的风险。</td></tr><tr><td>缺乏单元测试</td><td>单元测试不足会影响团队对代码的信心，增加重构成本，通过测试覆盖率对其进行度量。</td></tr><tr><td>缺陷和潜在的缺陷</td><td>缺陷和潜在缺陷是最直接影响代码质量的要素，要尽可能地发现并修复。</td></tr><tr><td>设计和系统架构</td><td>设计和系统架构受限于当时的资源条件，可能无法满足后续产品的发展需求，所以需要持续演进。</td></tr></tbody></table><p>技术债务最直接的影响就是内部代码质量的高低。如果软件内部质量很差，会带来 3 个方面的影响：</p><ol><li><p>额外的研发成本</p></li><li><p>不稳定的产品质量</p></li><li><p>难以维护的产品</p></li></ol><h3 id="如何量化技术债务？"><a href="#如何量化技术债务？" class="headerlink" title="如何量化技术债务？"></a>如何量化技术债务？</h3><p>软件开发不像是银行贷款，技术债务看不见摸不着，所以，我们需要一套计算方法把这种债务量化出来。目前业界比较常用的开源软件，就是 SonarQube。在 SonarQube 中，技术债是基于 SQALE 方法计算出来的。关于SQALE，全称是 Software QualityAssessment based on Lifecycle Expectations，这是一种开源算法。</p><p>Sonar 通过将不同类型的规则，按照一套标准的算法进行识别和统计，最终汇总成一个时间，也就是说，要解决扫描出来的这些问题，需要花费的时间成本大概是多少，从而对代码质量有一种直观的认识。</p><p>计算出来的技术债务会因为开启的规则数量和种类的不同而不同。</p><p>另外，在 Sonar 中，还有一个更加直观的指标来表示代码质量，这就是 SQALE 级别。SQALE 的级别为 A、B、C、D、E，其中 A 是最高等级，意味着代码质量水平最高。级别的算法完全是基于技术债务比例得来的。简单来说，就是<strong>根据当前代码的行数，计算修复技术债务的时间成本和完全重写这个代码的时间成本的比例。</strong></p><blockquote><p>技术债务比例 = 修复已有技术债务的时间 / 完全重写全部代码的时间</p></blockquote><h3 id="解决方法和原则"><a href="#解决方法和原则" class="headerlink" title="解决方法和原则"></a>解决方法和原则</h3><p>解决技术债务，有哪些步骤呢？</p><ol><li>共识：团队内部要对技术债务的危害、解决项目的目标、规则的选择和制定达成一致意见。</li><li>可见：通过搭建开源的 Sonar 平台，将代码扫描整合进持续交付流水线中，定期或者按需执行，让技术债务变得可视化和可量化。不仅如此，Sonar 平台还能针对识别出来的问题，给出建议的解决方法，这对于团队快速提升编码水平，大有帮助。</li><li>止损：针对核心业务模块，对核心指标类型，比如 vulnerability，缺陷的严重和阻塞问题设定基线，也就是控制整体数量不再增长。</li><li>改善：创建技术优化需求，并在迭代中留出一定的时间修复已有问题，或者采用集中突击的方式搞定大头儿，再持续改进。</li></ol><p>在解决技术债务的过程中，要遵循 4 条原则。</p><ol><li>让技术债务呈良性下降趋势。一种好的趋势意味着一个好的起点，也是团队共同维护技术债务的一种约定。</li><li>优先解决高频修改的问题。技术债务的利息就是引入新功能的额外成本，那么对于高频修改的模块来说，这种成本会快速累积，这也就意味着修复的产出是最大的。至于哪些代码是高频修改的，只要通过分析版本控制系统就可以看出来。</li><li>在新项目中启动试点。如果现有的代码过于庞大，不可能在短时间内完成修复，那么你可以选择控制增长，同时在新项目中试点执行，一方面磨合规则的有效性，另一方面，也能试点质量门禁、IDE 插件集成等自动化流程。</li><li>技术债务无法被消灭，也不要等到太晚。只要还在开发软件项目，技术债务就基本上无法避免，所以不需要一下子把目标定得太高，循序渐进就行了。但同时，技术债务的累积也不是无穷无尽的，等到再也无法维护的时候就太迟了。</li></ol><p>制定规则的建议：</p><p>第一，参考代码质量平台的默认问题级别。一般来说，阻塞和严重的问题的优先级比一般问题更高，这也是基于代码质量平台长时间的专业积累得出的结论。</p><p>第二，你可以参考业界优秀公司的实践经验，比如很多公司都在参考阿里巴巴的 Java 开发手册，京东也有自己的编码规约。</p><p>影响比较大的问题类型，建议你优先进行处理：</p><ul><li>大量重复代码；</li><li>类之间的耦合严重；</li><li>方法过于复杂；</li><li>条件判断嵌套太多；</li><li>缺少必要的异常处理；</li><li>多表关联和缺少索引；</li><li>代码风险和缺陷；</li><li>安全漏洞。</li></ul><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><p><strong>环境管理的挑战</strong></p><p>1.环境种类繁多</p><p>2.环境复杂性上升</p><p>3.环境一致性难以保证</p><p>4.环境交付速度慢</p><p>5.环境变更难以追溯</p><p>解决这些问题的方法就是是 基础设施即代码。可以这么说，如果没有采用基础设施即代码的实践，DevOps 一定走不远。</p><p><strong>基础设施即代码</strong></p><p>基础设施即代码就是用一种描述性的语言，通过文本管理环境配置，并且自动化完成环境配置的方式。典型的就是以 CAPS 为代表的自动化环境配置管理工具，也就是 Chef、Ansible、Puppet 和 Saltstacks 四个开源工具的首字母缩写。</p><p>首先， <strong>通过将所有环境的配置过程代码化，每个环境都对应一份配置文件，可以实现公共配置的复用。</strong></p><p>其次，环境的配置过程，完全可以使用工具自动化批量完成。你只需要引用对应环境的配置文件即可，剩下的事情都交给工具。</p><p>最后，既然环境配置变成了代码，自然可以直接纳入版本控制系统中进行管理，享受版本控制的福利。任何环境的配置变更都可以通过类似 Git 命令的方式来实现，不仅收敛了环境配置的入口，还让所有的环境变更都完全可追溯。</p><p>基础设施即代码的实践，通过人人可以读懂的代码将原本复杂的技术简单化，这样一来，即便是团队中不懂运维的角色，也能看懂和修改这个过程。这不仅让团队成员有了一种共同的语言，还大大减少了不同角色之间的依赖，降低了沟通协作成本。这也是基础设施即代码的隐形价值所在，特别符合 DevOps 所倡导的协作原则。</p><p>在大多数公司，部署上线的工作都是由专职的运维团队来负责，开发团队只要将测试通过的软件包提供给运维团队就行了。所以，<strong>开发和运维的自然边界就在于软件包交付的环节，只有打通开发环节的软件集成验收的 CI 流水线和运维环节的应用部署 CD 流水线上线，才能真正实现开发运维的一体化。</strong>而当版本控制系统遇上基础设施即代码，就形成了一种绝妙的组合，那就是 <strong>GitOps</strong>。</p><p><strong>开发运维打通的 GitOps 实践</strong></p><p>顾名思义，GitOps 就是<strong>基于版本控制系统 Git 来实现的一套解决方案</strong>，核心在于基于 Git这样一个统一的数据源，通过类似代码提交过程中的拉取请求的方式，也就是 Pull/Request，来完成应用从开发到运维的交付过程，让开发和运维之间的协作可以基于 Git 来实现。</p><p>虽然 GitOps 最初是基于容器技术和 Kubernetes 平台来实现的，但它的理念并不局限于使用容器技术，实际上，它的核心在于通过代码化的方式来描述应用部署的环境和部署过程。</p><p>在 GitOps 中，<strong>每一个环境对应一个环境配置仓库</strong>，这个仓库中包含了应用部署所需要的一切过程。比如，使用 Kubernetes 的时候，就是应用的一组资源描述文件，比如部署哪个版本，开放哪些端口，部署过程是怎样的。</p><p>GitOps的部署流程图</p><p><img src="/assets/images/ops/devops/image-20200907104436525.png" alt="image-20200907104436525"></p><p>  以测试环境为例的主要流程：</p><ol><li>开发人员提交新的代码改动到 Git 仓库，这会自动触发持续集成流水线。</li><li>经过一系列的构建、测试和检查环节，并最终通过持续集成流水线之后，就会生成一个新版本的应用，并上传到制品库中。</li><li>然后自动针对测试环境的配置仓库创建一个代码合并请求。</li><li>开发或者测试人员可以通过接受合并的方式，将这段环境变更配置合入主干，并再一次自动化地触发部署流水线，将新版本的应用部署到测试环境中。</li></ol><p><strong>GitOps 的好处究竟有哪些呢？</strong></p><ul><li>环境配置的共享和统一管理</li><li>每一次的变更和部署过程也同样由版本控制系统进行记录。</li></ul><p><strong>开发环境的治理实践</strong></p><p>可以采用基础设施即代码的方法，生成一个包含全部工具依赖的Docker 镜像，并分发给开发团队。在开发时仅需要拉起一个容器，将代码目录挂载进去，就可以生成一个完全标准化的研发环境。当工具版本升级时，可以重新制作一个新的镜像，开发本地拉取后，所有的工具就升级完成了，这大大简化了研发环境的维护成本。</p><p>关于如何解决开发本地测试的问题，在 Jenkins 社区也有一些相关的实践。</p><p>比如，你基于 Kubernetes 创建了一套最小测试环境，按照正常过程来说，如果改动一行代码，你需要经过代码提交、打包镜像、上传制品、更新服务器镜像等，才能开始调试。但如果你使用KSync工具，这些过程统统可以省略。KSync 可以帮你建立本地工作空间和远端容器目录的关联，并自动同步代码。也就是说，只要在本地 IDE 里面修改了一行代码，保存之后，KSync 就可以帮你把本地代码传到线上的容器中，对于类似 Python 这样的解释型语言来说特别省事。</p><p>谷歌也开源了一套基于容器开发自动部署工具Skaffold，跟 KSync 类似，使用 Skaffold命令就可以创建一套 Kubernetes 环境。当本地修改一行代码之后，Skaffold 会自动帮你重新生成镜像文件，推送远端，并部署生效，让代码开发变得所见即所得。研发只需要专注于写代码这件事情，其余的全部自动化，这也是未来 DevOps 工程实践的一个发展方向。</p><h2 id="部署管理"><a href="#部署管理" class="headerlink" title="部署管理"></a>部署管理</h2><p><strong>部署</strong>是一组技术实践，表示通过技术手段，将本次开发测试完成的功能实体（比如代码、二进制包、配置文件、数据库等）应用到指定环境的过程，包括开发环境、预发布环境、生产环境等。部署的结果是对服务器进行变更，但是这个变更结果不一定对外可见。</p><p><strong>发布</strong>，也就是 Release，更偏向一种业务实践，也就是将部署完成的功能正式生效，对用户可见和提供服务的程。</p><p>DevOps 模式下，<strong>质量思想</strong>发生了转变。简单概括就是：<strong>要在保障一定的质量水平的前提下，尽量加快发布节奏，并通过低风险发布手段，以及线上测试和监控能力，尽早地发现问题，并以一种最简单的手段来快速恢复。</strong></p><p><strong>一定的质量水平</strong></p><p>对于互联网这种快速迭代的业务来说，大家都习惯了默认会出问题，所以在圈定测试范围和测试覆盖的基础上，只要完成严重问题的修复即可发布，低级别的问题可以在后续的众测和灰度的环节继续处理。</p><p>所以，与定义一个发布质量标准相比，更重要的随着 DevOps 的推广，扭转团队的质量观念。<strong>质量不再是测试团队自身的事情，而是整个交付团队的事情。</strong>如果出现了线上问题，团队要一起来定位和修复，并且反思如何避免类似的问题再次发生，从失败中学习。</p><p><strong>低风险的发布手段</strong></p><p>既然发布是一件不可回避的高风险事情，那么，为了降低发布活动的风险，就需要有一些手段了。典型的包括以下几种：蓝绿部署，灰度发布和暗部署。</p><ol><li>蓝绿部署就是为应用准备两套一模一样的环境，一套是蓝环境，一套是绿环境，每次只有一套环境提供线上服务。这里的蓝和绿，只是用于区分两套环境的标志而已。在新版本上线时，先将新版本的应用部署到没有提供线上服务的环境中，进行上线前验证，验证通过后就达到了准备就绪的状态。在发布时间点，只要将原本指向线上环境的路由切换成另外一套环境，整个发布过程就完成了。</li><li>灰度发布，也叫金丝雀发布。与蓝绿部署相比，灰度发布更加灵活，成本也更低，所以，在企业中是一种更为普遍的低风险发布方式。灰度发布有很多种实现机制，最典型的就是采用一种渐进式的滚动升级来完成整个应用的发布过程。当发布新版本应用时，根据事先设计好的灰度计划，将新应用部署到一定比例的节点上。当用户流量打到这部分节点的时候，就可以使用新的功能了。</li><li>随着 A/B 测试的兴起，暗部署的方式也逐渐流行起来。所谓<strong>暗部署，就是在用户不知道的情况下进行线上验证的一种方法。</strong>比如后端先行的部署方式，把一个包含新功能的接口发布上线，这个时候，由于没有前端导向这个接口，用户并不会真实地调用到这个接口。当用户进行了某些操作后，系统会将用户的流量在后台复制一份并打到新部署的接口上，以验证接口的返回结果和性能是否符合预期。</li></ol><p><strong>线上测试和监控</strong></p><p>如何做线上验证呢？比较常见的，有三种手段。</p><ol><li><p>采用灰度发布、用户众测等方式，逐步观察用户行为并收集用户数据，以验证新版本的可用性是否符合预期。</p><p>在互联网产品中，<strong>埋点是一种最常用的产品分析和数据采集方法</strong>，也是数据驱动决策的主要依据之一。它的价值就在于，根据预先设计的收集和监控数据的方法，采集用户的行为、产品质量、运营数据等多维度的数据。</p></li><li><p>用户反馈。</p><p>除了自动化的采集数据之外，用户主动的反馈也是获取产品信息的第一手资料。而用户反馈的渠道有很多，公司里面一般都有用户运营和舆情监控系统，用于按照“关键字”等自动爬取各个主流渠道的产品信息。一旦发现负面的反馈，就第一时间进行止损。</p></li><li><p>使用线上流量测试。</p><p>最常用的就是将线上真实的用户流量复制下来，以实时或者离线的方式回放到预发布环境中用于功能测试。</p></li></ol><p><strong>快速恢复</strong></p><p>初步对问题进行分析定位后，你可以有两种选择：向前修复和向后回滚。</p><p><strong>向前修复就是快速修改代码并发布一个新版本上线，向后回滚就是将系统部署的应用版本回滚到前一个稳定版本。</strong></p><p>在出现问题系统可以自动修复, 就是故障自愈。故障自愈的第一步，就要做好服务降级和兜底策略。</p><p>服务降级就是指，在流量高峰的时候，将非主路径上的功能进行临时下线，保证业务的可用性。典型的做法就是通过功能开关的方式来手动或自动地屏蔽一些功能。</p><p>兜底策略是指，当极端情况发生时，比如服务不响应、网络连接中断，或者调用服务出现异常的时候，也不会出现崩溃。常见的做法就是缓存和兜底页面，以及前端比较流行的骨架屏等。</p><h2 id="混沌工程"><a href="#混沌工程" class="headerlink" title="混沌工程"></a>混沌工程</h2><p>混沌工程作为软件领域的一门新兴学科，就和它的名字一样，让很多人感到非常“混沌”。</p><p>那么，混沌工程究竟是从何而来，又是要解决什么问题呢？我们先来看看混沌原则网站对混沌工程的定义：</p><blockquote><p>Chaos Engineering is the discipline of experimenting on a distributed system inorder to build confidence in the system’s capability to withstand turbulent conditions in production.</p></blockquote><blockquote><p>混沌工程是一门在分布式系统上进行实验的学科，目的是建立人们对于复杂系统在生产环境中抵御突发事件的信心。</p></blockquote><p>简单来说，混沌工程要解决的，就是复杂环境下的分布式系统的反脆弱问题。那么，我们所要面对的“复杂的分布式”的真实世界是怎样的呢？</p><p>随着微服务、容器化等技术的兴起，业务驱动自组织团队独立发布的频率越来越高，再加上架构的不断更新演进，可以说，几乎没有人能完整地梳理清楚一套系统的服务间调用关系，这就让复杂系统变成了一个“黑洞”。不管外围如何敲敲打打，都很难窥探到核心问题。</p><p>区别于以往的方式，混沌工程采取了一种更加积极的方式，换了一个思路主动出击。那就是，<strong>尽可能在这些故障和缺陷发生之前，通过一系列的实验，在真实环境中验证系统在故障发生时的表现。</strong>根据实验的结果来识别风险问题，并且有针对性地进行系统改造和安全加固，从而提升对于整个系统可用性的信心。</p><p><strong>服务可用性实践</strong></p><p>故障演练就是针对以往发生过的问题进行有针对性地模拟演练。通过事先定义好的演练范围，然后人为模拟事故发生，触发应急响应预案，快速地进行故障定位和服务切换，并观察整个过程的耗时和各项数据指标的表现。</p><p>故障演练针对的大多是可以预见到的问题，比如机器层面的物理机异常关机、断电，设备层面的磁盘空间写满、I/O 变慢，网络层面的网络延迟、DNS 解析异常等。这些问题说起来事无巨细，但基本上都有一条清晰的路径，有明确的触发因素，监控事项和解决方法。</p><p><strong>从业务层面来说，面对多变的环境因素，完善的服务降级预案和系统兜底机制也是必不可少的</strong>。在业务压力比较大的时候，可以适当地屏蔽一些对用户感知不大的服务，比如推荐、辅助工具、日志打印、状态提示等，保证最核心流程的可用性。另外，适当地<strong>引入排队机制</strong>也能在一定程度上分散瞬时压力。</p><p><strong>必须要强调的是，在引入混沌工程的实践之前，首先需要确保现有的服务已经具备了弹性模式，并且能够在应急响应预案和自动化工具的支撑下尽早解决可能出现的问题。</strong></p><h3 id="混沌工程的原则"><a href="#混沌工程的原则" class="headerlink" title="混沌工程的原则"></a>混沌工程的原则</h3><p>混沌工程的五大原则：建立稳定状态的假设、真实世界的事件、在生产中试验、持续的自动化实验、最小影响范围。</p><p><strong>建立稳定状态的假设</strong></p><p>关于系统的稳定状态，就是说，有哪些指标可以证明当前系统是正常的、健康的。实际上，无论是技术指标，还是业务指标，现有的监控系统都已经足够强大了，稍微有一点抖动，都能在第一时间发现这些问题。</p><table><thead><tr><th>指标类型</th><th>指标示例</th></tr></thead><tbody><tr><td>业务核心指标</td><td>用户数、活跃用户数、新增用户数、订单量、GMV、平均客单价、转化率、订单成功率、订单取消率、订单退货率、商品和商家数量</td></tr><tr><td>业务访问指标</td><td>UV、PV、点击率、首页到达率、商品到达率、评论到达率</td></tr><tr><td>用户体验指标</td><td>用户满意度、用户投诉数量、用户反馈数量、订单好评率、订单差评率</td></tr><tr><td>系统指标</td><td>QPS、TPS、CPU使用率、CPU负载、内存使用率、网络连接数、平均响应时长、404数量</td></tr></tbody></table><p><strong>真实世界的事件</strong></p><p>真实世界的很多问题都来源于过往踩过的“坑”，即便是特别不起眼的事件，都会带来严重的后果。</p><p>我们无法模拟所有的异常事情，<strong>投入产出比最高的就是选择重要指标</strong>（比如设备可用性、网络延迟，以及各类服务器问题），进行有针对性地实验。另外，可以结合类似全链路压测等手段，从全局视角测试系统整体运作的可用性，通过和稳定状态的假设指标进行对比，来识别潜在的问题。</p><p><strong>在生产中实验</strong></p><p><strong>真实世界的问题，只有在生产环境中才会出现。</strong>一个小规模的预发布环境更多的是验证系统行为和功能符合产品设计，也就是从功能的角度出发，来验证有没有新增缺陷和质量回退。<br>但是，系统的行为会根据真实的流量和用户的行为而改变。比如，流量明星的一则消息就可能导致微博的系统崩溃，这是在测试环境很难复现的场景。</p><p>但客观来说，在生产环境中进行实验，的确存在风险，这就要求实验范围可控，并且具备随时停止实验的能力。还是最开始的那个原则，如果系统没有为弹性模式做好准备，那么就不要开启生产实验。</p><p>还以压测为例，我们可以随机选择部分业务模块，并圈定部分实验节点，然后开启常态化压测。通过定期将线上流量打到被测业务上，观察突发流量下的指标表现，以及是否会引发系统雪崩，断路器是否生效等，<strong>往往在没有准备的时候才能发现真实问题。这种手段作为混沌工程的一种实践</strong>，已经普遍应用到大型公司的在线系统之中了。</p><p><strong>持续的自动化实验</strong></p><p><strong>自动化是所有重复性活动的最佳解决方案。</strong>通过自动化的实验和自动化结果分析，我们可以保证混沌工程的诸多实践可以低成本、自动化地执行。正因为如此，以混沌工程为名的工具越来越多。</p><p>比如，商业化的混沌工程平台 Gremlins 就可以支持不可用依赖、网络不可达、突发流量等场景。阿里也开源了他们的混沌工具ChaosBlade，缩短了构建混沌工程的路径，引入了更多的实践场景。另外，开源的Resilience4j和 Hystrix也都是非常好用的工具。无论是自研，还是直接采用，都可以帮助你快速上手。</p><p><strong>最小的影响范围</strong></p><p>混沌工程实践的原则就是不要干扰真实用户的使用，所以，在一开始将实验控制在一个较小的范围内，是非常有必要的，这样可以避免由于实验失控带来的更大问题。</p><h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><p>度量不是目的，而是手段，也就是说度量的目标是“做正确的事”，而度量的手段是“正确地做事”。</p><h3 id="如何定义指标？"><a href="#如何定义指标？" class="headerlink" title="如何定义指标？"></a>如何定义指标？</h3><p>好的指标大多具备一些典型的特征。</p><ol><li><p>明确受众。</p><p>指标不能脱离受众而单独存在，在定义指标的同时，要定义它所关联的对象，也就是这个指标是给谁看。</p></li><li><p>直指问题。</p><p>一看到这个指标，就能意识到问题所在，并自然而然地进行改进，而不是看了跟没看见一样，也不知道具体要做什么。</p></li><li><p>量化趋势。</p><p>按照 SMART 原则，好的指标应该是可以衡量的，而且是可以通过客观数据来自证的。</p></li><li><p>充满张力。</p><p>指标不应该孤立存在，而是应该相互关联构成一个整体。好的指标应该具有一定的张力，向上可以归并到业务结果，向下可以层层分解到具体细节。这样通过不同维度的数据抽取，可以满足不同视角的用户需求。</p></li></ol><h3 id="定义指标有哪些原则？"><a href="#定义指标有哪些原则？" class="headerlink" title="定义指标有哪些原则？"></a>定义指标有哪些原则？</h3><ol><li>全局指标优于局部指标：过度的局部优化可能对整体产出并无意义，从而偏离了度量的核心，也就是提升交付速度和交付质量。</li><li>综合指标优于单一指标：从单一维度入手会陷入只见树木不见森林的困境，综合指标更加客观。所以，要解决一个问题，就需要一组指标来客观指引。</li><li>结果指标优于过程指标：首先要有结果指标，以结果为导向，以过程为途径，一切过程指标都应该归结到结果指标。</li><li>团队指标优于个人指标：优先考核团队指标而非个人指标，团队共享指标有助于形成内部合力，减少内部的割裂。</li><li>灵活指标优于固化指标：指标的设立是为了有针对性地实施改进，需要考虑业务自身的差异性和改进方向，而非简单粗暴的“一刀切”，并且随着团队能力的上升，指标也需要适当的调整，从而不断挑战团队的能力。</li></ol><h3 id="哪些指标最重要？"><a href="#哪些指标最重要？" class="headerlink" title="哪些指标最重要？"></a>哪些指标最重要？</h3><ol><li><p>交付效率</p><p><strong>需求前置时间：</strong>从需求提出到完成整个研发交付过程，并最终上线发布的时间。对业务方和用户来说，这个时间是最能客观反映团队交付速度的指标。这个指标还可以进一步细分为需求侧，也就是从需求提出、分析、设计、评审到就绪的时长，以及业务侧，也就是研发排期、开发、测试、验收、发布的时长。对于价值流分析来说，这就代表了完整的价值流时长。<br><strong>开发前置时间：</strong>从需求进入排期、研发真正动工的时间点开始，一直到最终上线发布的时长。它体现的是研发团队的交付能力，也就是一个需求进来后，要花多久才能完成整个开发过程。</p></li><li><p>交付能力</p><p><strong>发布频率：</strong>单位时间内的系统发布次数。原则上发布频率越高，代表交付能力越强。这依赖于架构结构和团队自治、独立发布的能力。每个团队都可以按照自己的节奏安全地发布，而不依赖于关联系统和发布窗口期的约束。<br><strong>发布前置时间：</strong>指研发提交一行代码到最终上线发布的时间，是团队持续交付工程能力的最直观的考查指标，依赖于全流程自动化的流水线能力和自动化测试能力。这也是DevOps 状态报告中的核心指标之一。<br><strong>交付吞吐量：</strong>单位时间内交付的需求点数。也就是，单位时间内交付的需求个数乘以需求颗粒度，换算出来的点数，它可以体现出标准需求颗粒度下的团队交付能力。</p></li><li><p>交付质量</p><p><strong>线上缺陷密度：</strong>单位时间内需求缺陷比例，也就是平均每个需求所产生的缺陷数量，缺陷越多，说明需求交付质量越差。<br><strong>线上缺陷分布：</strong>所有缺陷中的严重致命等级缺陷所占的比例。这个比例的数值越高，说明缺陷等级越严重，体现了质量的整体可控性。<br><strong>故障修复时长：</strong>从有效缺陷提出到修复完成并上线发布的时间。一方面，这个指标考查了故障定位和修复的时间，另外一方面，也考查了发布前置时间，只有更快地完成发布上线过程，才能更快地修复问题。</p></li></ol><h3 id="如何开启度量工作？"><a href="#如何开启度量工作？" class="headerlink" title="如何开启度量工作？"></a>如何开启度量工作？</h3><p>在企业内部开启度量工作，可以分为四个步骤。</p><h4 id="第-1-步：细化指标。"><a href="#第-1-步：细化指标。" class="headerlink" title="第 1 步：细化指标。"></a>第 1 步：细化指标。</h4><p>一个完整的指标，除了定义之外，还需要明确指标名、指标描述、指标级别（团队级 / 组织级）、指标类型、适用场景范围及目标用户、数据采集方式和标准参考值。</p><p>以交付指标为例，我汇总了一份细化后的指标内容，你可以参考下表。其实不仅仅是核心结果指标，只要是在度量体系内定义的指标，都需要进行细化。</p><p><img src="/assets/images/ops/devops/image-20200908113702895.png" alt="image-20200908113702895"></p><h4 id="第-2-步：收集度量数据"><a href="#第-2-步：收集度量数据" class="headerlink" title="第 2 步：收集度量数据"></a>第 2 步：收集度量数据</h4><p>度量指标需要客观数据的支撑，而数据往往都来源于各个不同的平台。所以，在定义指标的时候，你需要评估是否有足够的客观数据来支撑这个指标的衡量。</p><p>需要从流程和平台两个层面入手解决。比如，一方面，从流程层面制定研发操作规范，让每一名研发人员都清楚在什么时间点需要改变需求卡片状态；另一方面，建设平台能力，提供易用性的方式辅助研发，甚至自动流转需求状态。</p><h4 id="第-3-步：建立可视化平台。"><a href="#第-3-步：建立可视化平台。" class="headerlink" title="第 3 步：建立可视化平台。"></a>第 3 步：建立可视化平台。</h4><p>度量指标毕竟是要给人看的，度量数据也需要有一个地方可以收集和运算，这就依赖于度量可视化平台的建设了。</p><h4 id="第-4-步：识别瓶颈并持续改进。"><a href="#第-4-步：识别瓶颈并持续改进。" class="headerlink" title="第 4 步：识别瓶颈并持续改进。"></a>第 4 步：识别瓶颈并持续改进。</h4><p>当数据做到了可信和可视化之后，团队面临的问题和瓶颈会自然而然浮现出来。</p><h2 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h2><p>DevOps 做到什么程度，就算是实现转型落地了？那么，我的回答是，<strong>核心就是团队已经具备了持续改进的能力，而不只是简简单单地引入了几个工具，建立了几个度量指标而已</strong></p><p>持续改进的意义到底是什么呢？为什么一切活动的终极目标都是持续改进呢？</p><p>这是因为，每家公司面临的问题都不一样，从 0 到 1 的过程相对比较简单，可以对照着工程实践，快速地引入工具，建立流程，补齐能力短板。但是，从 1 到 N 的过程，就需要团队根据业务需要，自行识别改进目标了。</p><p>谈到持续改进，有一个非常著名的方法体系，叫作 PDCA，也称为<strong>戴明环</strong>。没错，你从名称就能看出，这套方法体系同样来自于质量管理大师戴明博士。PDCA 是四个英文单词的缩写，也就是 <strong>Plan（计划）、Do（实施）、Check（检查）和 Action（行动）</strong>。</p><p>PDCA 提供了一套结构化的实施框架，任何一项改进类工作，都可以划分为这四个实施阶段。<strong>通过 PDCA 循环的不断迭代，驱动组织进入一种良性循环，不断识别出新的待改进问题。</strong>针对这些问题，首先要进行根因分析，制定具体的实施计划。然后，不定期地检查实施的结果和预期目标是否一致。最后，要对改进结果进行复盘，把做得好的地方保留下来，把做得不好的地方纳入下一阶段的循环中，继续改进。</p><p><strong>构建持续改进的核心，就在于构建一个学习型组织。</strong></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="鼓励正向回溯和总结"><a href="#鼓励正向回溯和总结" class="headerlink" title="鼓励正向回溯和总结"></a>鼓励正向回溯和总结</h4><p>从失败中学习是我们从小就懂的道理。一个团队对待故障的态度，很大程度上就反映了他们对于持续改进的态度。系统出现故障是谁都不愿意遇到的事情，但在真实世界中，这是没法避免的。</p><p>故障回溯并不一定以确定责任为第一要务，<strong>更重要的是，要识别系统流程中的潜在问题和漏洞，并通过后续机制来进行保障</strong>，比如增加测试用例、增加产品走查事项等等。</p><h4 id="预留固定时间进行改进"><a href="#预留固定时间进行改进" class="headerlink" title="预留固定时间进行改进"></a>预留固定时间进行改进</h4><p>在团队的日常迭代中，事先给改进类工作预留一部分时间，或者是在业务相对不那么繁忙的时候（比如大促刚刚结束，团队在调整状态的时候），在改进工作上多花些时间。</p><p>这些工作量主要用于解决非功能需求、技术改进类问题，比如修复技术债务、单元测试用例补充、度量识别出来的改进事项等。通过将这部分改进时间固定下来，可以培养团队持续改进的文化。</p><p>我比较推荐的做法是，在团队的 Backlog 中新增一类任务，专门用于记录和跟踪这类持续改进的内容。在迭代计划会议上，对这类问题进行分析，并预估工作量，保证团队有固定的时间来应对这些问题。</p><h4 id="在团队内部共享业务指标"><a href="#在团队内部共享业务指标" class="headerlink" title="在团队内部共享业务指标"></a>在团队内部共享业务指标</h4><p>对于业务的指标和表现，需要尽可能地在团队内部做到透明，让团队成员可以接触真实世界的用户反馈和评价，以及业务的度量信息。</p><p>在一个新功能开发完成上线之后，要能实时查看这个需求的上线状态。如果需求分析时已经关联了业务考核指标，那么，同样可以将该业务关联的指标数据进行展示。这样，研发就会知道自己交付的内容有多少问题，用户的真实反馈是怎样的，从而促使团队更多地站在用户的视角思考问题。</p><p>除了业务指标，DevOps 的指标体系也应该对内部公开透明。大家可以查看自己所在团队的表现，以及在公司内部的整体水平。</p><h4 id="激励创造性，并将价值最大化"><a href="#激励创造性，并将价值最大化" class="headerlink" title="激励创造性，并将价值最大化"></a>激励创造性，并将价值最大化</h4><p>在团队成员的绩效目标中，增加对团队贡献和技术创新的要求，在团队内部鼓励创新类工作。另外，在团队内部建立对应的选拔和激励机制，为好的想法投入资源，把它们变成可以解决类似问题的工具。</p><p>很多公司也开始注意到这种内部知识复用的重要性，所以，无论是代码库开源，还是公共基础组件的市的建设，甚至是公司级的平台治理系统，都可以帮助你快速地复用已有的能力，避免一直重复造轮子。</p><h2 id="DevOps-平台"><a href="#DevOps-平台" class="headerlink" title="DevOps 平台"></a>DevOps 平台</h2><p>企业DevOps平台建设的三个阶段</p><h3 id="阶段一：从无到有"><a href="#阶段一：从无到有" class="headerlink" title="阶段一：从无到有"></a>阶段一：从无到有</h3><p>在这个阶段，企业的 DevOps 平台建设处于刚刚起步的状态，在整个交付过程中，还有大量的本地操作和重复性的操作。<br>另外，企业内部一般也没有一个成体系的工具团队，来专门负责平台能力建设。那么，对于这个阶段，我给你的建议是：<strong>引入开源工具和商业工具，快速补齐现有的能力短板。</strong></p><p>所谓能力短板，其实就是当前交付工具链体系中缺失的部分，尤其是高频操作，或者是涉及多人协作的部分，比如，需求管理、持续集成等。</p><p>如何选择工具？</p><p>选择工具的核心原则就是<strong>选择主流工具</strong></p><ul><li>需求管理工具 Jira；</li><li>知识管理工具 Confluence；</li><li>版本控制系统 GitLab；</li><li>持续集成工具 Jenkins；</li><li>代码质量工具 SonarQube；</li><li>构建工具 Maven/Gradle；</li><li>制品管理 Artifactory/Harbor；</li><li>配置管理工具 Ansible；</li><li>配置中心 Apollo；</li><li>测试工具 RF/Selenium/Appium/Jmeter/TestNG；</li><li>安全合规工具 BlackDuck/Fortify；<br>……</li></ul><p>为什么商业工具也是可选项？</p><p>商业工具的优势一直都存在，比如，专业性、安全性、扩展性、技术支持力度等。其实，很多开源工具都有商业版本。</p><p>选择商业工具的理由有很多，不选的理由大多就是一个字：贵。针对这个问题，我要说的是，要分清一笔支出到底是成本，还是投资。</p><p>就跟购买黄金一样，虽然也花了钱，但这是一笔投资，未来可以保值和增值，甚至是变现。对于商业工具来说，也是同样的道理。如果一款商业工具可以大幅提升团队效率，最后的产出可能远超最开始的投资。如果我们组建一个团队，仿照商业工具，开发一套自研工具，重复造轮子的成本也可能一点不少。所以，重点就是要看怎么算这笔账。</p><h3 id="阶段二：从小到大"><a href="#阶段二：从小到大" class="headerlink" title="阶段二：从小到大"></a>阶段二：从小到大</h3><p>经过了第一个阶段，企业交付链路上的工具基本都已经齐全了。团队对于工具的需求开始从够用到好用进行转变。另外，随着业务发展，团队扩大，差异化需求也成了摆在面前的问题。再加上，人和数据都越来越多，工具的重要性与日俱增。</p><p>那么，工具的稳定性、可靠性，以及大规模使用的性能问题，也开始凸显出来。对于这个阶段，我给你的建议是：使用半自建工具和定制商业工具，来解决自己的问题。</p><p>所谓半自建工具，大多数情况下，还是基于开源工具的二次开发，或者是对开源工具进行一次封装，在开源工具上面实现需要的业务逻辑和交互界面。</p><p>那么，半自建工具有哪些注意事项呢？虽然各个领域的工具职能千差万别，但从我的经验来看，主要有两点：设计时给扩展留出空间；实现时关注元数据治理。</p><h3 id="阶段三：从繁到简"><a href="#阶段三：从繁到简" class="headerlink" title="阶段三：从繁到简"></a>阶段三：从繁到简</h3><p>到了第三个阶段，恭喜你已经在 DevOps 平台建设方面有了一定的积累，在各个垂直领域也积累了成功案例。那么，在这个阶段，我们要解决的主要问题有 3 点：</p><ul><li><p>平台太多。做一件事情，需要各种切来切去；</p></li><li><p>平台太复杂。想要实现一个功能，需要对相关人员进行专业培训，他们才能做对；</p></li><li><p>平台价值说不清。比如，使用平台，能带来多大价值？能给团队和业务带来多大贡献？</p></li></ul><p>对于这个阶段，我给你的建议是：<strong>使用整合工具来化繁为简，统一界面，简化操作，有效度量。</strong></p><p>整合工具，就是包含了开源工具、半自研工具、商业工具的集合。</p><p>你要提供的不再是一个工具，而是一整套的解决方案；不是解决一个问题，而是解决交付过程中方方面面的问题。</p><p><strong>企业工具平台治理</strong></p><p>如果最开始没有一个顶层规划，到了这个时候，企业内部大大小小的工具平台应该有很多。你需要做的第一步，就是<strong>平台化治理工作</strong>。</p><p>第一条建议是比较温和可行的，那就是，找到<strong>软件交付的主路径</strong>。用一个平台覆盖这条主路径，从而串联各个单点上的能力，让一些真正好的平台能够脱颖而出。而要做到这个事情，就需要持续交付流水线了。</p><p><strong>打造自服务的工具平台</strong></p><p>到了这个阶段，自服务就成了平台建设的核心理念。</p><p>所谓自服务，就是用户可以自行登录平台实现自己的操作，查看自己关心的数据，获取有效的信息。</p><p>而想要实现自服务，简化操作是必经之路。说白了，如果一件事情只要一键就能完成，这才是真正地实现了自服务。</p><p>这么说可能有点夸张。但是，打破职能间的壁垒，实现跨职能的赋能，依靠的就是平台的自<br>服务能力。很多时候，当你在埋怨“平台设计得这么简单，为啥还是有人不会用”的时候，<br>其实这只能说明一个问题，就是平台依然不够简单。</p><p><strong>指导平台建设的核心理念</strong></p><ul><li>标准化：一切皆有规则，一切皆有标准；</li><li>自动化：干掉一切不必要的手工操作环节，能一键完成的，绝不操作两次；</li><li>服务化：面向用户设计，而不是面向专家设计，让每个人都能在没有外界依赖的前提下，完成自己的工作；</li><li>数据化：对数据进行收集、汇总、分析和展示，让客观数据呈现出来，让数据指导持续改进。</li></ul><h2 id="DevOps产品设计"><a href="#DevOps产品设计" class="headerlink" title="DevOps产品设计"></a>DevOps产品设计</h2><p>DevOps 产品设计体验的五个层次：战略存在层、能力圈层、资源结构层、角色框架层和感知层。</p><h3 id="第一个层次：战略存在层"><a href="#第一个层次：战略存在层" class="headerlink" title="第一个层次：战略存在层"></a>第一个层次：战略存在层</h3><p>希望用户通过这个产品得到什么？显然，目标用户和痛点问题的不同，会从根本上导致两套 DevOps 产品之间相距甚远。</p><p>DevOps 产品的战略定位：<strong>效率，质量，成本和安全。</strong>归根结底,产品的任何功能都是要为战略服务的.</p><p><strong>明确目标用户，定义刚性需求，服务于典型场景，并最终在某一个点上突出重围，这就是我们在准备做 DevOps 产品的时候首先要想清楚的问题。</strong></p><h3 id="第二个层次：能力圈层"><a href="#第二个层次：能力圈层" class="headerlink" title="第二个层次：能力圈层"></a>第二个层次：能力圈层</h3><p>战略很好，但是不能当饭吃。为了实现战略目标，我们需要做点什么，这就是需要产品化的能力。所谓产品化，就是将一个战略或者想法通过产品分析、设计、实验并最终落地的过程。</p><p>明确哪些是自己产品的核心竞争力，而哪些是我们的边界和底线，现阶段是不会去触碰的。当我们用这样一个圈子把自己框起来的时候，至少在短期内，目标是可以聚焦的。</p><p>当然，随着产品的价值体现，资源会随之而扩充，这个时候，我们就可以调整、扩大自己的能力圈。但说到底，这些能力都是为了实现产品战略而存在的，这一点永远不要忘记。</p><p>所谓<strong>主航道，就是产品的核心能力，直接反射了产品战略的具体落地方式。</strong>对于流水线产品来说，这个能力来源于对软件交付过程的覆盖，而不论你将来开发任何产品，这条主路径都是无法回避的。那么，产品就有了茁壮成长的环境和土壤。而<strong>护城河就是你这个产品的不可替代性，或者是为了替代你的产品需要付出的高额代价。</strong></p><h3 id="第三个层次：资源结构层"><a href="#第三个层次：资源结构层" class="headerlink" title="第三个层次：资源结构层"></a>第三个层次：资源结构层</h3><p>资源这个事儿吧，就像刚才提到的，永远是稀缺的，但这对于所有人来说都是公平的。所以，<strong>对资源的整合和调动能力就成了核心竞争力。</strong></p><p>产品蕴含的资源除了这些看得见、摸得着的机器以外，还有很多方面，比如，硬实力方面的，像速度快、机器多、单一领域技术沉淀丰富，又比如，强制性的，像审批入口、安全规则，还有软性的用户习惯，数据积累等等。</p><p>对于内部 DevOps 产品来说，还有一项资源是至关重要的，那就是<strong>领导支持</strong>。</p><h3 id="第四个层次：角色框架层"><a href="#第四个层次：角色框架层" class="headerlink" title="第四个层次：角色框架层"></a>第四个层次：角色框架层</h3><p>要站在用户的角度来看待问题，要在他们当时的场景下，去解决他们的问题，而不是远远地观望着，甚至以上帝视角俯视全局。</p><p><strong>不要让你的产品只有专业人士才会使用。</strong></p><p><strong>产品应该提供抽象能力屏蔽很多细节，而不是暴露很多细节，甚至，好的产品自身就是使用说明书。</strong>这一点，在注意力变得格外稀缺的现在，重要性不可忽视。</p><h3 id="第五个层次：感知层"><a href="#第五个层次：感知层" class="headerlink" title="第五个层次：感知层"></a>第五个层次：感知层</h3><p>让不专业的人做专业的事情，结果可想而知，好多产品功能的设计都堪称是“反人类”的。</p><p>关于这个层次，我提供两点建议：</p><ul><li>多跟前端工程师交流。现在的前端框架已经非常成熟了，基于模板，我们可以快速地搭建出一个平台。而且，模板的框架自身，也蕴含着很多的设计思想。</li><li>多学习一些基本的设计原则。你可以参考Element 官网上的设计理念章节，里面谈到了一致、反馈、效率和可控四个方面，每个方面又涉及很多细节。参照着成熟的产品，再对照这些基本设计理念，你放心，你会进步神速的。</li></ul><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>流水线是持续交付中最核心的实践，也是持续交付实践最直接的体现。</p><h3 id="十大特征"><a href="#十大特征" class="headerlink" title="十大特征"></a>十大特征</h3><p><strong>特性一：打造平台而非能力中心</strong></p><p>与其他 DevOps 平台相比，流水线平台有一个非常典型的特征，那就是，它是唯一一个贯穿软件交付端到端完整流程的平台。正因为这样，流水线平台承载了整个软件交付过程方方面面的能力，比如，持续集成能力、自动化测试能力、部署发布能力，甚至是人工审批的能力等。</p><p>将持续交付流水线平台和垂直业务平台分开，并定义彼此的边界。</p><p>所谓的<strong>垂直业务平台，就是指单一专业领域的能力平台</strong>，比如自动化测试平台、代码质量平台、运维发布平台等等，这些也是软件交付团队日常打交道最频繁的平台。</p><p><strong>流水线平台只专注于流程编排、过程可视化，并提供底层可复用的基础能力</strong>。比如，像是运行资源池、用户权限管控、任务编排调度流程等等。</p><p>垂直业务平台则专注于专业能力的建设、一些核心业务的逻辑处理、局部环节的精细化数据管理等。垂直业务平台可以独立对外服务，也可以以插件的形式，将平台能力提供给流水线平台。</p><p><strong>特性二：可编排和可视化</strong></p><p>所谓的流程可编排能力，就是指用户可以自行定义软件交付过程的每一个步骤，以及各个步骤之间的先后执行顺序。说白了，就是“我的模块我做主，我需要增加哪些交付环节，我自己说了算”。</p><p>流程可编排，需要平台前端提供一个可视化的界面，来方便用户定义流水线过程。典型的方式就是，将流水线过程定义为几个阶段，每个阶段按顺序执行。在每个阶段，可以按需添加步骤，这些步骤可以并行执行，也可以串行执行。</p><p><strong>特性三：流水线即代码</strong></p><p>流水线代码化的好处不言而喻：借助版本控制系统的强大功能，流水线代码和业务代码一样纳入版本控制系统，可以简单追溯每次流水线的变更记录。</p><p>流水线即代码大大地简化了流水线的配置成本，和原子一样，是构成现代流水线的另外一个支柱。</p><p><strong>特性四：流水线实例化</strong></p><p>首先，流水线需要支持参数化执行。<br>通过输入不同的参数，控制流水线的运行结果，甚至是控制流水线的执行过程。</p><p>其次，流水线的每一次执行，都可以理解为是一个实例化的过程。</p><p>每个实例基于执行时间点的流水线配置，生成一个快照，这个快照不会因为流水线配置的变更而变更。如果想要重新触发这次任务，就需要根据当时的快照运行，从而实现回溯历史的需求。</p><p>最后，流水线需要支持并发执行能力。</p><p>这就是说，流水线可以触发多次，生成多个运行实例。这考察的不仅是流水线的调度能力、队列能力，还有持久化数据的管理能力。</p><p><strong>特性五：有限支持原则</strong></p><p>流水线的设计目标，应该是满足大多数、常见场景下的快速使用，并提供一定程度的定制化可扩展能力，而不是满足所有需求。</p><p>流水线设计要提供有限的可能性，而非穷举所有变量因素。</p><p>用户的差异化诉求，该如何满足呢？其实，这很简单，你可以在平台中提供一些通用类原子能力，比如，执行自定义脚本的能力、调用 http 接口的能力、用户自定义原子的能力，等等。只要能提供这些能力，就可以满足用户的差异化需求了。</p><p><strong>特性六：流程可控</strong></p><p>流水线可以为了满足不同阶段的业务目标而存在，并且每条流水线上实现的功能都不相同。为了达到这个目的，流水线需要支持多种触发方式，比如定时触发、手动触发、事件触发等。其中，事件触发就是实现持续集成的一个非常重要的能力。</p><p>除了多种触发方式以外，流水线还需要支持人工审批。这也就是说，每个阶段的流转可以是自动的，上一阶段完成后，就自动执行下一阶段；也可以是手动执行的，必须经过人为确认才能继续执行，这里的人为确认需要配合权限的管控。</p><p><strong>特性七：动静分离配置化</strong></p><p>动静分离就是一种配置化的实现方式。这就是指，将需要频繁调整或者用户自定义的内容，保存在一个静态的配置文件中。然后，系统加载时通过读取接口获取配置数据，并动态生成用户可见的交互界面。</p><p><strong>特性八：快速接入</strong></p><p>在建设流水线平台的时候，能否快速地实现外部平台能力的接入，就成了一个必须要解决的问题。</p><p>经典的解决方式就是提供一种插件机制，来实现平台能力的接入。</p><p>实际上，接入成本的高低，直接影响了平台能力的拓展，而流水线平台支持的能力多少，就是平台的核心竞争力。</p><p>首先，流水线平台需要定义一套标准的接入方式。以接口调用类型为例，接入平台需要提供一个任务调用接口、一个状态查询接口以及一个结果上报接口。</p><ul><li>任务调用接口：用于流水线触发任务，一般由接入平台定义和实现。对于比较成熟的平台来说，这类接口一般都是现成的。接口调用参数可以直接转换成原子的参数，一些平台的配置化信息（比如接口地址、接口协议等），都可以定义在原子的数据结构中。</li><li>状态查询接口：用于流水线查询任务的执行状态，获取任务的执行进度。这个接口也是由接入平台定义和实现的，返回的内容一般包括任务状态和执行日志等。</li><li>数据上报接口：用于任务将执行结果上报给流水线平台进行保存。这个接口由流水线平台定义，并提供一套标准的数据接口给到接入方。接入方必须按照这个标准接口上报数据，以简化数据上报的过程。</li></ul><p><strong>特性九：内建质量门禁</strong></p><p>内建质量的两大原则：</p><ul><li>问题发现得越早，修复成本就越低；</li><li>质量是每个人的责任，而不是质量团队的责任。</li></ul><p>毫无疑问，持续交付流水线是内建质量的最好阵地，而具体的展现形式就是质量门禁。通过在持续交付流水线的各个阶段注入质量检查能力，可以让内建质量真正落地。</p><p>在流水线平台上，要完成质量规则制定、门禁数据收集和检查，以及门禁结果报告的完整闭环。质量门禁大多数来源于垂直业务平台，比如，UI 自动化测试平台就可以提供自动化测试通过率等指标。只有将用于门禁的数据上报到流水线平台，才能够激活检查功能。</p><p><strong>特性十：数据聚合采集</strong></p><p>当平台的能力以原子的形式接入流水线之后，流水线需要有能力获取本次执行相关的结果数据，这也是在平台对接的时候，务必要求子系统实现数据上报接口的原因。至于上报数据的颗粒度，其实并没有一定之规，原则就是满足用户对最基本的结果数据的查看需求。</p><h2 id="建设数据度量平台"><a href="#建设数据度量平台" class="headerlink" title="建设数据度量平台"></a>建设数据度量平台</h2><p>建设数据度量平台的核心价值，也就是让软件交付过程变得可视化。</p><p>在平台建设的时候，需要关注事前、事中和事后三个阶段的事情。</p><ul><li><strong>事前就是要对指标的定义达成共识</strong>。这里的指标要细化到数据源和详细的计算公式层面，即便没有度量平台，也可以计算出相应的结果；</li><li><strong>事中就是平台建设方面</strong>，面对多数据源平台可以采用采集器插件的方式灵活适配，建议使用 HBase 等非关系型数据库进行数据存储，可以利用现有的前端组件来实现可视化界面展示。</li><li><strong>事后就是数据的运营和规则落地</strong>。只有度量数据能够反映出问题，并驱动团队改进，度量才有意义。</li></ul><h2 id="案例-三个月完成千人规模的产品要怎么做"><a href="#案例-三个月完成千人规模的产品要怎么做" class="headerlink" title="案例: 三个月完成千人规模的产品要怎么做"></a>案例: 三个月完成千人规模的产品要怎么做</h2><h3 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h3><p>在项目启动会上，团队达成了两个非常关键的结论：一个是系统方案选型；另一个是建立协作机制。</p><p>首先，由于时间紧任务重，我们决定使用更易于协作的前后端分离的开发模式</p><p>技术框架方面，由于大家对前后端分离的模式达成了共识，我们就采用Python+Django+VUE 的方式来做。</p><p>在项目协作方面，我等会儿会专门提到，由于团队成员分散在北京、上海两地，彼此之间不够熟悉和信任，所以，建立固定的沟通机制就非常重要。</p><p><strong>建立沟通机制</strong></p><ul><li>一次是面向全员的。一方面同步项目的最新进展，另一方面，也给大家一些紧迫感，让大家觉得“其他人都在按照计划执行，自己也不能落后”。</li><li>另外一次是面向跨地域骨干的。这主要还是为了增进联系，并且对一些核心问题进行二次的进展确认。不拉上全员，也是为了避免过多地浪费项目成员的时间。</li></ul><p>最后，项目毕竟还是有一些技术风险的，所以还需要启动预研。<strong>预研项目的一些技术风险。</strong></p><p>项目启动阶段要重点关注的几件事情：</p><ul><li>明确项目目标，树立团队的信心；</li><li>沟通开发模式和技术架构选型，以快速开发和简单上手为导向；</li><li>建立沟通渠道，保持高频联系；</li><li>识别项目的技术风险，提前开启专项预研。</li></ul><h3 id="开发策略"><a href="#开发策略" class="headerlink" title="开发策略"></a>开发策略</h3><p>首先，就是研发环境容器化。</p><p>其次，就是选择分支策略。虽然 DevOps 倡导的是主干开发，但是我们还是选择了“三分支”的策略，因为我们搭建了三套环境。</p><h3 id="开发协作流程"><a href="#开发协作流程" class="headerlink" title="开发协作流程"></a>开发协作流程</h3><p>在工具层面，我们使用了 Jira。</p><p>在 Jira 里面，我们采用了精益看板加上迭代的方式，基本上两周一个迭代，保持开发交付的节奏。</p><p>需求统一纳入 Backlog 管理，当迭代开始时，就拖入待开发状态，研发挑选任务启动开发，并进入开发中。当开发完成后，也就意味着功能已经在测试环境部署。这个时候，就可以等待功能验收。只有在验收通过之后，才会发布到预发布环境。并经过二次验收后，最终上线发布给用户。</p><p><strong>开发流程</strong></p><p><img src="/assets/images/ops/devops/image-20200911115807613.png" alt="image-20200911115807613"></p><p><img src="/assets/images/ops/devops/image-20200911115824783.png" alt="image-20200911115824783"></p><p><strong>明确原则和规范</strong></p><p>对于一个新组建的团队来说，规则是消除分歧和误解的最好手段，所以一定要让这些规则足够得清晰易懂。</p><p><strong>“3-2-1”原则</strong></p><p><strong>3：创建任务三要素</strong></p><ul><li>有详细的问题说明和描述</li><li>有清晰的验收标准</li><li>有具体的经办人和迭代排期</li></ul><p><strong>2：处理任务两要素</strong></p><ul><li>在开发中，代码变更要关联 Jira 任务号</li><li>在开发完成后，要添加 Jira 注释，说明改动内容和影响范围</li></ul><p><strong>1：解决任务一要素</strong></p><ul><li>问题报告人负责任务验收关闭</li></ul><p>当然，团队规则远不止这几条。你要打造自己团队内部的规则，并且反复地强调规则，帮助<br>大家养成习惯。这样一来，你会发现，研发效率提升和自组织团队都会慢慢成为现实。</p><p>除此之外，你也不要高估人的主动性，期望每个人都能自觉地按照规则执行。定期和及时的提醒就非常必要。比如，每天增加定时邮件通知，告诉大家有哪些需求需要验收，有哪些可以上线发布，尽量让每个人都明白应该去哪里获取最新的信息。</p><p>另外，每次开周会时，都要强调规则的执行情况，甚至每天的站会也要按需沟通。只有保持短促、高频的沟通，才能产生理想的效果。</p><h3 id="产品运营策略"><a href="#产品运营策略" class="headerlink" title="产品运营策略"></a>产品运营策略</h3><p>团队不仅要做得好，还要善于运营和宣传，而这又是技术团队的一大软肋。</p><p><strong>建立内部用户沟通群</strong>，在产品初期尽量选择一些活跃的种子用户来试用。那些特别感兴趣、愿意尝试新事物、不断给你提建议的都是超级用户。这些用户未来都是各个团队中的“星星之火”，在项目初期，你一定要识别出这些用户。</p><p>另外，每一次上线都发布一个 release notes，并通过邮件和内部沟通群的方式通知全员，一方面可以宣传新功能，另一方面，也是很重要的一方面，就是<strong>保持存在感的刷新。</strong></p><p><strong>内部建立 OnCall 机制</strong>，每周团队成员轮值解决一线用户的问题，既可以保证问题的及时收敛，也能让远离用户的开发真真切切地听到用户的声音。</p><p>平台运营就跟打广告是一样的，越是在人流最大、关注度最高的地方打广告，效果也就越好。每个公司一般都有类似的首页，比如公司内部的技术首页、技术论坛、日常办公的 OA系统等等，这些地方其实都会有宣传的渠道和入口。你要做的就是找到这个入口，并联系上负责这个渠道的人员。</p><p>另一个方法有些取巧，但对于技术团队来说，也非常适用，那就是通过技术分享的渠道来宣传产品。</p><p><img src="/assets/images/ops/devops/image-20200911120423420.png" alt="image-20200911120423420"></p><h3 id="团队文化建设"><a href="#团队文化建设" class="headerlink" title="团队文化建设"></a>团队文化建设</h3><p>无论什么样的工具、流程、目标，最终都是依靠人来完成的。如果忽略对人的关注，就等同于本末倒置，不是一个成熟的团队管理者应该做的事情。</p><ol><li>让专业的人做专业的事情</li><li>抓大放小，适当地忽略细节</li></ol><h2 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h2><h3 id="端到端流水线解决方案"><a href="#端到端流水线解决方案" class="headerlink" title="端到端流水线解决方案"></a>端到端流水线解决方案</h3><p><img src="/assets/images/ops/devops/image-20200914110423050.png" alt="image-20200914110423050"></p><ul><li><p>需求管理 - Jira</p></li><li><p>代码管理 - GitLab</p></li><li><p>代码质量 - SonarQube</p></li><li><p>环境管理 - Kubernetes</p></li></ul><h2 id="Devops工程师必备的技能"><a href="#Devops工程师必备的技能" class="headerlink" title="Devops工程师必备的技能"></a>Devops工程师必备的技能</h2><h3 id="DevOps-技能发展路线图"><a href="#DevOps-技能发展路线图" class="headerlink" title="DevOps 技能发展路线图"></a>DevOps 技能发展路线图</h3><p><img src="https://cdn.jsdelivr.net/gh/kamranahmedse/developer-roadmap@master/translations/chinese/img/devops-map.png" alt="devops-map"></p><h3 id="DevOps-工程师的岗位职责"><a href="#DevOps-工程师的岗位职责" class="headerlink" title="DevOps 工程师的岗位职责"></a>DevOps 工程师的岗位职责</h3><p>除了基础的岗位职责外，还需额外关注 3 个方面</p><ol><li>工具平台开发, 工具是自动化的载体，而自动化可以说是 DevOps 的灵魂。</li><li>流程实践落地,理念和实践的宣导，内部员工的培训，持续探索和发现流程的潜在优化点，这些也都<br>是 DevOps 工程师要考虑的事情。</li><li>技术预研试点, 结合公司的实际情况，评估潜在的工具和解决方案, 开展 DevOps 的理念宣导和技术培训，鼓动领导参加行业的大会，</li></ol><h3 id="DevOps-工程师的主要技能"><a href="#DevOps-工程师的主要技能" class="headerlink" title="DevOps 工程师的主要技能"></a>DevOps 工程师的主要技能</h3><p>DevOps 工程师的核心能力模型: </p><p>其中，能力模型分为两个方面：专业能力和通用能力。</p><p>专业能力也就是常说的硬实力，是IT 从业人员身上的特有能力，比如软件工程师会写代码，就跟导演会拍电影，司机会开车一样。而通用能力，更加接近于软实力，这些能力并不局限于某一个岗位或者职业，是所有人都应该努力培养的能力。很多时候，当硬实力到达天花板之后，软实力的差异将决定一个人未来的高度，这一点非常重要。</p><p><strong>软实力</strong></p><ol><li>沟通能力，在推动 DevOps 落地的过程中，你需要同时具备向上沟通、向下沟通和横向沟通的能力。</li><li>同理心，共享目标,共担责任,这种同理心也是弥合团队分歧，建立良好的协作文化所必需的能力。</li><li>学习能力，在有限的时间里快速学习新的技能，并且有意愿主动地改进提升，也是一种能力。</li></ol><p><strong>硬实力</strong></p><ol><li>代码能力，代码能力包含两个方面，分别是脚本语言能力和高级语言编程能力。</li><li>自动化能力，无论是开源工具，还是自研工具，工具与工具之间的链路打通也是自动化的重要因素。</li><li>IT 基础能力，对于基础概念，还是需要既知其然，也知其所以然。</li><li>容器云能力，在云时代，基于容器技术的应用开发和部署方式，都是DevOps 工程师必须了解的。</li><li>业务和流程能力，企业需要的不仅仅是一个工具，而是工具所关联的一整套解决方案，其中最重要的就是业务流程。对于 DevOps 工程师来说，要有能力发现当前流程中的瓶颈点，并且知道一个更加优化的流程应该是怎样的。</li></ol><h3 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h3><p>基于过往在公司内部推行 DevOps 的经验，以及当前行业的发展趋势，我有几条建议送给你：</p><ol><li><p>集中强化代码能力</p></li><li><p>培养跨职能领域核心能力</p></li><li><p>DevOps 核心理念和业务思维</p></li><li><p>潜移默化的软实力建设</p></li><li><p>勤练习，多总结</p></li></ol><h2 id="推荐读物"><a href="#推荐读物" class="headerlink" title="推荐读物"></a>推荐读物</h2><p><strong>报告</strong></p><p>​    《DevOps 状态报告》</p><p>​    关注点：1.看趋势， 2.看模型，3看实践</p><p>​    <a href="https://pan.baidu.com/s/1W7-_et-wulD7AueBU2KTow">https://pan.baidu.com/s/1W7-_et-wulD7AueBU2KTow</a> 提取码：mgl1</p><p><strong>书籍</strong></p><blockquote><p>电子读物可以去 微信读书 APP中搜索</p></blockquote><ul><li><p>关于DevOps 工程实践</p><p>《持续交付》&amp;《持续交付 2.0》</p></li><li><p>关于管理实践和精益方面</p><p>《精益创业》&amp;《 Scrum 精髓》&amp;《精益产品开发》&amp;《精益开发与看板方法》</p></li><li><p>关于DevOps 的全貌以及核心理论体系和实践</p><p>《DevOps 实践指南》&amp;《Accelerate：加速》</p></li></ul><p><strong>小说</strong></p><p>​    《凤凰项目》&amp;《人月神话》&amp;《目标》</p><p><strong>大会，网站和博客</strong></p><ul><li><a href="https://events.itrevolution.com/">DEOS</a> ：DevOps国际峰会，以案例总结著称；</li><li><a href="https://devopsdays.org/">DevOpsDays</a>：大名鼎鼎的DevOpsDays社区；</li><li><a href="https://thenewstack.io/">TheNewStack</a> ：综合性网站，盛产高质量的电子书；</li><li><a href="https://devops.com/">DevOps.com</a> ：综合性网站；</li><li><a href="https://dzone.com/">DZone</a> ： 综合性网站，盛产高质量的电子书；</li><li><a href="https://devblogs.microsoft.com/devops/">Azure DevOps</a>：综合性网站，盛产高质量的电子书；</li><li><a href="https://www.martinfowler.com/bliki/">Martin Fowler</a> ：Martin Fowler的博客；</li><li><a href="https://www.cloudbees.com/devops">CloudBees Devops</a> ：Jenkins背后的公司的博客。</li></ul><hr><blockquote><p>本文是对  极客时间 的 &lt;&lt; DevOps实战笔记 &gt;&gt; 的总结。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 凭证管理, 看着一篇就够了~</title>
      <link href="2020/05/15/jenkins-ping-zheng-guan-li/"/>
      <url>2020/05/15/jenkins-ping-zheng-guan-li/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>许多三方网站和应用可以与Jenkins交互，如Artifact仓库，基于云的存储系统和服务等. 在Jenkins中添加/配置credentials，Pipeline项目就可以使用 credentials 与三方应用交互</p><h2 id="Credential-类型"><a href="#Credential-类型" class="headerlink" title="Credential 类型"></a>Credential 类型</h2><p>参考： <a href="https://jenkins.io/zh/doc/book/using/using-credentials/">https://jenkins.io/zh/doc/book/using/using-credentials/</a></p><p><strong>Jenkins可以存储以下类型的credentials:</strong></p><ul><li><p>Secret text - API token之类的token (如GitHub个人访问token)</p></li><li><p>Username and password - 可以为独立的字段，也可以为冒号分隔的字符串：username:password(更多信息请参照 处理 credentials)</p></li><li><p>Secret file - 保存在文件中的加密内容</p></li><li><p>SSH Username with private key - SSH 公钥/私钥对</p></li><li><p>Certificate - a PKCS#12 证书文件 和可选密码</p></li><li><p>Docker Host Certificate Authentication credentials.</p></li></ul><h2 id="Credential-安全"><a href="#Credential-安全" class="headerlink" title="Credential 安全"></a>Credential 安全</h2><p>为了最大限度地提高安全性，在Jenins中配置的 credentials 以加密形式存储在Jenkins 主节点上（用Jenkins ID加密），并且 <code>只能通过 credentials ID</code> 在Pipeline项目中获取</p><p>这最大限度地减少了向Jenkins用户公开credentials真实内容的可能性，并且阻止了将credentials复制到另一台Jenkins实例</p><h2 id="Credential-创建"><a href="#Credential-创建" class="headerlink" title="Credential 创建"></a>Credential 创建</h2><ul><li><p>选择适合的凭证类型</p><p>  <img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027222335.png"></p></li><li><p>创建 “Username and password” 凭证<br>  <img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027223010.png"></p></li><li><p>创建 “SSH Username with private key” 凭证</p><p>  <img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027222917.png"></p></li></ul><h3 id="Credential-ID-定义"><a href="#Credential-ID-定义" class="headerlink" title="Credential ID 定义"></a>Credential ID 定义</h3><ul><li><p>在 ID 字段中，必须指定一个有意义的<code>Credential ID</code>- 例如 jenkins-user-for-xyz-artifact-repository。注意: 该字段是可选的。 如果您没有指定值, Jenkins 则Jenkins会分配一个全局唯一ID（GUID）值。</p></li><li><p><strong>请记住：</strong> 一旦设置了credential ID，就不能再进行更改。</p></li></ul><h2 id="Credential-使用"><a href="#Credential-使用" class="headerlink" title="Credential 使用"></a>Credential 使用</h2><p>参考： <a href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials">https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials</a></p><p>存储在Jenkins中的credentials可以被使用：</p><ol><li><p>适用于Jenkins的任何地方 (即全局 credentials),</p></li><li><p>通过特定的Pipeline项目/项目 (在 处理 credentials 和 使用Jenkinsfile部分了解更多信息),</p></li><li><p>由特定的Jenkins用户 (如 Pipeline 项目中<a href="https://jenkins.io/zh/doc/book/blueocean/creating-pipelines/">创建 Blue Ocean</a>的情况).</p><ul><li>Blue Ocean 自动生成一个 SSH 公共/私有密钥对, 确保 SSH 公共/私有秘钥对在继续之前已经被注册到你的Git服务器</li></ul></li></ol><p>实际使用中，下面几个场景会用到creential</p><ul><li>gitlab 访问、API调用</li><li>jenkins slave 创建</li></ul><h3 id="Credential-相关插件"><a href="#Credential-相关插件" class="headerlink" title="Credential 相关插件"></a>Credential 相关插件</h3><p><strong>注意：</strong> 上述 Credential 类型都依赖于 jenkins插件，同样jenkins pipeline 也需要这些插件的安装以支持代码片段</p><ul><li><p>Credentials Binding： <a href="https://plugins.jenkins.io/credentials-binding/">https://plugins.jenkins.io/credentials-binding/</a></p><ul><li><p><strong>For secret text, usernames and passwords, and secret files</strong></p><pre class="line-numbers language-bash"><code class="language-bash">environment <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>MAGE_REPO_CREDENTIALS <span class="token operator">=</span> credentials<span class="token punctuation">(</span><span class="token string">'COMPOSER_REPO_MAGENTO'</span><span class="token punctuation">)</span>COMPOSER_AUTH <span class="token operator">=</span> <span class="token string">""</span><span class="token string">"&amp;#123;"</span>http-basic<span class="token string">": &amp;#123;   "</span>repo.magento.com<span class="token string">": &amp;#123;       "</span>username<span class="token string">": "</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;env.MAGE_REPO_CREDENTIALS_USR&amp;#125;",</span>       <span class="token string">"password"</span><span class="token keyword">:</span> <span class="token string">"$&amp;#123;env.MAGE_REPO_CREDENTIALS_PSW&amp;#125;"</span>   <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125; &amp;#125;"""</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>For other credential types</strong></p><pre class="line-numbers language-bash"><code class="language-bash">withCredentials<span class="token punctuation">(</span><span class="token punctuation">[</span>usernamePassword<span class="token punctuation">(</span>credentialsId: <span class="token string">'amazon'</span>, usernameVariable: <span class="token string">'USERNAME'</span>, passwordVariable: <span class="token string">'PASSWORD'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>// available as an <span class="token function">env</span> variable, but will be masked <span class="token keyword">if</span> you try to print it out any <span class="token function">which</span> way// note: single quotes prevent Groovy interpolation<span class="token punctuation">;</span> expansion is by Bourne Shell, <span class="token function">which</span> is what you wantsh <span class="token string">'echo <span class="token variable">$PASSWORD</span>'</span>// also available as a Groovy variable<span class="token keyword">echo</span> USERNAME// or inside double quotes <span class="token keyword">for</span> string interpolation<span class="token keyword">echo</span> <span class="token string">"username is <span class="token variable">$USERNAME</span>"</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Jenkins Plain Credentials Plugin: <a href="https://plugins.jenkins.io/plain-credentials/">https://plugins.jenkins.io/plain-credentials/</a></p><p>  <img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027224420.png"></p></li><li><p>SSH Credentials: <a href="https://plugins.jenkins.io/ssh-credentials/">https://plugins.jenkins.io/ssh-credentials/</a></p></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li><p>为了便于管理和使用， 强烈建议使用统一的约定来指定credential ID</p></li><li><p>建议使用类似下面的format做为credential ID， 便于jenkinsfile开发时直接使用，同时在”描述“里写清楚credential的作用</p><p>  <code>gitlab-api-token、gitlab-private-key、gitlab-userpwd-pair、harbor-xxx-xxx</code></p><p>  <img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027221956.png"></p></li></ul><p><strong>实践：</strong></p><ul><li><p>如下所示，将凭证使用统一的ID命名之后，便于复用，凭证定义一次，可多次，多个地方统一使用，无论是后期维护，复用都非常方便！</p><pre class="line-numbers language-shell"><code class="language-shell">    environment &#123;        // HARBOR="harbor.devopsing.site"        HARBOR_ACCESS_KEY = credentials('harbor-userpwd-pair')        SERVER_ACCESS_KEY = credentials('deploy-userpwd-pair')            &#125;    .....    docker login --username=$&#123;HARBOR_ACCESS_KEY_USR&#125; --password=$&#123;HARBOR_ACCESS_KEY_PSW&#125; $&#123;HARBOR&#125;    sshpass -p "$&#123;SERVER_ACCESS_KEY_PSW&#125;" ssh -o StrictHostKeyChecking=no $&#123;SERVER_ACCESS_KEY_USR&#125;@$&#123;DEPLOY_SERVER&#125; "$runCmd"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins, CI/CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Agile, CI/CD, DevOps</title>
      <link href="2020/03/27/agile-cicd-devops/"/>
      <url>2020/03/27/agile-cicd-devops/</url>
      
        <content type="html"><![CDATA[<p>随着DevOps理念的普及与扩散，可能会被一大堆名字概念搞的莫名其妙，理清它们之间的关系可以帮助团队知道DevOps如何落地，改善工作流程。</p><p><strong>Here’s a quick and easy way to differentiate agile, DevOps, and CI/CD:</strong></p><ul><li>Agile focuses on processes highlighting change while accelerating delivery.</li><li>CI/CD focuses on software-defined life cycles highlighting tools that emphasize automation.</li><li>DevOps focuses on culture highlighting roles that emphasize responsiveness.</li></ul><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020224951.png"></p><h2 id="Agile-Development"><a href="#Agile-Development" class="headerlink" title="Agile Development"></a>Agile Development</h2><ul><li>拥抱变化</li><li>快速迭代</li></ul><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225036.png"></p><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI /CD"></a>CI /CD</h2><p>CI/CD 都体现了如今快节奏市场中的文化和发展原则，旨在缩短开发周期、提高软件交付效率以及实现全流程的自动化。同时，两者都有着共同的目标：让软件开发更少地依赖于手动执行的任务，在此基础上使得软件的发布更加频繁、更加安全可靠。由于有着相同的目标，因此持续集成和持续交付并非相互排斥的, 只是它们的应用范围有所不同。</p><ul><li>CI：持续集成（CONTINUOUS INTEGRATION）</li><li>CD：持续部署（CONTINUOUS DEPLOYMENT）</li><li>CD：持续交付（CONTINUOUS DELIVERY）</li></ul><h3 id="持续集成CI（Continuous-Integration）"><a href="#持续集成CI（Continuous-Integration）" class="headerlink" title="持续集成CI（Continuous Integration）"></a>持续集成CI（Continuous Integration）</h3><p>参考大师的定义: <a href="http://www.martinfowler.com/articles/continuousIntegration.html">http://www.martinfowler.com/articles/continuousIntegration.html</a></p><p>持续集成（CI）是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程</p><ul><li><p>对项目而言，持续集成（CI）的目标是确保开发人员新提交的变更是好的， 不会发生break build; 并且最终的主干分支一直处于可发布的状态，</p></li><li><p>对于开发人员而言，要求他们必须频繁地向主干提交代码，相应也可以即时得到问题的反馈。实时获取到相关错误的信息，以便快速地定位与解决问题<br><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225142.png"></p></li></ul><p>显然这个过程可以大大地提高开发人员以及整个IT团队的工作效率，避免陷入好几天得不到好的“部署产出”，影响后续的测试和交付。</p><h3 id="持续交付-（Continuous-Delivery）"><a href="#持续交付-（Continuous-Delivery）" class="headerlink" title="持续交付 （Continuous Delivery）"></a>持续交付 （Continuous Delivery）</h3><p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「预发布环境」（production-like environments）中。交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段 持续交付并不是指软件每一个改动都要尽快部署到产品环境中，它指的是任何的代码修改都可以在任何时候实时部署。<br><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225203.png"></p><p>强调：<br>1、手动部署<br>2、有部署的能力，但不一定部署</p><h3 id="持续部署（Continuous-Deployment）"><a href="#持续部署（Continuous-Deployment）" class="headerlink" title="持续部署（Continuous Deployment）"></a>持续部署（Continuous Deployment）</h3><p>代码通过评审之后，自动部署到生产环境中。持续部署是持续交付的最高阶段。 </p><p>强调<br>1、持续部署是自动的<br>2、持续部署是持续交付的最高阶段<br>3、持续交付表示的是一种能力，持续部署则是一种方式</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225227.png"></p><ul><li>DEV Development environment -开发环境，用于开发者调试使用</li><li>FAT Feature Acceptance Test environment  -功能验收测试环境，用于软件测试者测试使用</li><li>UAT User Acceptance Test environment  -用户验收测试环境，用于生产环境下的软件测试者测试使用</li><li>PRO Production environment -生产环境</li></ul><p>通过CD可以加快软件交付速度，目标用户可以在几天或几周内就收到修复后的功能与新增的功能，而无需等待数月后才更新。CD的部署频率也加快了整个流程中的反馈循环。最新版本真的解决了预期的问题吗？是否满足了用户的需求？用户就可以快速地验收并作出判断，而IT团队也可以在问题影响到开发周期之前就解决反馈的问题。持续的反馈循环使得用户与IT团队更紧密地合作，以确保能准确的理解与满足他们的需求。整个交付过程进度可视化，方便团队人员与客户了解项目的进度。</p><ul><li><p>持续集成可确保代码库中始终保持最新的代码，同时可以快速集成来自多个开发人员的代码，并确保这些代码可在多个环境中协同工作。它通常有助于减少错误并通过自动化流程来减少手动任务。CI可以实现代码的自动构建与测试，减少开发中的Bug。因此，CI适用于那些过度依赖手动任务和复杂构建过程的企业。</p></li><li><p>持续交付适用于需要缩短开发周期，更快地为目标用户提供软件的企业。CD降低了部署新软件或升级已有软件的难度，且实现了全流程的自动化，因此您的团队无需手动执行复杂繁琐的任务，从而加快反馈速度，来确保您增加的功能真正地满足用户的需求。</p></li></ul><p>此外，也有不少人认为CI是CD的前提与基础，没有CI就不能实现CD。这种说法也是比较流行的，其思路如下图。因此，不管是哪种说法，CI与CD都是DevOps工具中不可或缺的理念与方法。</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225243.png"></p><p><strong>持续交付与持续部署，到底谁应该包含谁 ?</strong></p><p>持续部署是自动化的将一切变更放到生产环境，而持续交付则有判断决策过程，并直接说“In order to do Continuous Deployment you must be doing Continuous Delivery.”</p><blockquote><p>“Continuous Delivery is sometimes confused with Continuous Deployment.Continuous Deploymentmeans that every change goes through the pipeline and automatically gets put into production, resulting in many production deployments every day. Continuous Delivery just means that you are able to do frequent deployments but may choose not to do it, usually due to businesses preferring a slower rate of deployment. In order to do Continuous Deployment you must be doing Continuous Delivery.”</p></blockquote><p>对持续交付与持续部署的关系，Martin也承认两个概念容易造成困惑，持续部署代表将所有变更自动通过流水线推到生产环境，持续交付则意味着你有能力这样做，但可以基于业务选择不这样做。</p><p>所以我不觉得两者有谁包含谁，两者在这个层面讲，一个是技术领域，一个是业务领域。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment">Continuous integration vs. continuous delivery vs. continuous deployment</a></p></li><li><p><a href="https://dzone.com/articles/continuous-integration-vs-continuous-delivery">Continuous Integration vs. Continuous Delivery</a></p></li><li><p><a href="https://www.mindtheproduct.com/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/">The Product Managers’ Guide to Continuous Delivery and DevOps</a></p></li><li><p><a href="https://theagileadmin.com/what-is-devops/">What Is DevOps?</a></p></li><li><p><a href="https://www.mabl.com/blog/what-is-cicd">What is CI/CD?</a></p></li><li><p><a href="https://www.synopsys.com/blogs/software-security/agile-cicd-devops-difference/">What’s the difference between agile, CI/CD, and DevOps</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is DevOps ?</title>
      <link href="2020/02/27/what-is-devops/"/>
      <url>2020/02/27/what-is-devops/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近几年”DevOps”这个关键词经常出现在项目开发当中，特别是随着微服务/容器/cloud在项目中的大范围应用，你不想知道都很难。作为一个伴随CI/CD到DevOps一路走来的工程师，我将分几个部分漫话DevOps以及相关的概念，作为软件开发工程师，你需要知道并且开始践行DevOps, 它应该成为你职业素养的一部分。</p><p>笔者是在2015年左右开始听说“DevOps”这个名词，最早听说并实践的一直是CI/CD （后面会介绍它们之间的关系），从CI/CD开始，你会更容易理解DevOps倡导的文化。</p></blockquote><h2 id="What-is-DevOps"><a href="#What-is-DevOps" class="headerlink" title="What is DevOps"></a>What is DevOps</h2><p><strong>DevOps 是一组用于促进开发和运维人员之间协作的过程、方法和系统的统称。</strong></p><p>Wikipedia对DevOps的定义是：</p><blockquote><p>DevOps是软件开发、运维和质量保证三个部门之间的沟通、协作和集成所采用的流程、方法和体系的一个集合。 它是人们为了及时生产软件产品或服务，以满足某个业务目标，对开发与运维之间相互依存关系的一种新的理解。 …… DevOps并不仅仅关注软件部署，它是部门间沟通协作的一组流程和方法。</p></blockquote><p>DevOps是Development和Operations的组合，是一种方法论，是一组过程、方法与系统的统称，用于促进应用开发、应用运维和质量保障（QA）部门之间的沟通、协作与整合。以期打破传统开发和运营之间的壁垒和鸿沟  </p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232721.png"></p><p>从下图中，可以看到Dev 和Ops 关注的点是不同的，并且有各自的利益和关注点，沟通必然存在障碍。<strong>一个想快速迭代，一个想稳定；一个不关心怎么部署运维，一个不清楚开发架构；由此带来的就是效率的低下，以及相互的抱怨，但是完整的项目并不是仅仅代码写完就完事了，质量/稳定/运维才是更重要的。</strong></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232740.png"></p><p>DevOps 提倡通过一系列的技术和工具降低开发和运维人员之间的隔阂，实现从开发到最终部署的全流程自动化，从而达到开发运维一体化。通过将 DevOps 的理念引入到整个系统的开发过程中，能够显著提升软件的开发效率，使得各个团队减少时间损耗，更加高效地协同工作，缩短软件交付的周期，更加适应当今快速发展的互联网时代。下面这个DevOps能力图，良好的闭环可以大大增加整体的产出</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232754.png"></p><h2 id="DevOps-与传统开发方式"><a href="#DevOps-与传统开发方式" class="headerlink" title="DevOps 与传统开发方式"></a>DevOps 与传统开发方式</h2><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232821.png"></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232836.png"></p><h2 id="Why-is-DevOps"><a href="#Why-is-DevOps" class="headerlink" title="Why is DevOps"></a>Why is DevOps</h2><p>猛得听上去，DevOps很抽象，你可能会问以前没有DevOps不是一样开发交付吗？为什么是DevOps?<br>瀑布开发，敏捷开发都听过吧？DevOps你可以理解为新的开发模型，是文化和技术的方法论，需要公司在组织文化上的变革。</p><p>DevOps早在十年前就有人提出来，但是，为什么这两年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。<strong>微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。</strong><br>因为技术在发展，项目的开发过程也需要适应新的技术和框架，微服务那么多，容器可能上千个，你怎么快速部署/维护？</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232921.png"></p><h2 id="DevOps-的好处"><a href="#DevOps-的好处" class="headerlink" title="DevOps 的好处"></a>DevOps 的好处</h2><ul><li>依托自动化工具把开发、测试、发布、部署的过程整合，实现高度自动化与高效交付。</li><li>在保证产品质量的前提下快速、频繁地发布产品。</li><li>能够即使获得用户反馈，并快速响应。</li><li>最大限度地减少风险，降低代码的出错率。</li><li>高质量的软件发布标准。整个交付过程标准化、可重复、可靠。</li><li>整个交付过程进度可视化，方便团队人员了解并控制项目进度。</li><li>团队协作更高效。</li></ul><h2 id="DevOps-带来的变革"><a href="#DevOps-带来的变革" class="headerlink" title="DevOps 带来的变革"></a>DevOps 带来的变革</h2><ul><li>角色分工：打破传统团队隔阂，让开发、运维紧密结合，高效协作</li><li>研发：专注研发、高度敏捷、持续集成</li><li>产品交付：高质量、快速、频繁、自动化、持续交付</li></ul><p>简单的说，<strong>DevOps=团队文化+流程+工具</strong></p><p>团队文化的意思很简单，就是<strong>你的团队要知道并认可DevOps理念</strong>；然后就要通过<strong>具体的流程和工具</strong>来实现这个理念。</p><p>后续，我会一点点根据自己的心得体会，慢慢总结分享对DevOps的理解</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>持续集成实践中的思考</title>
      <link href="2020/02/20/chi-xu-ji-cheng-shi-jian-zhong-de-si-kao/"/>
      <url>2020/02/20/chi-xu-ji-cheng-shi-jian-zhong-de-si-kao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在看到ThoughtWorks的一篇技术文章提到“几项与持续集成相关的反模式”, 结合自己的实践体会特别有深切体会，所以记录下来</p></blockquote><h2 id="持续集成的反模式"><a href="#持续集成的反模式" class="headerlink" title="持续集成的反模式"></a>持续集成的反模式</h2><p>最需要被点名批评的现象莫过于“持续集成剧场”了：</p><blockquote><p>很多开发者只是简单的搭建了持续集成服务器就以为在做“持续集成”，但他们实际上会遗失持续集成的关键优点而导致失败。常见的失败模式包括：虽然在一个共享的主分支上运行持续集成，但是代码提交不频繁，所以集成并没有真正的“持续”。以及在一个测试覆盖率不足，甚至是长期状态为红的情况下进行构建；或者在功能分支上运行持续集成，这会导致持续隔离。</p></blockquote><p>简而言之，这些团队并没有真正体会到持续集成的好处，而是为了完成上级的任务而演一场“我们在持续集成”的戏——这也正是这个反模式的名字由来。过去十年中，我们在众多刚开始实施持续集成的企业见过这一幕。领导认识到持续集成的好处，<strong>但是推行成了个大问题：推轻了，下面团队不愿动，技术问题解决不了；推重了，下面团队来个上有政策下有对策，领导想看什么就给你演什么——持续集成剧场就此落成。比如说你见过一个表面看起来一直是绿色但是背后连编译都不敢跑的持续集成吗？</strong> 我见过。真是一场好戏。</p><p>为了解决持续集成演戏的问题，一些规模较大的企业开始建设持续集成中心。想法很符合直觉：既然团队自己做持续集成有技术困难、还有可能变成演戏，<strong>那么我就组建一支团队专门帮他们一个个把持续集成跑通、帮他们管理持续集成服务器，</strong>持续集成的运行和统计数据都在这个中央团队手里，下面的团队总没办法演戏了吧？于是，他们又遭遇了第二个持续集成反模式：“所有团队共用一个持续集成实例”。</p><blockquote><p>那些必须使用中心化持续集成服务器的交付团队，常常依赖中心的团队去完成小的配置任务，或者在共享的基础设置和工具中排查问题，这给他们在进度上带来长时间的滞后。</p></blockquote><p>这次是康威定律带来的困难：如果每个团队使用的技术栈配置不同、技术栈配置和管理的职责仍然在每个团队中，那么技术栈演进与持续集成的演进就难免出现节拍不一致。<strong>于是管理着持续集成中心的中央团队开始疲于奔命，帮一个个项目团队修持续集成，而项目团队还感到没有得到足够的支持。</strong></p><p>第三个反模式是“企业级集成测试环境”，这也是很多组织建设持续集成中心的初衷之一：由于能执行完整端到端测试的环境稀缺，各个团队的集成测试无论如何也必须在一个瓶颈处统一调度，所以中心化管理持续集成也就顺理成章。然而，</p><blockquote><p>这些企业集成测试环境通常称为 SIT 或预生产环境）是当下持续交付常见的瓶颈。环境本身很脆弱而且维护成本很高，而这些环境通常存在一些需要由单独的环境管理团队手动配置的组件。在预生产环境的测试给出的反馈慢且不可靠，而且会重复测试那些在隔离的组件上已经测过的功能。</p></blockquote><h2 id="我的体会"><a href="#我的体会" class="headerlink" title="我的体会"></a>我的体会</h2><ol><li><p>对于上面第一个情景，很多时候我们以为有了工具就是持续集成，但是往往那些持续集成并不是那么完美，至少在我看到都是“hardcode”, 可移植性差，不能复用，维护成本高，下一个接手的人需要花时间了解上一个人做的“CI/CD”；因为在一些团队里，并不是很重视这个，认为CI/CD仅仅是个辅助的东西，当然这样跟国内项目的开发周期有关，有时候项目很小，客户催的很急，哪有时间去优化那么好，能用起来再说。当下一个项目来的时候，同样的技术栈的项目还要重新来过一次。</p></li><li><p>毕竟对于开发团队来说，CI/CD是另外一个领域的东西，虽然入门简单（按照网上的教程一个很简单demo就搞定了），但是里面的思想和业务场景需要一个个业务场景的积累，如何优化，如何标准化复用，这并不是简单的事情，其实这也是DevOps要解决的一个个痛点。</p></li><li><p>那么我们建个专业的团队做这个事情吧，就是第二个场景提到的事情，其实这也是我目前正在进行中的场景，但是随着业务开展，严格意义上还没有人用，我们就发现你搞出来了，不见得有人会用，不同的业务，不同的技术栈，你需要和Dev团队密切沟通，需要DevOps团队有广阔的技术视野，如果服务众多个不同业务团队，你可能会发现自己被动的成为了“那个业务项目的一员”；另外沟通的成本其实也不低，想法是好的有个专业的团队，但是落地不是那么容易，这不是一个人，一个团队能解决的问题。</p></li><li><p>那么如何解决这个困境？ 我认为需要企业自上而下，推广这种文化，可以从一个项目开始做推广，小步快跑，将“标准化规则”慢慢建立起来，比如分支的管理，依赖管理，CI/CD与不同技术栈的集成标准化，环境问题（内部环境,线上环境），最后衍生出来一个标准化的CI/CD平台。最后的场景是，Dev团队只关注于业务，他们只需要基于一个CI/CD模板，填写必要的环境参数等，剩下的事情不需要他们管，对于他们是透明的，他们只需要产出是什么，比如仓库，邮件通知等等。</p></li><li><p>所有的”快速复用，持续交付”都是基于大家形成的一个标准流程，没有标准，就没有”复用”，就没有快速的迭代，最后还是”半人工”的低效工作。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【读书】进化</title>
      <link href="2019/11/16/dushu-jinhua/"/>
      <url>2019/11/16/dushu-jinhua/</url>
      
        <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>最近在看这本《进化-运维技术变革与实践探索》，结合自己的一些实践，有些心得体会，并且摘录了我认为重要的或者有同感的内容。</p><ul><li><a href="https://time.geekbang.org/column/intro/63">https://time.geekbang.org/column/intro/63</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续交付看似一个简单的工具链打通，却需要突破诸多障碍-组织上，工具上，文化上</p><pre><code>- 组织上，必须打破部门墙，否则工具链肯定连不起来- 工具平台能力上，涉及多个方面：项目管理，需求管理，环境管理，配置管理，部署管理，测试管理，监控管理，服务治理</code></pre><p><strong>IT及运维的成熟度分为几个阶段:</strong></p><pre><code>1. 职能阶段: IT和运维作为独立的成本中心存在，其职能在于高效地交付一系列相对有限的核心运维能力2. 内部赋能阶段：IT 和运维专注于实现流畅的内部流程和操作规范，并持续改进，同时被动响应从业务线来的各种需求。这个阶段的运维团队追求的是以IT为中心的由内到外、自下而上的价值趋向，表现和结果3. 贡献阶段：IT 和运维团队在完成自身的营运常态化之后，可以致力于解决业务问题，积极引导IT和运维资源及服务朝着业务目标前进，成为专注于业务的运维团队。这个阶段的运维视角也发生了根本的转变，变成了以业务为导向的由外到内，自上而下的视角4. 差异化阶段：IT和运维团队同其他不同领域的业务团队积极合作，相互融合来持续交付新的产品，服务以及差异化的运营，团队能够敏捷完成产品和服务创新。这这个阶段，IT 和运维已经成为业务本身5. 转型阶段：IT 和运维团队成为持续业务改造的核心，甚至可以被用来重新定义市场和竞争规则。在这个阶段，IT和运维将成为企业的核心竞争优势</code></pre><p>运维能力是整体技术架构能力的体现，运维层面爆发的问题或故障一定是因为整体技术架构中存在问题，割裂两者，单纯看技术架构或运维都是毫无意义的</p><p>跳出运维看运维，从架构角度看运维，这种运维思路上的转变，远比单纯提升运维技术更有价值。从全局角度来看运维，考虑如何打造和体现整个技术架构的运维能力，而不是”运维”的运维能力</p><p>软件架构的目的，是将构建和维护所需的人力资源见到最低    - From 《架构整洁之道》</p><p><strong>运维接触更多的是软件生命周期中的运行维护阶段:</strong></p><ul><li><p>持续交付</p><ul><li>持续集成</li><li>持续部署</li><li>持续发布</li></ul></li><li><p>持续运维</p><ul><li>运行数据分析</li><li>体验数据分析</li><li>预案演练</li><li>故障复查</li></ul></li><li><p>持续反馈和改进</p><ul><li>效率提升</li><li>性能优化</li><li>稳定性提升</li><li>体验提升</li><li>成本控制</li></ul></li><li><p>架构优化</p><ul><li>更加高效稳定地支持业务快速发展</li></ul></li></ul><h2 id="1-运维的本质"><a href="#1-运维的本质" class="headerlink" title="1. 运维的本质"></a>1. 运维的本质</h2><p>规划以<strong>应用</strong>为核心的运维体系</p><pre><code>1. 应用业务模型  -从运维角度，属于业务范畴，不用关注太多2. 应用管理模型- 应用自身属性：应用名，功能信息，责任人，Git地址，部署结构（代码路径，日志路径，以及各类配置文件路径），启停方式，健康检测方式3. 应用运行时所依赖的基础设施和组件- 资源层面： 物理机，虚拟机，容器，HTTP服务（IP,DNS服务）- 基础组件：数据库，缓存，消息队列，存储</code></pre><p>1） 建立各个基础设施和组件的数据模型，同时识别出它们的唯一标识  （以缓存为例，namespace，容量，分区）</p><p>2） 设别出基础设施及组件可以与应用名AppName建立关联关系的属性</p><ul><li>场景1： 资源没有生命周期管理，没有建立和应用之间的关系</li><li>场景2：没有同意应用名，使得各个平台之间形成孤岛</li></ul><h2 id="2-运维体系建设"><a href="#2-运维体系建设" class="headerlink" title="2. 运维体系建设"></a>2. 运维体系建设</h2><p><strong>标准先行！！！</strong></p><p>标准化的过程实际山就是对象的识别和建模过程。形成统一的对象模型之后，各方在统一的认识下展开有效协同，然后针对不同的运维对象，抽取出它们对应的运维场景，接下来才是运维场景的自动化实现。</p><p>运维脱离对象，就没有任何意义。同样，没有理清楚对象，运维自然不得章法。</p><p><strong>标准化步骤：</strong></p><pre><code>1) 识别对象2) 识别对象属性3) 识别对象关系4) 识别对象场景a) 基础设施标准化    1) 识别对象：服务器，网络，IDC，机柜，存储，配件等    2) 识别对象属性：服务器（SN序列号，IP,厂商）；硬件配置（CPU,内存，硬盘，网卡，PCIE, BIOS）; 网络设备(厂商，型号，参数等)    3) 识别对象关系：服务器所在机柜； 虚拟机所在宿主机；机柜所在IDC 等。。拓扑结构    4) 识别对象场景： 服务器为例，日常操作：采购，入库，安装，配置，上线，下线，维修。。可视化/查询/拓扑/动态展示/级联关系/健康状态b) 应用层面的标准化    1) 识别对象：微服务在“设计阶段”被识别和确认    2) 识别对象属性：一个应用是业务逻辑的抽象    ○ 业务属性    ○ 运维属性        i. 应用元数据属性：应用名，Owner，所属业务，功能说明等        ii. 应用代码属性：语言，版本，GitLab地址        iii. 应用的部署模式： 软件包/容器        iv. 应用的目录信息，日志目录/运维脚本目录/安装目录等        v. 应用的运行脚本，如启停，监控检测脚本        vi. 应用运行时的配置参数，如端口，JVM 参数等    3) 识别对象关系        i. 应用与基础设施        ii. 应用与应用之间关系 -e.g. API依赖        iii. 应用与中间件关系    4) 识别应用场景：持续集成，持续发布，扩容，缩容，监控，容量评估，压测，限流降级  </code></pre><p><strong>运维职责：</strong></p><pre><code>- 基础架构标准化    --&gt;-选型- 基础架构服务标准化       - 基于基础架构工具原生能力进行“封装”，e.g. 创建/申请容量，扩容/缩容，服务发现/访问路由配置，监控指标，主备切换能力1. 参与制定基础架构标准并对标准进行强制约束2. 基础架构的服务化平台开发    - 平台自主化，让开发人员依赖平台能力自助完成对基础组件的需求，二不是依赖运维人员    - 如果不朝着“服务化”方向发展，运维将始终被拖累在基础组件的运维操作上</code></pre><p>应用运维体系建设： 从应用的生命周期的视角看</p><pre><code>1. 应用的创建阶段：应用需要用到哪些基础服务，在架构设计和编码阶段就要确定下来2. 应用的研发阶段：应用的持续集成体系3. 应用的上线阶段：申请应用所需服务器资源，发布软件包使其上线4. 应用的运行阶段（最核心，最重要）： 各项运行指标 -监控/报警体系      - 业务需求不断变化，需要不断“迭代更新”线上应用，依然依赖研发阶段的持续集成，并最终与线上发布形成持续交付这样的闭环体系      - 应用之间的依赖管理和链路追踪的场景      - 外部业务量的各种异常变化 （双11， 热点事件，服务器/IDC/数据库 故障） -线上稳定性保障5. 应用的销毁阶段： 清理资源，取决于最前面应用与基础服务关系模型分析和建设是否到位</code></pre><h2 id="3-配置管理数据库（CMDB）"><a href="#3-配置管理数据库（CMDB）" class="headerlink" title="3. 配置管理数据库（CMDB）"></a>3. 配置管理数据库（CMDB）</h2><p>当识别出运维对象之间的关系，并形成了统一的标准之后，就需要通过某个信息管理平台“固化”，这就是CMDB (Configuration Management DataBase).</p><p>CMDB源于20世纪80年代末的ITIL，源于传统IT运维阶段，但发扬光大确实新兴的互联网行业。</p><p>CMDB 是一个”高度定制化”的体系, 没有统一的标准。</p><p>传统运维阶段，更多是以“设备”为核心进行管理；但是到了互联网技术阶段，核心变成了“应用”</p><pre><code>- 应用名---应用配置信息- IP--资源信息 </code></pre><p>二者通过“应用名-IP”的对应关系联系在一起</p><p>CMDB是运维的基石，但是需要把精力放在运维的核心“应用”上来 - CMDB是面向“资源”的管理，应用配置是面向“应用”的管理</p><p>CMDB中如何落地应用，以及如何建立应用集群分组<br>    - 产品线 -业务团队-应用<br>    - 多环境/多IDC/多服务分组</p><p>应用-集群服务分组-资源</p><h2 id="4-运维组织架构与模式"><a href="#4-运维组织架构与模式" class="headerlink" title="4. 运维组织架构与模式"></a>4. 运维组织架构与模式</h2><pre><code>1. 运维基础平台体系建设 -CMDB,DNS管理，资源管理，偏运维自身体系建设2. 分布式中间件的服务化建设3. 持续交付体系建设 -依赖于上面两个基础体系的建设4. 稳定性体系建设 -快速定位/快付故障恢复/评估扩容5. 技术运营体系建设 -标准，指标，规则和流程  -意识</code></pre><p>跨团队协作 -1. 运维团队主动出击，沟通推进； 2. 上层支持`</p><p>Google SRE 运维模式</p><p>对SRE职责定义-负责可用性，时延，性能，效率，变更管理，监控，应急响应和容量管理等相关工作。—-&gt;”效率” 和“稳定”</p><p>CRE/云计算/AI -新的挑战 -应用运维的转型</p><h2 id="5-持续交付"><a href="#5-持续交付" class="headerlink" title="5. 持续交付"></a>5. 持续交付</h2><p>配置管理</p><pre><code>- 版本控制- 依赖管理    ○ Mavn/Ant/Gradle  建立本地Maven 源，构建时候优先从本地获取依赖包，本地源没有对应依赖时，从公网下载，同时缓存到本地- 软件配置    ○ 代码配置 -与代码运行时业务逻辑有关    ○ 应用配置 -与环境有关 （部署环境/不同机房：平台类为主；私有部署到不同客户）        § 构建配置：编程语言，构建方式。。        § 部署配置：日志目录，脚本目录。。        § 运行配置：应用启停，服务上下线，健康监测方式等        § 应用运行时与基础组件关系：依赖的数据库，缓存，消息队列等。- 环境配置 -持续交付的重中之重，最复杂的部分</code></pre><p>多环境配置管理</p><pre><code>- 开发环境- 集成环境- 预发环境- Beta环境（灰度，金丝雀）- 线上环境</code></pre><p>环境配置管理主要时针对应用对于基础设施和基础服务依赖关系的配置管理</p><p>解决方案</p><pre><code>1. 多个配置文件，构建时替换    a. 开发环境： dev_config.properties    b. 预发环境：pre_config.properties    c. 线上环境：online_cofnig.properties    这三个配置文件里的“配置项”时相同的，根据不同环境，值时不同的。 构建时，根据选定的环境对配置文件进行替换- 优点：简单直接，适合配置项变化不大情况- 缺点：没多出一个环境，就要加一个配置文件，如果配置项不断变化，管理很麻烦； 不同环境单独构建，多次打包2. 占位符（Placeholder）模板模式- 配置项的值用“变量”替换- 只保留一个config.properties；但是变量的值可能要多份- 没有解决只打包一次问题3. AutoConfig 方案- 阿里巴巴开发的Webx框架中的一个工具包，继承了Maven的配置管理方式，同时可以作为插件直接与Maven配合工作    ○ 配置校验：对与替换的值做校验，提前发现问题    ○ 只打包一次    ○ 需要基于AutroConfig 做二次开发</code></pre><p>比较敏感的配置信息（如用户名，Token，密码等）不允许放在配置文件，跟不允许明文方式</p><p>多环境建设</p><pre><code>- 1. 线下环境分类建设    ○ 不必建设多个相同的，尽量最小化    ○ 开发/测试使用环境冲突，同一应用不同版本/项目团队冲突集成测试环境- 最大程度与线上版本同步，也为开发测试环境和项目环境提供部分依赖服务开发测试环境- 偏向日常的需求开发，联调和功能验证，以最小化原则进行建设项目环境- 适用于多团队多个项目，遵循最小化原则，项目启动分配资源，结束时回收资源技术点： 网段规划（每个环境独立网段）；服务化框架的单元化调用；DNS访问策略；自动化管理- 2. 线上环境建设    ○ 生产环境- 无法百分之百模拟真实的用户场景    ○ Beta环境    ○ 预发环境    ○ 办公室生产环境</code></pre><p>持续交付流水线</p><pre><code>- 持续交付建立在上面多环节以及配置管理的基础上1. 项目需求分解- 确定多个应用的联调，测试和最终发布的计划和协同，依赖关系2. 代码提交方式 -分支策略选择3. 应用的构建  - 静态语言/动态语言    ○ 配置文件如何打包？构建时，确认部署的环境    ○ 使用docker作为编译环境</code></pre><p>发布策略- 蓝绿发布，灰度发布（金丝雀），滚动发布</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps 我们都在路上</title>
      <link href="2019/11/15/hello-devops/"/>
      <url>2019/11/15/hello-devops/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会有这个博客"><a href="#为什么会有这个博客" class="headerlink" title="为什么会有这个博客"></a>为什么会有这个博客</h2><p>工作很多年了，一直从事与持续交付，版本上线发布相关的工作，从最初连什么是“daily build”都不知道，到慢慢接触到持续集成，devops等，随着经验的积累，对devops有了一定的理解，也确定了自己今后的专注的方向。随之而来，SRE，运维慢慢进入我的视野，对于产品上线后的保障监控，我还是新手，也在慢慢学习。近几年云计算和容器的发展，促进了运维的发展，这些都是我看好的方向。</p><p>所以希望对过去的经验和知识进行总结，分享出来，这些都来自于平时在OneNote，有道笔记的积累，算是对过去知识体系的重新梳理。</p><h2 id="后面会写点什么"><a href="#后面会写点什么" class="headerlink" title="后面会写点什么"></a>后面会写点什么</h2><p>主要会围绕DevOps/Cloud相关话题展开，也会涉及其他技术栈、工具。同时也会同步分享到公众号【DevOps在路上】</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928223309.jpg"></p><p><strong>微信公众号【DevOps在路上】</strong></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928230236.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps 工具</title>
      <link href="2019/10/02/devops-gong-ju/"/>
      <url>2019/10/02/devops-gong-ju/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928233152.png" alt="devops-tools"></p><h2 id="版本控制-amp-协作开发"><a href="#版本控制-amp-协作开发" class="headerlink" title="版本控制&amp;协作开发"></a>版本控制&amp;协作开发</h2><ul><li><p>版本控制系统 Git</p><p>  Git 是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。</p></li><li><p>代码托管平台 GitLab</p><p>  GitLab 是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。开源中国代码托管平台 git.oschina.net 就是基于 GitLab 项目搭建。</p></li><li><p>代码评审工具 Gerrit</p><p>  Gerrit 是一个免费、开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件程序员，可以相互审阅彼此修改后的程序代码，决定是否能够提交，退回或者继续修改。它使用 Git 作为底层版本控制系统。</p></li><li><p>版本控制系统 Mercurial</p><p>  Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。</p></li><li><p>版本控制系统 Subversion</p><p>  Subversion 是一个版本控制系统，相对于的 RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上免费的版本控制服务多基于Subversion。</p></li><li><p>版本控制系统 Bazaar</p><p>  Bazaar 是一个分布式的版本控制系统，它发布在 GPL 许可协议之下，并可用于 Windows、GNU/Linux、UNIX 以及 Mac OS 系统。</p></li></ul><h2 id="包-amp-产品管理工具"><a href="#包-amp-产品管理工具" class="headerlink" title="包&amp;产品管理工具"></a>包&amp;产品管理工具</h2><ul><li><p>Chocolatey：Chocolatey是Windows下一款开源的命令行包管理软件 ，简单说这就是Windows的apt-get；</p></li><li><p>WiX Toolset：提供一组最强大的工具集来帮助你创建Windows安装包。该工具集从XML源代码构建你的Windows安装程序包，可以无缝集成到构建过程；</p></li></ul><h2 id="自动化构建和测试"><a href="#自动化构建和测试" class="headerlink" title="自动化构建和测试"></a>自动化构建和测试</h2><ul><li><p>Apache Ant<br>  Apache Ant是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。</p></li><li><p>Maven<br>  Maven 除了以程序构建能力为特色之外，还提供 Ant 所缺少的高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目，而使用 Ant 则需要十几行。<br>  事实上，由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目现在使用 Maven，而且公司项目采用 Maven 的比例在持续增长。开源中国的<a href="http://maven.oschina.net/">Maven 库</a></p></li><li><p>Selenium<br>Selenium (SeleniumHQ) 是 thoughtworks公司的一个集成测试的强大工具。</p></li><li><p>PyUnit<br>Python单元测试框架（The Python unit testing framework），简称为PyUnit， 是Kent Beck和Erich Gamma这两位聪明的家伙所设计的 JUnit 的Python版本。</p></li><li><p>QUnit<br>QUnit 是 jQuery 的单元测试框架。</p></li><li><p>JMeter<br>JMeter 是 Apache 组织的开放源代码项目，它是功能和性能测试的工具，100% 的用 java 实现。</p></li><li><p>Gradle<br>Gradle 就是可以使用 Groovy 来书写构建脚本的构建系统，支持依赖管理和多项目，类似 Maven，但比之简单轻便。</p></li><li><p>PHPUnit<br>PHPUnit 是一个轻量级的PHP测试框架。它是在PHP5下面对JUnit3系列版本的完整移植，是xUnit测试框架家族的一员(它们都基于模式先锋Kent Beck的设计)。</p></li></ul><h2 id="持续集成-amp-交付"><a href="#持续集成-amp-交付" class="headerlink" title="持续集成&amp;交付"></a>持续集成&amp;交付</h2><ul><li><p>Jenkins<br>  Jenkins 是一个开源的持续集成工具，使用 Java 编程语言编写的。它有助于实时检测和报告较大代码库中的单一更改。该软件可帮助开发人员快速查找和解决代码库中的问题并自动测试其构建。</p></li><li><p>Travis CI<br>  Travis 是一款流行的 CI 工具，可免费用于开源项目。在托管时，不必依赖任何平台。此 CI 工具为许多构建配置和语言提供支持，如 Node，PHP，Python，Java，Perl 等。</p></li><li><p>GoCD<br>  GoCD 是一个开源的持续集成服务器。它可轻松模拟和可视化复杂的工作流程。此 CI 工具允许持续交付，并为构建 CD Pipeline 提供直观的界面。</p></li><li><p>Bamboo<br>  Bamboo 是一个持续集成的构建服务器，可以自动构建、测试和发布，并可与 JIRA 和 Bitbucket 无缝协作。Bamboo 支持多语言和平台，如 CodeDeply、Ducker、Git，SVN、Mercurial、AWS 及 Amazon S3 bucket</p></li><li><p>GitLab CI<br>  GitLab CI 是 GitLab 的一部分。它是一个提供 API 的 Web 应用程序，可将其状态存储在数据库中。GitLab CI 可以管理项目并提供友好的用户界面，并充分利用 GitLab 所有功能</p></li></ul><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><ul><li><p>Chef<br>  Chef 是一个系统集成框架，为整个架构提供配置管理功能。</p></li><li><p>Puppet<br>  Puppet，您可以集中管理每一个重要方面，您的系统使用的是跨平台的规范语言，管理所有的单独的元素通常聚集在不同的文件，如用户， CRON作业，和主机一起显然离散元素，如包装，服务和文件。</p></li><li><p>RunDeck<br>  RunDeck 是用 Java/Grails 写的开源工具，帮助用户在数据中心或者云环境中自动化各种操作和流程。通过命令行或者web界面，用户可以对任意数量的服务器进行操作，大大降低了对服务器自动化的门槛。</p></li><li><p>Saltstack<br>  Saltstack 可以看做是func的增强版+Puppet的弱化版。使用Python编写。非常好用,快速可以基于EPEL部署。Salt 是一个开源的工具用来管理你的基础架构，可轻松管理成千上万台服务器。</p></li><li><p>Ansible<br>  Ansible 提供一种最简单的方式用于发布、管理和编排计算机系统的工具，你可在数分钟内搞定。Ansible 是一个模型驱动的配置管理器，支持多节点发布、远程任务执行。默认使用 SSH 进行远程连接。无需在被管理节点上安装附加软件，可使用各种编程语言进行扩展。</p></li></ul><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><ul><li><p>Logstash<br>Logstash 是一个应用程序日志、事件的传输、处理、管理和搜索的平台。你可以用它来统一对应用程序日志进行收集管理，提供 Web 接口用于查询和统计。</p></li><li><p>CollectD<br>Collectd 是一个守护(daemon)进程，用来收集系统性能和提供各种存储方式来存储不同值的机制。比如以RRD 文件形式。</p></li><li><p>StatsD<br>StatsD 是一个简单的网络守护进程，基于 Node.js 平台，通过 UDP 或者 TCP 方式侦听各种统计信息，包括计数器和定时器，并发送聚合信息到后端服务，例如 Graphite。</p></li><li><p>Nagios<br>Nagios 是一个监视系统运行状态和网络信息的监视系统。Nagios能监视所指定的本地或远程主机以及服务，同时提供异常通知功能等。</p></li><li><p>Ganglia<br>Ganglia 是一个跨平台可扩展的，高 性能计算系统下的分布式监控系统，如集群和网格。它是基于分层设计，它使用广泛的技术，如XML数据代表，便携数据传输，RRDtool用于数据存储和可视化。</p></li><li><p>Sensu<br>Sensu 是开源的监控框架。主要特性：高度可组合；提供一个监控代理，一个事件处理器和文档 APIs；为云而设计；Sensu 的现代化架构允许监控大规模的动态基础设施，能够通过复杂的公共网络监控几千个全球分布式的机器和服务；热情的社区。</p></li><li><p>Zabbix<br>Zabbix 是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。</p></li><li><p>ICINGA<br>ICINGA 项目是 由Michael Luebben、HendrikB?cker和JoergLinge等人发起的，他们都是现有的Nagios项目社区委员会的成员，他们承诺，新的开源项 目将完全兼容以前的Nagios应用程序及扩展功能。</p></li><li><p>Graphite<br>Graphite 是一个用于采集网站实时信息并进行统计的开源项目，可用于采集多种网站服务运行状态信息。Graphite服务平均每分钟有4800次更新操作。</p></li><li><p>Kibana<br>Kibana 是一个为 Logstash 和 ElasticSearch 提供的日志分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作</p></li></ul><h2 id="微服务-容器平台"><a href="#微服务-容器平台" class="headerlink" title="微服务/容器平台"></a>微服务/容器平台</h2><ul><li><p>OpenShift<br>OpenShift 是由红帽推出的一款面向开源开发人员开放的平台即服务(PaaS)。 OpenShift通过为开发人员提供在语言、框架和云上的更多的选择，使开发人员可以构建、测试、运行和管理他们的应用。</p></li><li><p>Cloud Foundry<br>Cloud Foundry 是VMware于2011年4月12日推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发 人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</p></li><li><p>Kubernetes<br>Kubernetes 是来自 Google 云平台的开源容器集群管理系统。基于 Docker 构建一个容器的调度服务。该系统可以自动在一个容器集群中选择一个工作容器供使用。其核心概念是 Container Pod。</p></li><li><p>Mesosphere<br>Apache Mesos 是一个集群管理器，提供了有效的、跨分布式应用或框架的资源隔离和共享，可以运行Hadoop、MPI、Hypertable、Spark。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JumpServer 架构浅解</title>
      <link href="2019/08/16/jumpserver-jia-gou/"/>
      <url>2019/08/16/jumpserver-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>Jumpserver 是一款由python编写开源的跳板机(堡垒机)系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。完全开源，GPL授权 </p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><ul><li><p>设计一个跳转网关，所有登录操作都从网关通过<br>网关具有模拟终端的功能，透明的中转ssh命令，以支持Tab,Ctrl+A,Ctrl-E等快捷键，网关既可以记录操作日志，又可以审计操作命令。</p></li><li><p>设计一个认证模块<br>为了实现认证功能，需要有个认证模块，认证信息存到数据库，用户使用跳板机首先需要认证。</p></li><li><p>设计一个授权框架<br>授权是跳板机不可缺少的部分，授权就是用户和资产的关系，将关系保存的数据库，用户登录主机需要先查授权。</p></li><li><p>设计审计模块<br>审计是为了追踪，我们支持了在线监控，命令统计，录像回放功能，供管理员审查。</p></li><li><p>用户和主机模块<br>跳板机脱离不了用户和主机，所以这两个部分是基本的模块，另外我们将主机模块扩展，实现基本CMDB功能。</p></li><li><p>Web Terminal<br>现在都流行Web操作一切，于是我们又实现了Web Terminal，供用户直接在线链接服务器，这里实现是用了Tornado来完成的，Tornado实现WebSocket特别简单。</p></li></ul><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://upload-images.jianshu.io/upload_images/2504773-75dee68102104552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20200526180743745_415773244.png"></p><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><ul><li><p><strong>Jumpserver</strong> 为管理后台, 管理员可以通过 Web 页面进行资产管理、用户管理、资产授权等操作, 用户可以通过 Web 页面进行资产登录, 文件管理等操作是核心组件（Core）, 使用 Django Class Based View 风格开发，支持 Restful API</p></li><li><p><strong>Luna</strong> 为 Web Terminal Server 前端页面, 用户使用 Web Terminal 方式登录所需要的组件 （ WebTerminalView ）<br>该组件由团队自己通过Angular 实现，Jumpserver 只提供 API，不再负责后台渲染html等。</p></li><li><p><strong>Koko(CoCo)</strong> 为 SSH Server 和 Web Terminal Server 。用户可以使用自己的账户通过 SSH 或者 Web Terminal 访问 SSH 协议和 Telnet 协议资产。KoKo(最新版)是go版本的coco，新的Jumpserver ssh/ws server, 重构了 coco 的 SSH/SFTP 服务和 Web Terminal 服务 （ WebSFTPView ）</p><p>SSH/SFTP/web terminal/web文件管理 （ WebSFTPView ）<br>实现了 SSH Server 和 Web Terminal Server 的组件，提供 SSH 和 WebSocket 接口, 使用 Paramiko 和 Flask 开发</p></li><li><p><strong>Guacamole</strong> 为 RDP 协议和 VNC 协议资产组件, 用户可以通过 Web Terminal 来连接 RDP 协议和 VNC 协议资产 (暂时只能通过 Web Terminal 来访问)<br><a href="http://guacamole.apache.org/">Guacamole</a> Apache 跳板机项目，Jumpserver 使用其组件实现 RDP 功能，Jumpserver 并没有修改其代码而是添加了额外的插件，支持 Jumpserver 调用。</p></li><li><p>Jumpserver-Python-SDK<br><a href="https://github.com/jumpserver/jumpserver-python-sdk">Jumpserver Python SDK</a>，(KoKo)Coco 目前使用该 SDK 与 Jumpserver API 交互。</p><p>为 Jumpserver ssh terminal 和 web terminal封装了一个sdk, 完成和Jumpserver 交互的一些功能</p><ul><li>Service 通用RestApi 接口类</li><li>AppService 增加了app注册等</li><li>UserService 用户使用该类</li></ul></li><li><p><strong>jms-storage-sdk</strong><br>主要作为录像存储的工具类，支持本地或其他cloud存储（e.g. oss）</p></li></ul><h3 id="端口说明"><a href="#端口说明" class="headerlink" title="端口说明"></a>端口说明</h3><ul><li><p>Jumpserver 默认端口为 8080/tcp 配置文件 jumpserver/config.yml</p></li><li><p>KoKo(Coco) 默认 SSH 端口为 2222/tcp, 默认 Web Terminal 端口为 5000/tcp 配置文件在 KoKo(CoCo)/config.yml</p></li><li><p>Guacamole 默认端口为 8081/tcp, 配置文件 /config/tomcat9/conf/server.xml</p></li><li><p>Nginx 默认端口为 80/tcp</p></li><li><p>Redis 默认端口为 6379/tcp</p></li><li><p>Mysql 默认端口为 3306/tcp</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2504773-34fe231919ab8bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20200526180806315_1173897932.png"></p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="使用技术"><a href="#使用技术" class="headerlink" title="使用技术"></a>使用技术</h3><ul><li>Python 3.6.1</li><li>Django</li><li>Angular (Luna)</li><li>go （koko）</li><li>Celery  <a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a></li><li>Redis   cache 和 celery broke</li><li>Flower - Celery monitoring tool</li><li>Guacamole (webterminal -RDP)</li><li>websoket 框架 （<a href="https://github.com/kataras/neffos%EF%BC%89">https://github.com/kataras/neffos）</a></li></ul><h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><p><code>./jms start</code> 命令将会下面服务</p><p><img src="https://upload-images.jianshu.io/upload_images/2504773-baf73e869ebd006a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20200528102354700_861856403.png"></p><ul><li><p>gunicorn  - unix系统的wsgi http服务器，负责jsm-core的http请求</p></li><li><p>Daphne  - 支持HTTP, HTTP2 和 WebSocket 的asgi的服务器，主要处理WebSocket请求</p></li><li><p>celery - 后台异步任务分发处理 -celery_ansible/celery_default<br>简单、灵活且可靠的，处理大量消息的分布式系统；专注于实时处理的异步任务队列，同时也支持任务调度</p></li><li><p>flower - 负责监控 celery worker执行情况</p></li></ul><h2 id="Web-Terminal"><a href="#Web-Terminal" class="headerlink" title="Web Terminal"></a>Web Terminal</h2><ul><li>主要通过Luna，koko 和Guacamole实现</li></ul><h3 id="Luna"><a href="#Luna" class="headerlink" title="Luna"></a>Luna</h3><ul><li><p>打开web terminal link 后，进入luna, luna 会通过api请求jms 的资源列表，进行树状展示</p></li><li><p>当需要进行RDP访问时，会向guacamole进行post请求 <code>/guacamole/api/session/ext/jumpserver/asset/add</code></p></li><li><p>使用 mstsc.js 实现web版的javascript RDP client  -<a href="https://github.com/citronneur/mstsc.js">https://github.com/citronneur/mstsc.js</a> (很老的框架)<br>使用 socket.io 和画布来绑定 mstsc.js 后端。 前端通过 rle.js 文件完成位图的解压缩</p></li><li><p>webterminal 前端由luna 里的html5 canvas 和js 渲染出来</p></li><li><p>Luna 使用了 “guacamole-common-js”: “1.1.0”， 提供了 Guacamole client的实现<br>  <a href="http://guacamole.apache.org/doc/guacamole-common-js/">http://guacamole.apache.org/doc/guacamole-common-js/</a></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>window<span class="token punctuation">"</span></span> <span class="token attr-name">[ngClass]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&amp;#123;<span class="token punctuation">'</span>active<span class="token punctuation">'</span>:view.active&amp;#125;<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elements-ssh-term</span>    <span class="token attr-name">[view]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view<span class="token punctuation">"</span></span>    <span class="token attr-name">[host]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.host<span class="token punctuation">"</span></span>    <span class="token attr-name">[sysUser]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.user<span class="token punctuation">"</span></span>    <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.type<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">'</span>ssh<span class="token punctuation">'</span><span class="token punctuation">"</span></span>  <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elements-ssh-term</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elements-guacamole</span>    <span class="token attr-name">[view]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view<span class="token punctuation">"</span></span>    <span class="token attr-name">[host]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.host<span class="token punctuation">"</span></span>    <span class="token attr-name">[sysUser]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.user<span class="token punctuation">"</span></span>    <span class="token attr-name">[remoteAppId]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.remoteApp<span class="token punctuation">"</span></span>    <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.type<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">'</span>rdp<span class="token punctuation">'</span><span class="token punctuation">"</span></span>  <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elements-guacamole</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-sftp</span> <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.type<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">'</span>sftp<span class="token punctuation">'</span><span class="token punctuation">"</span></span> <span class="token attr-name">[host]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>view.host<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-sftp</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="koko-ssh）"><a href="#koko-ssh）" class="headerlink" title="koko(ssh）"></a>koko(ssh）</h3><ul><li><p>老版本coco使用ssh python 库- Paramiko</p></li><li><p>koko 启动时候会注册到jms, 需要配置中 “BOOTSTRAP_TOKEN” 与jump server保持一致, 用于身份认证</p></li><li><p>启动之后将会监听，当有新的ssh terminal窗口打开，就会尝通过websocket 建立ssh 连接 (依赖于Daphne），基于<a href="https://github.com/gorilla/websocket">go的websocket实现</a></p></li><li><p>用户在web terminal 窗口操作时，koko 会对命令解析，和jms里的过滤规则匹配</p></li><li><p>连接中断后，开始上传录像(其实是json文件，记录了时序log)到jumpserver(/data/media)</p></li><li><p>使用了websoket 框架 - <a href="https://github.com/kataras/neffos">https://github.com/kataras/neffos</a></p><p>   <img src="https://upload-images.jianshu.io/upload_images/2504773-a244bfa8cd68b787.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20200527094248561_866134588.png"></p></li></ul><h3 id="Guacamole-rdp"><a href="#Guacamole-rdp" class="headerlink" title="Guacamole(rdp)"></a>Guacamole(rdp)</h3><ul><li>对Apache Guacamole 进行了改造，主要是Guacamole client/server war包，看不到源码改造</li><li>原生的Guacamole 本身可以单独提供 web terminal 服务，但是部署相对复杂，有单独的postgresql存储机器连接信息</li><li>改造后的Guacamole ()，也需要通过 BOOTSTRAP_TOKEN 注册到 jms</li></ul><h3 id="操作录像回放"><a href="#操作录像回放" class="headerlink" title="操作录像回放"></a>操作录像回放</h3><ul><li><p>操作的录制:   ssh 是由koko基于websocket data完成; rdp 是由Guacamole API 完成</p></li><li><p>操作的回放：由 luna进行 replay 展示的，对ssh 录像(.json) 进行分割处理,使用js渲染成动画;</p><pre><code>&lt;elements-replay-json [replay]=&quot;replay&quot; *ngIf=&quot;replay.type==&#39;json&#39;&quot;&gt;&lt;/elements-replay-json&gt;&lt;elements-replay-guacamole [replay]=&quot;replay&quot; *ngIf=&quot;replay.type==&#39;guacamole&#39;&quot;&gt;&lt;/elements-replay-guacamole&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> SRE运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JumpServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 教程</title>
      <link href="2019/07/02/markdown-guide/"/>
      <url>2019/07/02/markdown-guide/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。</p><p>Markdown具有很多优点：</p><ul><li>写作中添加简单符号即完成排版，所见即所得。让你专注于文字而不是排版。</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf等。</li><li>可以保存成纯文本</li></ul></blockquote><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>标题能显示出文章的结构。行首插入1-6个# ，每增加一个#表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p><p>注：标准语法一般在#后跟个空格再写文字</p><p><strong>示例：</strong></p><pre class="line-numbers language-text"><code class="language-text">Atx风格# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，Markdown还支持另外一种标题展示形式，使用下划线进行文本大小的控制</p><pre class="line-numbers language-text"><code class="language-text">SetText风格这是一级标题===这是二级标题---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题</p><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h2><h3 id="2-1-基本样式"><a href="#2-1-基本样式" class="headerlink" title="2.1 基本样式"></a>2.1 基本样式</h3><p>要加粗的文字左右分别用两个<em>号包起来<br> \</em>*加粗**</p><p>要倾斜的文字左右分别用一个<em>号包起来<br>\</em>斜体*</p><p>要倾斜和加粗的文字左右分别用三个<em>号包起来<br>\</em>**斜体加粗***</p><p>要加删除线的文字左右分别用两个<del>号包起来<br>\</del>~删除线~~</p><p>要加删除线的文字左右分别用两个==号包起来<br>==高亮==</p><p><strong>示例：</strong><br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del><br>==这是加粗的文字==  </p><h3 id="2-2-常用转义字符"><a href="#2-2-常用转义字符" class="headerlink" title="2.2 常用转义字符"></a>2.2 常用转义字符</h3><p>MarkDown利用了很多特殊符号标识语法，但在需要输入这些符号就需要利用转义字符来控制，避免MarkDown语法解析。</p><pre class="line-numbers language-text"><code class="language-text">\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-添加空格"><a href="#2-3-添加空格" class="headerlink" title="2.3 添加空格"></a>2.3 添加空格</h3><p>跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）, 有下面两个解决方案。</p><ul><li><p>手动输入空格 （&amp;nbsp；）。<strong>注意！</strong>此时的分号为英文分号，但是不推荐使用此方法，太麻烦！</p></li><li><p>使用全角空格。即：在全角输入状态下直接使用空格键就ok了</p></li></ul><h3 id="2-4-字体颜色"><a href="#2-4-字体颜色" class="headerlink" title="2.4 字体颜色"></a>2.4 字体颜色</h3><p>使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：</p><p><strong>示例：</strong><br><font color='#ff0000'>字体颜色</font></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p><strong>语法：</strong></p><p><strong>单行代码</strong>：代码之间分别用一个反引号包起来<br>    `代码内容`</p><p><strong>代码块</strong>：代码之间分别用三个反引号包起来，且两边的反引号单独占一行<br>```<br>  代码…<br>  代码…<br>  代码…<br>```</p><p><strong>示例：</strong></p><p>单行代码<br><code>create database hero;</code></p><p>代码块</p><pre class="line-numbers language-shell"><code class="language-shell">    function fun()&#123;         echo "这是一句非常牛逼的代码";    &#125;    fun();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">@requires_authorization<span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># A comment</span>    <span class="token keyword">print</span> <span class="token string">'hello world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-段落-amp-引用"><a href="#4-段落-amp-引用" class="headerlink" title="4. 段落&amp;引用"></a>4. 段落&amp;引用</h2><h2 id="4-1-段落"><a href="#4-1-段落" class="headerlink" title="4.1 段落"></a>4.1 段落</h2><ul><li>换行是在行尾加两个空格 [空格 + 空格 + 回车]</li></ul><h2 id="4-2-引用"><a href="#4-2-引用" class="headerlink" title="4.2 引用"></a>4.2 引用</h2><p>Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示</p><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;，三个&gt;&gt;&gt;，n个…</p><p><strong>示例：</strong></p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote><h3 id="4-3-分割线"><a href="#4-3-分割线" class="headerlink" title="4.3 分割线"></a>4.3 分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><h2 id="5-插入图片-amp-链接"><a href="#5-插入图片-amp-链接" class="headerlink" title="5.  插入图片&amp;链接"></a>5.  插入图片&amp;链接</h2><h3 id="5-1-插入图片"><a href="#5-1-插入图片" class="headerlink" title="5.1 插入图片"></a>5.1 插入图片</h3><p><strong>语法：</strong></p><p><strong>Inline</strong> (titles are optional):</p><p><code>![alt text](/path/img.jpg &quot;Title&quot;)</code></p><p><strong>Reference-style:</strong></p><p><code>![alt text][id]</code></p><ul><li>alt- 就是显示在图片下面的文字，相当于对图片内容的解释。</li><li>title- 是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</li></ul><p><strong>示例：</strong><br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&fm=27&gp=0.jpg" alt="blockchain" title="区块链"></p><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928231653.JPG"></p><p><strong>注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。</strong></p><h3 id="5-2-插入链接"><a href="#5-2-插入链接" class="headerlink" title="5.2 插入链接"></a>5.2 插入链接</h3><p><strong>Inline:</strong><br><code>An [example](http://url.com/ &quot;Title&quot;)</code></p><p><a href="http://www.baidu.com/">点击跳转至百度</a></p><h4 id="点击跳转至必应"><a href="#点击跳转至必应" class="headerlink" title="点击跳转至必应"></a><a href="http://www.bing.com/" title="必应">点击跳转至必应</a></h4><p><strong>Reference-style labels</strong> (titles are optional):</p><p><code>An [example][id]. Then, anywhere else in the doc, define the link: [id]: http://example.com/  &quot;Title&quot;</code></p><p>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].</p><p><strong>Email:</strong><br>&lt;&gt;包括的URL或邮箱地址会被自动转换成为超链接</p><p><code>An email &lt;example@example.com&gt; link.</code></p><p><a href="mailto:&#120;&#120;&#120;&#x78;&#x78;&#120;&#64;&#x31;&#50;&#54;&#46;&#x63;&#111;&#109;">&#120;&#120;&#120;&#x78;&#x78;&#120;&#64;&#x31;&#50;&#54;&#46;&#x63;&#111;&#109;</a></p><h2 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h2><h2 id="6-1-无序列表"><a href="#6-1-无序列表" class="headerlink" title="6.1 无序列表"></a>6.1 无序列表</h2><p><strong>语法:</strong><br>无序列表用 - + * 任何一种都可以</p><ul><li><p>整理知识，学习笔记</p></li><li><p>发布日记，杂文，所见所想</p><ul><li>撰写发布技术文稿（无序列表内嵌列表空二个空格）</li><li>撰写发布学术论文</li></ul></li></ul><p>注意：- + *跟内容之间都要有一个空格;<strong>整篇文档无序列表符号必须一致</strong></p><h3 id="6-2-有序列表"><a href="#6-2-有序列表" class="headerlink" title="6.2 有序列表"></a>6.2 有序列表</h3><p><strong>语法：</strong><br>数字加点</p><ol><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ol><p>注意：序号跟内容之间要有空格</p><h3 id="6-3-列表嵌套"><a href="#6-3-列表嵌套" class="headerlink" title="6.3 列表嵌套"></a>6.3 列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><ol><li>Fruit<ol><li>Apple</li><li>Orange</li><li>Peach</li><li>Banana</li></ol></li><li>Vegetable</li></ol><h3 id="6-4-列表-引用"><a href="#6-4-列表-引用" class="headerlink" title="6.4 列表+引用"></a>6.4 列表+引用</h3><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><ul><li><p><input disabled="" type="checkbox">  支持以 PDF 格式导出文稿</p></li><li><p><input disabled="" type="checkbox">  改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</p></li><li><p><input checked="" disabled="" type="checkbox">  新增 Todo 列表功能</p></li><li><p><input checked="" disabled="" type="checkbox">  修复 LaTex 公式渲染问题</p></li><li><p><input checked="" disabled="" type="checkbox">  新增 LaTex 公式编号功能</p></li><li><p>段落一</p><blockquote><p>This module implements a number of iterator building blocks inspired by constructs from APL, Haskell, and SML. Each has been recast in a form suitable for Python.</p></blockquote></li><li><p>段落二</p><blockquote><p>区块标记二</p></blockquote></li></ul><h2 id="7-表格"><a href="#7-表格" class="headerlink" title="7. 表格"></a>7. 表格</h2><p><strong>语法：</strong></p><pre class="line-numbers language-text"><code class="language-text">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注：三个短横杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p><p>示例：</p><pre class="line-numbers language-text"><code class="language-text">姓名|技能|排行:--|:--|:--刘备|哭|大哥关羽|打|二哥张飞|骂|三弟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text"><code class="language-text">| 项目        | 价格   |  数量  || --------   | -----:  | :----:  || 计算机     | \$1600 |   5     || 手机        |   \$12   |   12   || 管线        |    \$1    |  234  |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 使用</title>
      <link href="2019/02/27/vscode-usage/"/>
      <url>2019/02/27/vscode-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="Tips-总结"><a href="#Tips-总结" class="headerlink" title="Tips 总结"></a>Tips 总结</h2><h3 id="1-VSCode显示空格和tab符号"><a href="#1-VSCode显示空格和tab符号" class="headerlink" title="1. VSCode显示空格和tab符号"></a>1. VSCode显示空格和tab符号</h3><p>1.打开setting,在搜索框中输入<code>renderControlCharacters</code>,选中勾选框,即可显示tab</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/renderControlCharacters.JPG" alt="picgo"></p><p>2.在搜索框中输入<code>renderWhitespace</code>,选择all,即可显示空格.</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/renderWhitespace.JPG"></p><h2 id="插件扩展"><a href="#插件扩展" class="headerlink" title="插件扩展"></a>插件扩展</h2><ul><li><a href="https://marketplace.visualstudio.com/VSCode">https://marketplace.visualstudio.com/VSCode</a></li></ul><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><pre class="line-numbers language-text"><code class="language-text">- Markdown Preview Enhanced    预览与展示，以pdf文档样式的效果来显示内容，默认配置- Markdown Toc    生成目录，需要配置参数- Markdown PDF    可以简单地将编写的.md文件转换成PDF等格式的文件，设置常用配置- Markdownlint    语法规整和风格检查- Markdown Preview Github Stying    使用Github样式来渲染Markdown，朴素简洁- Markdown All in One    功能组合包，包含了书写Markdown需要用到的常用功能和设置（键盘快捷方式，目录，自动预览等），默认配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h3><pre class="line-numbers language-text"><code class="language-text">- Chinese (Simplified) Language Pack for Visual Studio Code：中文界面- Git History    提供可视化的 Git 版本树管理，可通过命令面板或界面按钮激活- GitLens    增强内置Git 功能, 显示丰富的git日志，文件历史、行历史等- Visual Studio IntelliCode    微软官方提供的基于 AI 辅助的自动补全功能，支持 Python、TypeScript/JavaScript和Java语言- TabNine    强大的 AI 辅助智能补全，支持几乎所有编程语言- Code Spell Checker    代码拼写检查, 检查代码中的单词拼写错误并给出错误拼写单词的建议- Settings Sync   使用GitHub Gist同步多台计算机上的设置，代码段，主题，文件图标，启动，键绑定，工作区和扩展- Code Runner    万能语言运行环境, 不用搭建各种语言的开发环境，选中一段代码直接运行，非常适合学习或测试各种开发语言- Docker    管理本地容器- filesize    在状态栏中显示当前文件大小，点击后还可以看到详细创建、修改时间- vscode-icons    文件图标，实现对各种文件类型的文件前的图标进行优化显示，，可以直接通过文件的图标快速知道文件类型- Rainbow Brackets    为圆括号，方括号和大括号提供彩虹色- Bracket Pair Colonizer 2    彩虹括号，使用彩虹色区分标注不同的括号对- Indent-Rainbow    用四种不同颜色交替着色文本前面的缩进- Log File Highlighter    日志文件高亮，主要是针对 INFO、WARN、ERROR 高亮，方便查看日志文件- TODO Highlight    高亮显示代码中的 TODO、FIXME 及其他注解- Atuo Rename Tag    修改 html 标签，自动帮你完成头部和尾部闭合标签的同步修改- RegExp Preview and Editor    通过命令面板启动，在分栏页面中编辑正则表达式，并以数据流图可视化显示正则语法结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h3><pre class="line-numbers language-text"><code class="language-text">- PDF: vscode-pdf    直接打开浏览pdf格式的二进制文件Draw.io Integration绘制流程图、脑图和UML图，新建扩展名为 .drawio、.dio 、.drawio.svg 文件即可进入编辑- https://github.com/hediet/vscode-drawio- https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Remote-Development"><a href="#Remote-Development" class="headerlink" title="Remote Development"></a>Remote Development</h3><pre class="line-numbers language-text"><code class="language-text">- Remote Development  https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack- Remote - SSH：基于 SSH 的远程开发- Remote - Containers：基于 Docker 容器的远程开发- Remote - WSL：基于 Windows Subsystem for Linux(wsl) 的远程开发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><pre class="line-numbers language-text"><code class="language-text">- Beautify 代码格式化（Javascript, JSON, CSS, Sass, and HTML）- ESLint 代码检查，关注语法规则和代码风格，可以用来保证写出语法正确、风格统一的代码。- Prettier 严格基于规则的代码格式化程序, 解析代码并使用自定义规则重新打印代码，从而实现风格一致- SonarLint<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h3><pre class="line-numbers language-text"><code class="language-text">### JavaJava Extension Pack- Debugger for Java- Language Support for Java(TM) by Red Hat- Visual Studio IntelliCode- Maven for Java- Java Test Runner- Java Dependency ViewerSpring Boot Extension Pack- Spring Boot Tools- Spring Boot Dashboard- Spring Initializer Java SupportCheckStyle for JavaJava DecompilerLombok Annotations Support### Python- Python Extension Pack- python snippets- pylint### Bash- Bash IDE- shellman- Shell-format- Bash Debug### Jenkins- JenkinsFile Support- Groovy Lint, Format and Fix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用私有gitlab搭建gitbook持续集成</title>
      <link href="2019/01/27/gitbook-gitlab/"/>
      <url>2019/01/27/gitbook-gitlab/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在项目实践中，团队需要对用到的知识技术进行总结，即便于分享，也利于传承，而gitbook就是个不错的选择，使用gitbook-cli 对Markdown文档进行编译，生成静态文件，再通过web服务器（e.g. nginx）对外提供服务。</p><p>gitbook和gitlab搭建持续集成，可实现文档的即时更新，这也是我在DevOps实践的一部分。</p><ul><li><p><a href="https://www.gitbook.com/">https://www.gitbook.com</a></p></li><li><p><a href="https://github.com/GitbookIO/gitbook">https://github.com/GitbookIO/gitbook</a></p></li></ul><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201016234543.png"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><p>gitbook 是一个基于 Node.js 的命令行工具，下载安装 <a href="https://nodejs.org/en/">Node.js</a>，安装完成之后，你可以使用下面的命令来检验是否安装成功。</p><p><code>$ node -v</code></p><h3 id="2-安装-gitbook"><a href="#2-安装-gitbook" class="headerlink" title="2. 安装 gitbook"></a>2. 安装 gitbook</h3><p>输入下面的命令来安装 gitbook</p><p><code>npm install gitbook-cli -g</code></p><p>安装完成之后，你可以使用下面的命令来检验是否安装成功</p><p><code>$ gitbook -V</code></p><p>更多详情请参照 <a href="https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md">gitbook 安装文档</a> 来安装 gitbook</p><h3 id="3-安装-Gitlab-Runner"><a href="#3-安装-Gitlab-Runner" class="headerlink" title="3. 安装 Gitlab Runner"></a>3. 安装 Gitlab Runner</h3><p>下载二进制包</p><p><code>sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</code></p><p>添加执行权限</p><p><code>sudo chmod +x /usr/local/bin/gitlab-runner</code></p><p>(可选)如果使用Docker，安装Docker</p><p><code>curl -sSL https://get.docker.com/ | sh</code></p><p>创建 GitLab CI 用户</p><p><code>sudo useradd --comment &#39;GitLab Runner&#39; --create-home gitlab-runner --shell /bin/bash</code></p><p>以Service方式安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> gitlab-runner <span class="token function">install</span> --user<span class="token operator">=</span>gitlab-runner --working-directory<span class="token operator">=</span>/home/gitlab-runner<span class="token function">sudo</span> gitlab-runner start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-注册Runner"><a href="#4-注册Runner" class="headerlink" title="4. 注册Runner"></a>4. 注册Runner</h3><ul><li><a href="https://docs.gitlab.com/runner/install/linux-manually.html">Runner安装</a>    </li><li><a href="https://docs.gitlab.com/runner/register/index.html">Runner注册</a></li></ul><p>运行以下命令</p><p><code>sudo gitlab-runner register</code></p><p>输入GitLab 实例 URL <code>Please enter the gitlab-ci coordinator URL</code></p><p>输入Gitlab注册的token (Gitlab admin权限才能看见)</p><p><code>Please enter the gitlab-ci token for this runner     xxx</code></p><p>输入Runner描述，后面可在Gitlab UI上更新</p><p><code>Please enter the gitlab-ci description for this runner</code></p><p>输入Runner Tag，后面可在Gitlab UI上更新</p><p><code>Please enter the gitlab-ci tags for this runner (comma separated):</code></p><p>选择Runner executor</p><p> <code>Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:     shell</code></p><h2 id="gitbook-配置"><a href="#gitbook-配置" class="headerlink" title="gitbook 配置"></a>gitbook 配置</h2><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h3><pre class="line-numbers language-text"><code class="language-text">        .        ├── book.json        ├── README.md        ├── SUMMARY.md        ├── chapter-1/        |   ├── README.md        |   └── something.md        └── chapter-2/            ├── README.md            └── something.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>README.md<br>gitbook第一页内容是从文件 README.md 中提取的。如果这个文件名没有出现在 SUMMARY 中，那么它会被添加为章节的第一个条目</p></li><li><p>book.json<br>该文件主要用来存放配置信息</p></li><li><p>.bookignore<br>将读取.gitignore，.bookignore以及.ignore文件以获得文件和文件夹跳过列表</p></li><li><p>Glossary.md<br>允许指定要显示为注释的术语及其各自的定义。根据这些条款，GitBook将自动构建一个索引并突出显示这些术语</p></li><li><p>SUMMARY.md<br>用于存放GitBook的文件目录信息，左侧的目录就是根据这个文件来生成的，默认对应的文件是 SUMMARY.md，可以在 book.json 重新定义该文件的对应值。它通过Markdown中的列表语法来表示文件的父子关系</p><p><strong>注意</strong> 不被SUMMARY.md包含的文件不会被gitbook处理</p><p><strong>SUMMARY.md示例：</strong></p><pre class="line-numbers language-text"><code class="language-text"># Summary* [Introduction](README.md)* [Part I](part1/README.md)    * [Writing is nice](part1/writing.md)    * [gitbook is nice](part1/gitbook.md)* [Part II](part2/README.md)    * [We love feedback](part2/feedback_please.md)    * [Better tools for authors](part2/better_tools.md)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  通过使用 标题 或者 水平分割线 将 gitbook 分为几个不同的部分，如下所示：</p><pre class="line-numbers language-text"><code class="language-text"># Summary### Part I* [Introduction](README.md)* [Writing is nice](part1/writing.md)* [gitbook is nice](part1/gitbook.md)### Part II* [We love feedback](part2/feedback_please.md)* [Better tools for authors](part2/better_tools.md)---* [Last part without title](part3/title.md)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  目录中的章节可以使用锚点指向文件的特定部分</p><pre class="line-numbers language-text"><code class="language-text"># Summary### Part I* [Part I](part1/README.md)    * [Writing is nice](part1/README.md#writing)    * [gitbook is nice](part1/README.md#gitbook)* [Part II](part2/README.md)    * [We love feedback](part2/README.md#feedback)    * [Better tools for authors](part2/README.md#tools)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2. 命令行"></a>2. 命令行</h3><ol><li><p>gitbook init</p><p> gitbook项目初始化,会自动生成两个必要的文件 README.md 和 SUMMARY.md</p></li><li><p>gitbook build [path]</p><p> 构建gitbook项目生成静态网页，会生成一个 _book 文件夹（包含了 .md 对应的.html文件）</p></li><li><p>gitbook serve</p><p>该命令实际上会首先调用 gitbook build 编译 .md，完成以后会打开一个web服务器，监听在本地的4000端口。</p><p>生产的静态文件可单独放到tomcat或者nginx供静态访问</p><pre class="line-numbers language-text"><code class="language-text">./├── _book│   ├── gitbook│   │   ├── fonts│   │   ├── gitbook.js│   │   ├── gitbook-plugin-fontsettings│   │   ├── gitbook-plugin-highlight│   │   ├── gitbook-plugin-livereload│   │   ├── gitbook-plugin-lunr│   │   ├── gitbook-plugin-search│   │   ├── gitbook-plugin-sharing│   │   ├── images│   ├── index.html│   └── search_index.json├── README.md└── SUMMARY.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>gitbook update #更新gitbook到最新版本</p></li><li><p>gitbook install    #安装依赖</p></li><li><p>gitbook builid –debug    #输出错误信息</p></li><li><p>gitbook build –log=debug  #指定log级别</p></li></ol><h3 id="3-插件"><a href="#3-插件" class="headerlink" title="3. 插件"></a>3. 插件</h3><p>gitbook 提供了丰富插件，默认带有 5 个插件，highlight、search、sharing、font-settings、livereload，如果要去除自带的插件， 可以在插件名称前面加 -，比如：</p><pre class="line-numbers language-bash"><code class="language-bash">        <span class="token string">"plugins"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token string">"-search"</span>        <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>插件使用参考</p><ul><li><a href="https://gitbook.zhangjikai.com/plugins.html">https://gitbook.zhangjikai.com/plugins.html</a></li></ul><h2 id="gitlab-与gitbook集成"><a href="#gitlab-与gitbook集成" class="headerlink" title="gitlab 与gitbook集成"></a>gitlab 与gitbook集成</h2><p><strong>.gitlab-ci.yml 示例：</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># requiring the environment of NodeJS 10</span><span class="token key atrule">image</span><span class="token punctuation">:</span> node<span class="token punctuation">:</span><span class="token number">10</span><span class="token comment" spellcheck="true"># add 'node_modules' to cache for speeding up builds</span><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">paths</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> node_modules/ <span class="token comment" spellcheck="true"># Node modules and dependencies</span><span class="token key atrule">before_script</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> npm install gitbook<span class="token punctuation">-</span>cli <span class="token punctuation">-</span>g <span class="token comment" spellcheck="true"># install gitbook</span>  <span class="token punctuation">-</span> gitbook fetch 3.2.3 <span class="token comment" spellcheck="true"># fetch final stable version</span>  <span class="token punctuation">-</span> gitbook install <span class="token comment" spellcheck="true"># add any requested plugins in book.json</span><span class="token key atrule">test</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> gitbook build . public <span class="token comment" spellcheck="true"># build to public path</span>  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> branches <span class="token comment" spellcheck="true"># this job will affect every branch except 'master'</span>  <span class="token key atrule">except</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> master<span class="token comment" spellcheck="true"># the 'pages' job will deploy and build your site to the 'public' path</span><span class="token key atrule">pages</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> gitbook build . public <span class="token comment" spellcheck="true"># build to public path</span>  <span class="token key atrule">artifacts</span><span class="token punctuation">:</span>    <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> public    <span class="token key atrule">expire_in</span><span class="token punctuation">:</span> 1 week  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> master <span class="token comment" spellcheck="true"># this job will affect only the 'master' branch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.chengweiyang.cn/gitbook/index.html">http://www.chengweiyang.cn/gitbook/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitbook, gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 后台运行进程</title>
      <link href="2018/02/27/linux-hou-tai-yun-xing-jin-cheng/"/>
      <url>2018/02/27/linux-hou-tai-yun-xing-jin-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用。</p></blockquote><h2 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h2><p><strong>比较下 &amp; 与 nohup：</strong></p><ul><li>&amp; ：后台运行，但用户终端退出时（断连），命令结束</li><li>nohup test.sh &amp; : 后台运行，用户终端退出时（断连）依然保持运行，可使用标准输入输出</li></ul><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。e.g. <code>sh test.sh &amp;</code></p><p>适合在后台运行的命令有f i n d、费时的排序及一些s h e l l脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：</p><p><code>command &gt; out.file 2&gt;&amp;1 &amp;</code><br>这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p><p>PS：当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。(ps -ef | grep 进程号 或者 kill -9 进程号）</p><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up / ignoring hangup signals) 即 忽略挂起信号一直在后台执行。</p><p><code>语法: nohup Command [ Arg … ] [&amp; ]</code></p><p><code>e.g. $nohup python manage.py runserver &amp;</code></p><p><strong>使用时注意:</strong></p><p>在当shell中提示了nohup成功后，还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；如果在nohup执行成功后直接点关闭程序按钮关闭终端的话，这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown，起不到关掉终端后调用程序继续后台运行的作用。</p><p><code>nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code></p><p>无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的nohup.out 文件中。如果当前目录的nohup.out文件不可写，输出重定向到$HOME/nohup.out文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p><p><strong>2&gt;&amp;1解析:</strong></p><p><code>command &gt;out.file 2&gt;&amp;1 &amp;</code></p><ul><li><p>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</p></li><li><p>2&gt;&amp;1 是将标准出错 重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</p></li></ul><p>试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</p><h2 id="查看后台运行的命令"><a href="#查看后台运行的命令" class="headerlink" title="查看后台运行的命令"></a>查看后台运行的命令</h2><p>有两个命令可以来查看，<code>ps</code> 和 <code>jobs</code>。区别在于 jobs 只能查看当前终端后台执行的任务，换了终端就看不见了。而ps命令适用于查看瞬时进程的动态，可以看到别的终端的任务</p><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看当前有多少在后台运行的命令</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/1603718157_20201026141913132_275681253.png"></p><p>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</p><p>“+”代表最近的一个任务（当前任务），“-”代表之前的任务。</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/1603718158_20201026143108907_1737208027.png"></p><p>只有在当前命令行中使用 nohup和&amp; 时，jobs命令才能将它显示出来。如果将他们写到 .sh 脚本中，然后执行脚本，是显示不出来的</p><p>比如执行下面这个脚本后，jobs 显示不出来：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashnohup java -Dfile.encoding=UTF-8 -Dname=Runtime-Name -server -Xms128M -Xmx512M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=256M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -jar test.jar $1 $2 $3 &<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>nohup命令可以在你退出帐户/关闭终端之后继续运行相应的进程。关闭中断后，在另一个终端<code>jobs</code>已无法看到后台跑得程序了，此时利用ps（进程查看命令）</p><p><code>ps -aux | grep &quot;test.sh&quot;  #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分</code></p><h2 id="关闭当前后台运行的程序"><a href="#关闭当前后台运行的程序" class="headerlink" title="关闭当前后台运行的程序"></a>关闭当前后台运行的程序</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><ol><li><p>通过jobs命令查看job号（假设为num），然后执行kill %num</p></li><li><p>通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid</p></li></ol><p>前台进程的终止：ctrl+c</p><h2 id="前后台进程的切换与控制"><a href="#前后台进程的切换与控制" class="headerlink" title="前后台进程的切换与控制"></a>前后台进程的切换与控制</h2><h3 id="ctrl-z-命令"><a href="#ctrl-z-命令" class="headerlink" title="ctrl + z 命令"></a>ctrl + z 命令</h3><p>将一个正在前台执行的命令放到后台，并且处于暂停状态。</p><h3 id="fg-命令"><a href="#fg-命令" class="headerlink" title="fg 命令"></a>fg 命令</h3><p>将后台中的命令 <code>调至 前台继续运行</code>。如果后台中有多个命令，可以用 <code>fg %jobnumber</code>（是命令编号，不是进程号）将选中的命令调出</p><h3 id="bg-命令"><a href="#bg-命令" class="headerlink" title="bg 命令"></a>bg 命令</h3><p>将一个在后台暂停的命令，<code>变成在后台继续执行</code>。如果后台中有多个命令，可以用<code>bg %jobnumber</code>将选中的命令调出。</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/1603718158_20201026142920042_1829517779.png"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="问题1-为什么ssh一关闭，程序就不再运行了"><a href="#问题1-为什么ssh一关闭，程序就不再运行了" class="headerlink" title="问题1-为什么ssh一关闭，程序就不再运行了"></a>问题1-为什么ssh一关闭，程序就不再运行了</h3><p>元凶：SIGHUP 信号</p><p>让我们来看看为什么关掉窗口/断开连接会使得正在运行的程序死掉。</p><p>在Linux/Unix中，有这样几个概念：</p><ul><li><p>进程组（process group）：<code>一个或多个进程的集合</code>，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。</p></li><li><p>会话期（session）：<code>一个或多个进程组的集合</code>，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。<br>会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。</p></li></ul><p>根据POSIX.1定义：</p><ul><li>挂断信号（SIGHUP）默认的动作是终止程序。</li><li>当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。</li><li>如果会话期首进程终止，则该信号发送到该会话期前台进程组。</li></ul><p>一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。（关于孤儿进程参照：<a href="http://blog.csdn.net/hmsiwtv/article/details/7901711">http://blog.csdn.net/hmsiwtv/article/details/7901711</a> ）</p><p>结论：因此当网络断开或终端窗口关闭后，也就是SSH断开以后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。</p><p>简而言之：就是ssh 打开以后，bash等都是他的子程序，一旦ssh关闭，系统将所有相关进程杀掉！！ 导致一旦ssh关闭，执行中的任务就取消了</p><p><strong>示例：</strong></p><p>打开两个SSH终端窗口，在其中一个运行top命令。</p><p><code>owen@swarm-manager-105:~$ top</code></p><p>在另一个终端窗口，找到top的进程ID为 38779，其父进程ID为38751，即登录shell。</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ ps -ef|grep topowen      24007  23571  0 16:58 tty2     00:00:01 nautilus-desktopowen      38779  38751  0 20:22 pts/1    00:00:00 top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用pstree命令可以更清楚地看到这个关系：</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ pstree -H 38779|grep top        |-sshd-+-sshd---sshd---bash---top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>ps -xj</code>命令可以看到，登录shell（PID 38751）和top在同一个会话期，shell为会话期首进程，所在进程组PGID为38751，top所在进程组PGID为38779，为前台进程组。</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ ps -xj|grep 38751 38750  38751  38751  38751 pts/1     38779 Ss    1000   0:00 -bash 38751  38779  38779  38751 pts/1     38779 S+    1000   0:03 top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关闭第一个SSH窗口，在另一个窗口中可以看到top也被杀掉了。</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ ps -ef|grep 38751owen      40412  38966  0 20:52 pts/4    00:00:00 grep --color=auto 38751<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="问题2-为什么守护程序就算ssh-打开的，就算关闭ssh也不会影响其运行？"><a href="#问题2-为什么守护程序就算ssh-打开的，就算关闭ssh也不会影响其运行？" class="headerlink" title="问题2- 为什么守护程序就算ssh 打开的，就算关闭ssh也不会影响其运行？"></a>问题2- 为什么守护程序就算ssh 打开的，就算关闭ssh也不会影响其运行？</h3><p>因为他们的程序特殊，比如httpd –k start运行这个以后，他不属于sshd这个进程组  而是单独的进程组，所以就算关闭了ssh，和他也没有任何关系！</p><pre class="line-numbers language-shell"><code class="language-shell">[owen@centos-1 ~]$ pstree |grep http        |-httpd---8*[httpd]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结论：守护进程的启动命令本身就是特殊的，和一般命令不同的，比如mysqld_safe 这样的命令 一旦使用了  就是守护进程运行。所以想把一般程序改造为守护程序是不可能，</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
