<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Agile, CI/CD, DevOps</title>
      <link href="2020/03/27/agile-cicd-devops/"/>
      <url>2020/03/27/agile-cicd-devops/</url>
      
        <content type="html"><![CDATA[<p>随着DevOps理念的普及与扩散，可能会被一大堆名字概念搞的莫名其妙，理清它们之间的关系可以帮助团队知道DevOps如何落地，改善工作流程。</p><p><strong>Here’s a quick and easy way to differentiate agile, DevOps, and CI/CD:</strong></p><ul><li>Agile focuses on processes highlighting change while accelerating delivery.</li><li>CI/CD focuses on software-defined life cycles highlighting tools that emphasize automation.</li><li>DevOps focuses on culture highlighting roles that emphasize responsiveness.</li></ul><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020224951.png"></p><h2 id="Agile-Development"><a href="#Agile-Development" class="headerlink" title="Agile Development"></a>Agile Development</h2><ul><li>拥抱变化</li><li>快速迭代</li></ul><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225036.png"></p><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI /CD"></a>CI /CD</h2><p>CI/CD 都体现了如今快节奏市场中的文化和发展原则，旨在缩短开发周期、提高软件交付效率以及实现全流程的自动化。同时，两者都有着共同的目标：让软件开发更少地依赖于手动执行的任务，在此基础上使得软件的发布更加频繁、更加安全可靠。由于有着相同的目标，因此持续集成和持续交付并非相互排斥的, 只是它们的应用范围有所不同。</p><ul><li>CI：持续集成（CONTINUOUS INTEGRATION）</li><li>CD：持续部署（CONTINUOUS DEPLOYMENT）</li><li>CD：持续交付（CONTINUOUS DELIVERY）</li></ul><h3 id="持续集成CI（Continuous-Integration）"><a href="#持续集成CI（Continuous-Integration）" class="headerlink" title="持续集成CI（Continuous Integration）"></a>持续集成CI（Continuous Integration）</h3><p>参考大师的定义: <a href="http://www.martinfowler.com/articles/continuousIntegration.html">http://www.martinfowler.com/articles/continuousIntegration.html</a></p><p>持续集成（CI）是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程</p><ul><li><p>对项目而言，持续集成（CI）的目标是确保开发人员新提交的变更是好的， 不会发生break build; 并且最终的主干分支一直处于可发布的状态，</p></li><li><p>对于开发人员而言，要求他们必须频繁地向主干提交代码，相应也可以即时得到问题的反馈。实时获取到相关错误的信息，以便快速地定位与解决问题<br><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225142.png"></p></li></ul><p>显然这个过程可以大大地提高开发人员以及整个IT团队的工作效率，避免陷入好几天得不到好的“部署产出”，影响后续的测试和交付。</p><h3 id="持续交付-（Continuous-Delivery）"><a href="#持续交付-（Continuous-Delivery）" class="headerlink" title="持续交付 （Continuous Delivery）"></a>持续交付 （Continuous Delivery）</h3><p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「预发布环境」（production-like environments）中。交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段 持续交付并不是指软件每一个改动都要尽快部署到产品环境中，它指的是任何的代码修改都可以在任何时候实时部署。<br><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225203.png"></p><p>强调：<br>1、手动部署<br>2、有部署的能力，但不一定部署</p><h3 id="持续部署（Continuous-Deployment）"><a href="#持续部署（Continuous-Deployment）" class="headerlink" title="持续部署（Continuous Deployment）"></a>持续部署（Continuous Deployment）</h3><p>代码通过评审之后，自动部署到生产环境中。持续部署是持续交付的最高阶段。 </p><p>强调<br>1、持续部署是自动的<br>2、持续部署是持续交付的最高阶段<br>3、持续交付表示的是一种能力，持续部署则是一种方式</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225227.png"></p><ul><li>DEV Development environment -开发环境，用于开发者调试使用</li><li>FAT Feature Acceptance Test environment  -功能验收测试环境，用于软件测试者测试使用</li><li>UAT User Acceptance Test environment  -用户验收测试环境，用于生产环境下的软件测试者测试使用</li><li>PRO Production environment -生产环境</li></ul><p>通过CD可以加快软件交付速度，目标用户可以在几天或几周内就收到修复后的功能与新增的功能，而无需等待数月后才更新。CD的部署频率也加快了整个流程中的反馈循环。最新版本真的解决了预期的问题吗？是否满足了用户的需求？用户就可以快速地验收并作出判断，而IT团队也可以在问题影响到开发周期之前就解决反馈的问题。持续的反馈循环使得用户与IT团队更紧密地合作，以确保能准确的理解与满足他们的需求。整个交付过程进度可视化，方便团队人员与客户了解项目的进度。</p><ul><li><p>持续集成可确保代码库中始终保持最新的代码，同时可以快速集成来自多个开发人员的代码，并确保这些代码可在多个环境中协同工作。它通常有助于减少错误并通过自动化流程来减少手动任务。CI可以实现代码的自动构建与测试，减少开发中的Bug。因此，CI适用于那些过度依赖手动任务和复杂构建过程的企业。</p></li><li><p>持续交付适用于需要缩短开发周期，更快地为目标用户提供软件的企业。CD降低了部署新软件或升级已有软件的难度，且实现了全流程的自动化，因此您的团队无需手动执行复杂繁琐的任务，从而加快反馈速度，来确保您增加的功能真正地满足用户的需求。</p></li></ul><p>此外，也有不少人认为CI是CD的前提与基础，没有CI就不能实现CD。这种说法也是比较流行的，其思路如下图。因此，不管是哪种说法，CI与CD都是DevOps工具中不可或缺的理念与方法。</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020225243.png"></p><p><strong>持续交付与持续部署，到底谁应该包含谁 ?</strong></p><p>持续部署是自动化的将一切变更放到生产环境，而持续交付则有判断决策过程，并直接说“In order to do Continuous Deployment you must be doing Continuous Delivery.”</p><blockquote><p>“Continuous Delivery is sometimes confused with Continuous Deployment.Continuous Deploymentmeans that every change goes through the pipeline and automatically gets put into production, resulting in many production deployments every day. Continuous Delivery just means that you are able to do frequent deployments but may choose not to do it, usually due to businesses preferring a slower rate of deployment. In order to do Continuous Deployment you must be doing Continuous Delivery.”</p></blockquote><p>对持续交付与持续部署的关系，Martin也承认两个概念容易造成困惑，持续部署代表将所有变更自动通过流水线推到生产环境，持续交付则意味着你有能力这样做，但可以基于业务选择不这样做。</p><p>所以我不觉得两者有谁包含谁，两者在这个层面讲，一个是技术领域，一个是业务领域。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment">Continuous integration vs. continuous delivery vs. continuous deployment</a></p></li><li><p><a href="https://dzone.com/articles/continuous-integration-vs-continuous-delivery">Continuous Integration vs. Continuous Delivery</a></p></li><li><p><a href="https://www.mindtheproduct.com/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/">The Product Managers’ Guide to Continuous Delivery and DevOps</a></p></li><li><p><a href="https://theagileadmin.com/what-is-devops/">What Is DevOps?</a></p></li><li><p><a href="https://www.mabl.com/blog/what-is-cicd">What is CI/CD?</a></p></li><li><p><a href="https://www.synopsys.com/blogs/software-security/agile-cicd-devops-difference/">What’s the difference between agile, CI/CD, and DevOps</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is DevOps ?</title>
      <link href="2020/02/27/what-is-devops/"/>
      <url>2020/02/27/what-is-devops/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近几年”DevOps”这个关键词经常出现在项目开发当中，特别是随着微服务/容器/cloud在项目中的大范围应用，你不想知道都很难。作为一个伴随CI/CD到DevOps一路走来的工程师，我将分几个部分漫话DevOps以及相关的概念，作为软件开发工程师，你需要知道并且开始践行DevOps, 它应该成为你职业素养的一部分。</p><p>笔者是在2015年左右开始听说“DevOps”这个名词，最早听说并实践的一直是CI/CD （后面会介绍它们之间的关系），从CI/CD开始，你会更容易理解DevOps倡导的文化。</p></blockquote><h2 id="What-is-DevOps"><a href="#What-is-DevOps" class="headerlink" title="What is DevOps"></a>What is DevOps</h2><p><strong>DevOps 是一组用于促进开发和运维人员之间协作的过程、方法和系统的统称。</strong></p><p>Wikipedia对DevOps的定义是：</p><blockquote><p>DevOps是软件开发、运维和质量保证三个部门之间的沟通、协作和集成所采用的流程、方法和体系的一个集合。 它是人们为了及时生产软件产品或服务，以满足某个业务目标，对开发与运维之间相互依存关系的一种新的理解。 …… DevOps并不仅仅关注软件部署，它是部门间沟通协作的一组流程和方法。</p></blockquote><p>DevOps是Development和Operations的组合，是一种方法论，是一组过程、方法与系统的统称，用于促进应用开发、应用运维和质量保障（QA）部门之间的沟通、协作与整合。以期打破传统开发和运营之间的壁垒和鸿沟  </p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232721.png"></p><p>从下图中，可以看到Dev 和Ops 关注的点是不同的，并且有各自的利益和关注点，沟通必然存在障碍。<strong>一个想快速迭代，一个想稳定；一个不关心怎么部署运维，一个不清楚开发架构；由此带来的就是效率的低下，以及相互的抱怨，但是完整的项目并不是仅仅代码写完就完事了，质量/稳定/运维才是更重要的。</strong></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232740.png"></p><p>DevOps 提倡通过一系列的技术和工具降低开发和运维人员之间的隔阂，实现从开发到最终部署的全流程自动化，从而达到开发运维一体化。通过将 DevOps 的理念引入到整个系统的开发过程中，能够显著提升软件的开发效率，使得各个团队减少时间损耗，更加高效地协同工作，缩短软件交付的周期，更加适应当今快速发展的互联网时代。下面这个DevOps能力图，良好的闭环可以大大增加整体的产出</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232754.png"></p><h2 id="DevOps-与传统开发方式"><a href="#DevOps-与传统开发方式" class="headerlink" title="DevOps 与传统开发方式"></a>DevOps 与传统开发方式</h2><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232821.png"></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232836.png"></p><h2 id="Why-is-DevOps"><a href="#Why-is-DevOps" class="headerlink" title="Why is DevOps"></a>Why is DevOps</h2><p>猛得听上去，DevOps很抽象，你可能会问以前没有DevOps不是一样开发交付吗？为什么是DevOps?<br>瀑布开发，敏捷开发都听过吧？DevOps你可以理解为新的开发模型，是文化和技术的方法论，需要公司在组织文化上的变革。</p><p>DevOps早在十年前就有人提出来，但是，为什么这两年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。<strong>微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。</strong><br>因为技术在发展，项目的开发过程也需要适应新的技术和框架，微服务那么多，容器可能上千个，你怎么快速部署/维护？</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201020232921.png"></p><h2 id="DevOps-的好处"><a href="#DevOps-的好处" class="headerlink" title="DevOps 的好处"></a>DevOps 的好处</h2><ul><li>依托自动化工具把开发、测试、发布、部署的过程整合，实现高度自动化与高效交付。</li><li>在保证产品质量的前提下快速、频繁地发布产品。</li><li>能够即使获得用户反馈，并快速响应。</li><li>最大限度地减少风险，降低代码的出错率。</li><li>高质量的软件发布标准。整个交付过程标准化、可重复、可靠。</li><li>整个交付过程进度可视化，方便团队人员了解并控制项目进度。</li><li>团队协作更高效。</li></ul><h2 id="DevOps-带来的变革"><a href="#DevOps-带来的变革" class="headerlink" title="DevOps 带来的变革"></a>DevOps 带来的变革</h2><ul><li>角色分工：打破传统团队隔阂，让开发、运维紧密结合，高效协作</li><li>研发：专注研发、高度敏捷、持续集成</li><li>产品交付：高质量、快速、频繁、自动化、持续交付</li></ul><p>简单的说，<strong>DevOps=团队文化+流程+工具</strong></p><p>团队文化的意思很简单，就是<strong>你的团队要知道并认可DevOps理念</strong>；然后就要通过<strong>具体的流程和工具</strong>来实现这个理念。</p><p>后续，我会一点点根据自己的心得体会，慢慢总结分享对DevOps的理解</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>持续集成实践中的思考</title>
      <link href="2020/02/20/devops-practices-thinking/"/>
      <url>2020/02/20/devops-practices-thinking/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在看到ThoughtWorks的一篇技术文章提到“几项与持续集成相关的反模式”, 结合自己的实践体会特别有深切体会，所以记录下来</p></blockquote><h2 id="持续集成的反模式"><a href="#持续集成的反模式" class="headerlink" title="持续集成的反模式"></a>持续集成的反模式</h2><p>最需要被点名批评的现象莫过于“持续集成剧场”了：</p><blockquote><p>很多开发者只是简单的搭建了持续集成服务器就以为在做“持续集成”，但他们实际上会遗失持续集成的关键优点而导致失败。常见的失败模式包括：虽然在一个共享的主分支上运行持续集成，但是代码提交不频繁，所以集成并没有真正的“持续”。以及在一个测试覆盖率不足，甚至是长期状态为红的情况下进行构建；或者在功能分支上运行持续集成，这会导致持续隔离。</p></blockquote><p>简而言之，这些团队并没有真正体会到持续集成的好处，而是为了完成上级的任务而演一场“我们在持续集成”的戏——这也正是这个反模式的名字由来。过去十年中，我们在众多刚开始实施持续集成的企业见过这一幕。领导认识到持续集成的好处，<strong>但是推行成了个大问题：推轻了，下面团队不愿动，技术问题解决不了；推重了，下面团队来个上有政策下有对策，领导想看什么就给你演什么——持续集成剧场就此落成。比如说你见过一个表面看起来一直是绿色但是背后连编译都不敢跑的持续集成吗？</strong> 我见过。真是一场好戏。</p><p>为了解决持续集成演戏的问题，一些规模较大的企业开始建设持续集成中心。想法很符合直觉：既然团队自己做持续集成有技术困难、还有可能变成演戏，<strong>那么我就组建一支团队专门帮他们一个个把持续集成跑通、帮他们管理持续集成服务器，</strong>持续集成的运行和统计数据都在这个中央团队手里，下面的团队总没办法演戏了吧？于是，他们又遭遇了第二个持续集成反模式：“所有团队共用一个持续集成实例”。</p><blockquote><p>那些必须使用中心化持续集成服务器的交付团队，常常依赖中心的团队去完成小的配置任务，或者在共享的基础设置和工具中排查问题，这给他们在进度上带来长时间的滞后。</p></blockquote><p>这次是康威定律带来的困难：如果每个团队使用的技术栈配置不同、技术栈配置和管理的职责仍然在每个团队中，那么技术栈演进与持续集成的演进就难免出现节拍不一致。<strong>于是管理着持续集成中心的中央团队开始疲于奔命，帮一个个项目团队修持续集成，而项目团队还感到没有得到足够的支持。</strong></p><p>第三个反模式是“企业级集成测试环境”，这也是很多组织建设持续集成中心的初衷之一：由于能执行完整端到端测试的环境稀缺，各个团队的集成测试无论如何也必须在一个瓶颈处统一调度，所以中心化管理持续集成也就顺理成章。然而，</p><blockquote><p>这些企业集成测试环境通常称为 SIT 或预生产环境）是当下持续交付常见的瓶颈。环境本身很脆弱而且维护成本很高，而这些环境通常存在一些需要由单独的环境管理团队手动配置的组件。在预生产环境的测试给出的反馈慢且不可靠，而且会重复测试那些在隔离的组件上已经测过的功能。</p></blockquote><h2 id="我的体会"><a href="#我的体会" class="headerlink" title="我的体会"></a>我的体会</h2><ol><li><p>对于上面第一个情景，很多时候我们以为有了工具就是持续集成，但是往往那些持续集成并不是那么完美，至少在我看到都是“hardcode”, 可移植性差，不能复用，维护成本高，下一个接手的人需要花时间了解上一个人做的“CI/CD”；因为在一些团队里，并不是很重视这个，认为CI/CD仅仅是个辅助的东西，当然这样跟国内项目的开发周期有关，有时候项目很小，客户催的很急，哪有时间去优化那么好，能用起来再说。当下一个项目来的时候，同样的技术栈的项目还要重新来过一次。</p></li><li><p>毕竟对于开发团队来说，CI/CD是另外一个领域的东西，虽然入门简单（按照网上的教程一个很简单demo就搞定了），但是里面的思想和业务场景需要一个个业务场景的积累，如何优化，如何标准化复用，这并不是简单的事情，其实这也是DevOps要解决的一个个痛点。</p></li><li><p>那么我们建个专业的团队做这个事情吧，就是第二个场景提到的事情，其实这也是我目前正在进行中的场景，但是随着业务开展，严格意义上还没有人用，我们就发现你搞出来了，不见得有人会用，不同的业务，不同的技术栈，你需要和Dev团队密切沟通，需要DevOps团队有广阔的技术视野，如果服务众多个不同业务团队，你可能会发现自己被动的成为了“那个业务项目的一员”；另外沟通的成本其实也不低，想法是好的有个专业的团队，但是落地不是那么容易，这不是一个人，一个团队能解决的问题。</p></li><li><p>那么如何解决这个困境？ 我认为需要企业自上而下，推广这种文化，可以从一个项目开始做推广，小步快跑，将“标准化规则”慢慢建立起来，比如分支的管理，依赖管理，CI/CD与不同技术栈的集成标准化，环境问题（内部环境,线上环境），最后衍生出来一个标准化的CI/CD平台。最后的场景是，Dev团队只关注于业务，他们只需要基于一个CI/CD模板，填写必要的环境参数等，剩下的事情不需要他们管，对于他们是透明的，他们只需要产出是什么，比如仓库，邮件通知等等。</p></li><li><p>所有的”快速复用，持续交付”都是基于大家形成的一个标准流程，没有标准，就没有”复用”，就没有快速的迭代，最后还是”半人工”的低效工作。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【读书】进化</title>
      <link href="2019/11/16/dushu-jinhua/"/>
      <url>2019/11/16/dushu-jinhua/</url>
      
        <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>最近在看这本《进化-运维技术变革与实践探索》，结合自己的一些实践，有些心得体会，并且摘录了我认为重要的或者有同感的内容。</p><ul><li><a href="https://time.geekbang.org/column/intro/63">https://time.geekbang.org/column/intro/63</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续交付看似一个简单的工具链打通，却需要突破诸多障碍-组织上，工具上，文化上</p><pre><code>- 组织上，必须打破部门墙，否则工具链肯定连不起来- 工具平台能力上，涉及多个方面：项目管理，需求管理，环境管理，配置管理，部署管理，测试管理，监控管理，服务治理</code></pre><p><strong>IT及运维的成熟度分为几个阶段:</strong></p><pre><code>1. 职能阶段: IT和运维作为独立的成本中心存在，其职能在于高效地交付一系列相对有限的核心运维能力2. 内部赋能阶段：IT 和运维专注于实现流畅的内部流程和操作规范，并持续改进，同时被动响应从业务线来的各种需求。这个阶段的运维团队追求的是以IT为中心的由内到外、自下而上的价值趋向，表现和结果3. 贡献阶段：IT 和运维团队在完成自身的营运常态化之后，可以致力于解决业务问题，积极引导IT和运维资源及服务朝着业务目标前进，成为专注于业务的运维团队。这个阶段的运维视角也发生了根本的转变，变成了以业务为导向的由外到内，自上而下的视角4. 差异化阶段：IT和运维团队同其他不同领域的业务团队积极合作，相互融合来持续交付新的产品，服务以及差异化的运营，团队能够敏捷完成产品和服务创新。这这个阶段，IT 和运维已经成为业务本身5. 转型阶段：IT 和运维团队成为持续业务改造的核心，甚至可以被用来重新定义市场和竞争规则。在这个阶段，IT和运维将成为企业的核心竞争优势</code></pre><p>运维能力是整体技术架构能力的体现，运维层面爆发的问题或故障一定是因为整体技术架构中存在问题，割裂两者，单纯看技术架构或运维都是毫无意义的</p><p>跳出运维看运维，从架构角度看运维，这种运维思路上的转变，远比单纯提升运维技术更有价值。从全局角度来看运维，考虑如何打造和体现整个技术架构的运维能力，而不是”运维”的运维能力</p><p>软件架构的目的，是将构建和维护所需的人力资源见到最低    - From 《架构整洁之道》</p><p><strong>运维接触更多的是软件生命周期中的运行维护阶段:</strong></p><ul><li><p>持续交付</p><ul><li>持续集成</li><li>持续部署</li><li>持续发布</li></ul></li><li><p>持续运维</p><ul><li>运行数据分析</li><li>体验数据分析</li><li>预案演练</li><li>故障复查</li></ul></li><li><p>持续反馈和改进</p><ul><li>效率提升</li><li>性能优化</li><li>稳定性提升</li><li>体验提升</li><li>成本控制</li></ul></li><li><p>架构优化</p><ul><li>更加高效稳定地支持业务快速发展</li></ul></li></ul><h2 id="1-运维的本质"><a href="#1-运维的本质" class="headerlink" title="1. 运维的本质"></a>1. 运维的本质</h2><p>规划以<strong>应用</strong>为核心的运维体系</p><pre><code>1. 应用业务模型  -从运维角度，属于业务范畴，不用关注太多2. 应用管理模型- 应用自身属性：应用名，功能信息，责任人，Git地址，部署结构（代码路径，日志路径，以及各类配置文件路径），启停方式，健康检测方式3. 应用运行时所依赖的基础设施和组件- 资源层面： 物理机，虚拟机，容器，HTTP服务（IP,DNS服务）- 基础组件：数据库，缓存，消息队列，存储</code></pre><p>1） 建立各个基础设施和组件的数据模型，同时识别出它们的唯一标识  （以缓存为例，namespace，容量，分区）</p><p>2） 设别出基础设施及组件可以与应用名AppName建立关联关系的属性</p><ul><li>场景1： 资源没有生命周期管理，没有建立和应用之间的关系</li><li>场景2：没有同意应用名，使得各个平台之间形成孤岛</li></ul><h2 id="2-运维体系建设"><a href="#2-运维体系建设" class="headerlink" title="2. 运维体系建设"></a>2. 运维体系建设</h2><p><strong>标准先行！！！</strong></p><p>标准化的过程实际山就是对象的识别和建模过程。形成统一的对象模型之后，各方在统一的认识下展开有效协同，然后针对不同的运维对象，抽取出它们对应的运维场景，接下来才是运维场景的自动化实现。</p><p>运维脱离对象，就没有任何意义。同样，没有理清楚对象，运维自然不得章法。</p><p><strong>标准化步骤：</strong></p><pre><code>1) 识别对象2) 识别对象属性3) 识别对象关系4) 识别对象场景a) 基础设施标准化    1) 识别对象：服务器，网络，IDC，机柜，存储，配件等    2) 识别对象属性：服务器（SN序列号，IP,厂商）；硬件配置（CPU,内存，硬盘，网卡，PCIE, BIOS）; 网络设备(厂商，型号，参数等)    3) 识别对象关系：服务器所在机柜； 虚拟机所在宿主机；机柜所在IDC 等。。拓扑结构    4) 识别对象场景： 服务器为例，日常操作：采购，入库，安装，配置，上线，下线，维修。。可视化/查询/拓扑/动态展示/级联关系/健康状态b) 应用层面的标准化    1) 识别对象：微服务在“设计阶段”被识别和确认    2) 识别对象属性：一个应用是业务逻辑的抽象    ○ 业务属性    ○ 运维属性        i. 应用元数据属性：应用名，Owner，所属业务，功能说明等        ii. 应用代码属性：语言，版本，GitLab地址        iii. 应用的部署模式： 软件包/容器        iv. 应用的目录信息，日志目录/运维脚本目录/安装目录等        v. 应用的运行脚本，如启停，监控检测脚本        vi. 应用运行时的配置参数，如端口，JVM 参数等    3) 识别对象关系        i. 应用与基础设施        ii. 应用与应用之间关系 -e.g. API依赖        iii. 应用与中间件关系    4) 识别应用场景：持续集成，持续发布，扩容，缩容，监控，容量评估，压测，限流降级  </code></pre><p><strong>运维职责：</strong></p><pre><code>- 基础架构标准化    --&gt;-选型- 基础架构服务标准化       - 基于基础架构工具原生能力进行“封装”，e.g. 创建/申请容量，扩容/缩容，服务发现/访问路由配置，监控指标，主备切换能力1. 参与制定基础架构标准并对标准进行强制约束2. 基础架构的服务化平台开发    - 平台自主化，让开发人员依赖平台能力自助完成对基础组件的需求，二不是依赖运维人员    - 如果不朝着“服务化”方向发展，运维将始终被拖累在基础组件的运维操作上</code></pre><p>应用运维体系建设： 从应用的生命周期的视角看</p><pre><code>1. 应用的创建阶段：应用需要用到哪些基础服务，在架构设计和编码阶段就要确定下来2. 应用的研发阶段：应用的持续集成体系3. 应用的上线阶段：申请应用所需服务器资源，发布软件包使其上线4. 应用的运行阶段（最核心，最重要）： 各项运行指标 -监控/报警体系      - 业务需求不断变化，需要不断“迭代更新”线上应用，依然依赖研发阶段的持续集成，并最终与线上发布形成持续交付这样的闭环体系      - 应用之间的依赖管理和链路追踪的场景      - 外部业务量的各种异常变化 （双11， 热点事件，服务器/IDC/数据库 故障） -线上稳定性保障5. 应用的销毁阶段： 清理资源，取决于最前面应用与基础服务关系模型分析和建设是否到位</code></pre><h2 id="3-配置管理数据库（CMDB）"><a href="#3-配置管理数据库（CMDB）" class="headerlink" title="3. 配置管理数据库（CMDB）"></a>3. 配置管理数据库（CMDB）</h2><p>当识别出运维对象之间的关系，并形成了统一的标准之后，就需要通过某个信息管理平台“固化”，这就是CMDB (Configuration Management DataBase).</p><p>CMDB源于20世纪80年代末的ITIL，源于传统IT运维阶段，但发扬光大确实新兴的互联网行业。</p><p>CMDB 是一个”高度定制化”的体系, 没有统一的标准。</p><p>传统运维阶段，更多是以“设备”为核心进行管理；但是到了互联网技术阶段，核心变成了“应用”</p><pre><code>- 应用名---应用配置信息- IP--资源信息 </code></pre><p>二者通过“应用名-IP”的对应关系联系在一起</p><p>CMDB是运维的基石，但是需要把精力放在运维的核心“应用”上来 - CMDB是面向“资源”的管理，应用配置是面向“应用”的管理</p><p>CMDB中如何落地应用，以及如何建立应用集群分组<br>    - 产品线 -业务团队-应用<br>    - 多环境/多IDC/多服务分组</p><p>应用-集群服务分组-资源</p><h2 id="4-运维组织架构与模式"><a href="#4-运维组织架构与模式" class="headerlink" title="4. 运维组织架构与模式"></a>4. 运维组织架构与模式</h2><pre><code>1. 运维基础平台体系建设 -CMDB,DNS管理，资源管理，偏运维自身体系建设2. 分布式中间件的服务化建设3. 持续交付体系建设 -依赖于上面两个基础体系的建设4. 稳定性体系建设 -快速定位/快付故障恢复/评估扩容5. 技术运营体系建设 -标准，指标，规则和流程  -意识</code></pre><p>跨团队协作 -1. 运维团队主动出击，沟通推进； 2. 上层支持`</p><p>Google SRE 运维模式</p><p>对SRE职责定义-负责可用性，时延，性能，效率，变更管理，监控，应急响应和容量管理等相关工作。—-&gt;”效率” 和“稳定”</p><p>CRE/云计算/AI -新的挑战 -应用运维的转型</p><h2 id="5-持续交付"><a href="#5-持续交付" class="headerlink" title="5. 持续交付"></a>5. 持续交付</h2><p>配置管理</p><pre><code>- 版本控制- 依赖管理    ○ Mavn/Ant/Gradle  建立本地Maven 源，构建时候优先从本地获取依赖包，本地源没有对应依赖时，从公网下载，同时缓存到本地- 软件配置    ○ 代码配置 -与代码运行时业务逻辑有关    ○ 应用配置 -与环境有关 （部署环境/不同机房：平台类为主；私有部署到不同客户）        § 构建配置：编程语言，构建方式。。        § 部署配置：日志目录，脚本目录。。        § 运行配置：应用启停，服务上下线，健康监测方式等        § 应用运行时与基础组件关系：依赖的数据库，缓存，消息队列等。- 环境配置 -持续交付的重中之重，最复杂的部分</code></pre><p>多环境配置管理</p><pre><code>- 开发环境- 集成环境- 预发环境- Beta环境（灰度，金丝雀）- 线上环境</code></pre><p>环境配置管理主要时针对应用对于基础设施和基础服务依赖关系的配置管理</p><p>解决方案</p><pre><code>1. 多个配置文件，构建时替换    a. 开发环境： dev_config.properties    b. 预发环境：pre_config.properties    c. 线上环境：online_cofnig.properties    这三个配置文件里的“配置项”时相同的，根据不同环境，值时不同的。 构建时，根据选定的环境对配置文件进行替换- 优点：简单直接，适合配置项变化不大情况- 缺点：没多出一个环境，就要加一个配置文件，如果配置项不断变化，管理很麻烦； 不同环境单独构建，多次打包2. 占位符（Placeholder）模板模式- 配置项的值用“变量”替换- 只保留一个config.properties；但是变量的值可能要多份- 没有解决只打包一次问题3. AutoConfig 方案- 阿里巴巴开发的Webx框架中的一个工具包，继承了Maven的配置管理方式，同时可以作为插件直接与Maven配合工作    ○ 配置校验：对与替换的值做校验，提前发现问题    ○ 只打包一次    ○ 需要基于AutroConfig 做二次开发</code></pre><p>比较敏感的配置信息（如用户名，Token，密码等）不允许放在配置文件，跟不允许明文方式</p><p>多环境建设</p><pre><code>- 1. 线下环境分类建设    ○ 不必建设多个相同的，尽量最小化    ○ 开发/测试使用环境冲突，同一应用不同版本/项目团队冲突集成测试环境- 最大程度与线上版本同步，也为开发测试环境和项目环境提供部分依赖服务开发测试环境- 偏向日常的需求开发，联调和功能验证，以最小化原则进行建设项目环境- 适用于多团队多个项目，遵循最小化原则，项目启动分配资源，结束时回收资源技术点： 网段规划（每个环境独立网段）；服务化框架的单元化调用；DNS访问策略；自动化管理- 2. 线上环境建设    ○ 生产环境- 无法百分之百模拟真实的用户场景    ○ Beta环境    ○ 预发环境    ○ 办公室生产环境</code></pre><p>持续交付流水线</p><pre><code>- 持续交付建立在上面多环节以及配置管理的基础上1. 项目需求分解- 确定多个应用的联调，测试和最终发布的计划和协同，依赖关系2. 代码提交方式 -分支策略选择3. 应用的构建  - 静态语言/动态语言    ○ 配置文件如何打包？构建时，确认部署的环境    ○ 使用docker作为编译环境</code></pre><p>发布策略- 蓝绿发布，灰度发布（金丝雀），滚动发布</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps 我们都在路上</title>
      <link href="2019/11/15/hello-devops/"/>
      <url>2019/11/15/hello-devops/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会有这个博客"><a href="#为什么会有这个博客" class="headerlink" title="为什么会有这个博客"></a>为什么会有这个博客</h2><p>工作很多年了，一直从事与持续交付，版本上线发布相关的工作，从最初连什么是“daily build”都不知道，到慢慢接触到持续集成，devops等，随着经验的积累，对devops有了一定的理解，也确定了自己今后的专注的方向。随之而来，SRE，运维慢慢进入我的视野，对于产品上线后的保障监控，我还是新手，也在慢慢学习。近几年云计算和容器的发展，促进了运维的发展，这些都是我看好的方向。</p><p>所以希望对过去的经验和知识进行总结，分享出来，这些都来自于平时在OneNote，有道笔记的积累，算是对过去知识体系的重新梳理。</p><h2 id="后面会写点什么"><a href="#后面会写点什么" class="headerlink" title="后面会写点什么"></a>后面会写点什么</h2><p>主要会围绕DevOps/Cloud相关话题展开，也会涉及其他技术栈、工具。同时也会同步分享到公众号【DevOps在路上】</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928223309.jpg"></p><p><strong>微信公众号【DevOps在路上】</strong></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928230236.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps 工具</title>
      <link href="2019/10/02/devops-tools/"/>
      <url>2019/10/02/devops-tools/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928233152.png" alt="devops-tools"></p><h2 id="版本控制-amp-协作开发"><a href="#版本控制-amp-协作开发" class="headerlink" title="版本控制&amp;协作开发"></a>版本控制&amp;协作开发</h2><ul><li><p>版本控制系统 Git</p><p>  Git 是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。</p></li><li><p>代码托管平台 GitLab</p><p>  GitLab 是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。开源中国代码托管平台 git.oschina.net 就是基于 GitLab 项目搭建。</p></li><li><p>代码评审工具 Gerrit</p><p>  Gerrit 是一个免费、开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件程序员，可以相互审阅彼此修改后的程序代码，决定是否能够提交，退回或者继续修改。它使用 Git 作为底层版本控制系统。</p></li><li><p>版本控制系统 Mercurial</p><p>  Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强。</p></li><li><p>版本控制系统 Subversion</p><p>  Subversion 是一个版本控制系统，相对于的 RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上免费的版本控制服务多基于Subversion。</p></li><li><p>版本控制系统 Bazaar</p><p>  Bazaar 是一个分布式的版本控制系统，它发布在 GPL 许可协议之下，并可用于 Windows、GNU/Linux、UNIX 以及 Mac OS 系统。</p></li></ul><h2 id="包-amp-产品管理工具"><a href="#包-amp-产品管理工具" class="headerlink" title="包&amp;产品管理工具"></a>包&amp;产品管理工具</h2><ul><li><p>Chocolatey：Chocolatey是Windows下一款开源的命令行包管理软件 ，简单说这就是Windows的apt-get；</p></li><li><p>WiX Toolset：提供一组最强大的工具集来帮助你创建Windows安装包。该工具集从XML源代码构建你的Windows安装程序包，可以无缝集成到构建过程；</p></li></ul><h2 id="自动化构建和测试"><a href="#自动化构建和测试" class="headerlink" title="自动化构建和测试"></a>自动化构建和测试</h2><ul><li><p>Apache Ant<br>  Apache Ant是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。</p></li><li><p>Maven<br>  Maven 除了以程序构建能力为特色之外，还提供 Ant 所缺少的高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目，而使用 Ant 则需要十几行。<br>  事实上，由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目现在使用 Maven，而且公司项目采用 Maven 的比例在持续增长。开源中国的<a href="http://maven.oschina.net/">Maven 库</a></p></li><li><p>Selenium<br>Selenium (SeleniumHQ) 是 thoughtworks公司的一个集成测试的强大工具。</p></li><li><p>PyUnit<br>Python单元测试框架（The Python unit testing framework），简称为PyUnit， 是Kent Beck和Erich Gamma这两位聪明的家伙所设计的 JUnit 的Python版本。</p></li><li><p>QUnit<br>QUnit 是 jQuery 的单元测试框架。</p></li><li><p>JMeter<br>JMeter 是 Apache 组织的开放源代码项目，它是功能和性能测试的工具，100% 的用 java 实现。</p></li><li><p>Gradle<br>Gradle 就是可以使用 Groovy 来书写构建脚本的构建系统，支持依赖管理和多项目，类似 Maven，但比之简单轻便。</p></li><li><p>PHPUnit<br>PHPUnit 是一个轻量级的PHP测试框架。它是在PHP5下面对JUnit3系列版本的完整移植，是xUnit测试框架家族的一员(它们都基于模式先锋Kent Beck的设计)。</p></li></ul><h2 id="持续集成-amp-交付"><a href="#持续集成-amp-交付" class="headerlink" title="持续集成&amp;交付"></a>持续集成&amp;交付</h2><ul><li><p>Jenkins<br>  Jenkins 是一个开源的持续集成工具，使用 Java 编程语言编写的。它有助于实时检测和报告较大代码库中的单一更改。该软件可帮助开发人员快速查找和解决代码库中的问题并自动测试其构建。</p></li><li><p>Travis CI<br>  Travis 是一款流行的 CI 工具，可免费用于开源项目。在托管时，不必依赖任何平台。此 CI 工具为许多构建配置和语言提供支持，如 Node，PHP，Python，Java，Perl 等。</p></li><li><p>GoCD<br>  GoCD 是一个开源的持续集成服务器。它可轻松模拟和可视化复杂的工作流程。此 CI 工具允许持续交付，并为构建 CD Pipeline 提供直观的界面。</p></li><li><p>Bamboo<br>  Bamboo 是一个持续集成的构建服务器，可以自动构建、测试和发布，并可与 JIRA 和 Bitbucket 无缝协作。Bamboo 支持多语言和平台，如 CodeDeply、Ducker、Git，SVN、Mercurial、AWS 及 Amazon S3 bucket</p></li><li><p>GitLab CI<br>  GitLab CI 是 GitLab 的一部分。它是一个提供 API 的 Web 应用程序，可将其状态存储在数据库中。GitLab CI 可以管理项目并提供友好的用户界面，并充分利用 GitLab 所有功能</p></li></ul><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><ul><li><p>Chef<br>  Chef 是一个系统集成框架，为整个架构提供配置管理功能。</p></li><li><p>Puppet<br>  Puppet，您可以集中管理每一个重要方面，您的系统使用的是跨平台的规范语言，管理所有的单独的元素通常聚集在不同的文件，如用户， CRON作业，和主机一起显然离散元素，如包装，服务和文件。</p></li><li><p>RunDeck<br>  RunDeck 是用 Java/Grails 写的开源工具，帮助用户在数据中心或者云环境中自动化各种操作和流程。通过命令行或者web界面，用户可以对任意数量的服务器进行操作，大大降低了对服务器自动化的门槛。</p></li><li><p>Saltstack<br>  Saltstack 可以看做是func的增强版+Puppet的弱化版。使用Python编写。非常好用,快速可以基于EPEL部署。Salt 是一个开源的工具用来管理你的基础架构，可轻松管理成千上万台服务器。</p></li><li><p>Ansible<br>  Ansible 提供一种最简单的方式用于发布、管理和编排计算机系统的工具，你可在数分钟内搞定。Ansible 是一个模型驱动的配置管理器，支持多节点发布、远程任务执行。默认使用 SSH 进行远程连接。无需在被管理节点上安装附加软件，可使用各种编程语言进行扩展。</p></li></ul><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><ul><li><p>Logstash<br>Logstash 是一个应用程序日志、事件的传输、处理、管理和搜索的平台。你可以用它来统一对应用程序日志进行收集管理，提供 Web 接口用于查询和统计。</p></li><li><p>CollectD<br>Collectd 是一个守护(daemon)进程，用来收集系统性能和提供各种存储方式来存储不同值的机制。比如以RRD 文件形式。</p></li><li><p>StatsD<br>StatsD 是一个简单的网络守护进程，基于 Node.js 平台，通过 UDP 或者 TCP 方式侦听各种统计信息，包括计数器和定时器，并发送聚合信息到后端服务，例如 Graphite。</p></li><li><p>Nagios<br>Nagios 是一个监视系统运行状态和网络信息的监视系统。Nagios能监视所指定的本地或远程主机以及服务，同时提供异常通知功能等。</p></li><li><p>Ganglia<br>Ganglia 是一个跨平台可扩展的，高 性能计算系统下的分布式监控系统，如集群和网格。它是基于分层设计，它使用广泛的技术，如XML数据代表，便携数据传输，RRDtool用于数据存储和可视化。</p></li><li><p>Sensu<br>Sensu 是开源的监控框架。主要特性：高度可组合；提供一个监控代理，一个事件处理器和文档 APIs；为云而设计；Sensu 的现代化架构允许监控大规模的动态基础设施，能够通过复杂的公共网络监控几千个全球分布式的机器和服务；热情的社区。</p></li><li><p>Zabbix<br>Zabbix 是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。</p></li><li><p>ICINGA<br>ICINGA 项目是 由Michael Luebben、HendrikB?cker和JoergLinge等人发起的，他们都是现有的Nagios项目社区委员会的成员，他们承诺，新的开源项 目将完全兼容以前的Nagios应用程序及扩展功能。</p></li><li><p>Graphite<br>Graphite 是一个用于采集网站实时信息并进行统计的开源项目，可用于采集多种网站服务运行状态信息。Graphite服务平均每分钟有4800次更新操作。</p></li><li><p>Kibana<br>Kibana 是一个为 Logstash 和 ElasticSearch 提供的日志分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作</p></li></ul><h2 id="微服务-容器平台"><a href="#微服务-容器平台" class="headerlink" title="微服务/容器平台"></a>微服务/容器平台</h2><ul><li><p>OpenShift<br>OpenShift 是由红帽推出的一款面向开源开发人员开放的平台即服务(PaaS)。 OpenShift通过为开发人员提供在语言、框架和云上的更多的选择，使开发人员可以构建、测试、运行和管理他们的应用。</p></li><li><p>Cloud Foundry<br>Cloud Foundry 是VMware于2011年4月12日推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发 人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</p></li><li><p>Kubernetes<br>Kubernetes 是来自 Google 云平台的开源容器集群管理系统。基于 Docker 构建一个容器的调度服务。该系统可以自动在一个容器集群中选择一个工作容器供使用。其核心概念是 Container Pod。</p></li><li><p>Mesosphere<br>Apache Mesos 是一个集群管理器，提供了有效的、跨分布式应用或框架的资源隔离和共享，可以运行Hadoop、MPI、Hypertable、Spark。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 教程</title>
      <link href="2019/07/02/markdown-guide/"/>
      <url>2019/07/02/markdown-guide/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。</p><p>Markdown具有很多优点：</p><ul><li>写作中添加简单符号即完成排版，所见即所得。让你专注于文字而不是排版。</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf等。</li><li>可以保存成纯文本</li></ul></blockquote><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>标题能显示出文章的结构。行首插入1-6个# ，每增加一个#表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p><p>注：标准语法一般在#后跟个空格再写文字</p><p><strong>示例：</strong></p><pre class="line-numbers language-text"><code class="language-text">Atx风格# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，Markdown还支持另外一种标题展示形式，使用下划线进行文本大小的控制</p><pre class="line-numbers language-text"><code class="language-text">SetText风格这是一级标题===这是二级标题---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题</p><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h2><h3 id="2-1-基本样式"><a href="#2-1-基本样式" class="headerlink" title="2.1 基本样式"></a>2.1 基本样式</h3><p>要加粗的文字左右分别用两个<em>号包起来<br> \</em>*加粗**</p><p>要倾斜的文字左右分别用一个<em>号包起来<br>\</em>斜体*</p><p>要倾斜和加粗的文字左右分别用三个<em>号包起来<br>\</em>**斜体加粗***</p><p>要加删除线的文字左右分别用两个<del>号包起来<br>\</del>~删除线~~</p><p>要加删除线的文字左右分别用两个==号包起来<br>==高亮==</p><p><strong>示例：</strong><br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del><br>==这是加粗的文字==  </p><h3 id="2-2-常用转义字符"><a href="#2-2-常用转义字符" class="headerlink" title="2.2 常用转义字符"></a>2.2 常用转义字符</h3><p>MarkDown利用了很多特殊符号标识语法，但在需要输入这些符号就需要利用转义字符来控制，避免MarkDown语法解析。</p><pre class="line-numbers language-text"><code class="language-text">\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-添加空格"><a href="#2-3-添加空格" class="headerlink" title="2.3 添加空格"></a>2.3 添加空格</h3><p>跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）, 有下面两个解决方案。</p><ul><li><p>手动输入空格 （&amp;nbsp；）。<strong>注意！</strong>此时的分号为英文分号，但是不推荐使用此方法，太麻烦！</p></li><li><p>使用全角空格。即：在全角输入状态下直接使用空格键就ok了</p></li></ul><h3 id="2-4-字体颜色"><a href="#2-4-字体颜色" class="headerlink" title="2.4 字体颜色"></a>2.4 字体颜色</h3><p>使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：</p><p><strong>示例：</strong><br><font color='#ff0000'>字体颜色</font></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p><strong>语法：</strong></p><p><strong>单行代码</strong>：代码之间分别用一个反引号包起来<br>    `代码内容`</p><p><strong>代码块</strong>：代码之间分别用三个反引号包起来，且两边的反引号单独占一行<br>```<br>  代码…<br>  代码…<br>  代码…<br>```</p><p><strong>示例：</strong></p><p>单行代码<br><code>create database hero;</code></p><p>代码块</p><pre class="line-numbers language-shell"><code class="language-shell">    function fun()&#123;         echo "这是一句非常牛逼的代码";    &#125;    fun();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">@requires_authorization<span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># A comment</span>    <span class="token keyword">print</span> <span class="token string">'hello world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-段落-amp-引用"><a href="#4-段落-amp-引用" class="headerlink" title="4. 段落&amp;引用"></a>4. 段落&amp;引用</h2><h2 id="4-1-段落"><a href="#4-1-段落" class="headerlink" title="4.1 段落"></a>4.1 段落</h2><ul><li>换行是在行尾加两个空格 [空格 + 空格 + 回车]</li></ul><h2 id="4-2-引用"><a href="#4-2-引用" class="headerlink" title="4.2 引用"></a>4.2 引用</h2><p>Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示</p><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;，三个&gt;&gt;&gt;，n个…</p><p><strong>示例：</strong></p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote><h3 id="4-3-分割线"><a href="#4-3-分割线" class="headerlink" title="4.3 分割线"></a>4.3 分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><h2 id="5-插入图片-amp-链接"><a href="#5-插入图片-amp-链接" class="headerlink" title="5.  插入图片&amp;链接"></a>5.  插入图片&amp;链接</h2><h3 id="5-1-插入图片"><a href="#5-1-插入图片" class="headerlink" title="5.1 插入图片"></a>5.1 插入图片</h3><p><strong>语法：</strong></p><p><strong>Inline</strong> (titles are optional):</p><p><code>![alt text](/path/img.jpg &quot;Title&quot;)</code></p><p><strong>Reference-style:</strong></p><p><code>![alt text][id]</code></p><ul><li>alt- 就是显示在图片下面的文字，相当于对图片内容的解释。</li><li>title- 是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</li></ul><p><strong>示例：</strong><br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&fm=27&gp=0.jpg" alt="blockchain" title="区块链"></p><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20200928231653.JPG"></p><p><strong>注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。</strong></p><h3 id="5-2-插入链接"><a href="#5-2-插入链接" class="headerlink" title="5.2 插入链接"></a>5.2 插入链接</h3><p><strong>Inline:</strong><br><code>An [example](http://url.com/ &quot;Title&quot;)</code></p><p><a href="http://www.baidu.com/">点击跳转至百度</a></p><h4 id="点击跳转至必应"><a href="#点击跳转至必应" class="headerlink" title="点击跳转至必应"></a><a href="http://www.bing.com/" title="必应">点击跳转至必应</a></h4><p><strong>Reference-style labels</strong> (titles are optional):</p><p><code>An [example][id]. Then, anywhere else in the doc, define the link: [id]: http://example.com/  &quot;Title&quot;</code></p><p>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].</p><p><strong>Email:</strong><br>&lt;&gt;包括的URL或邮箱地址会被自动转换成为超链接</p><p><code>An email &lt;example@example.com&gt; link.</code></p><p><a href="mailto:&#x78;&#120;&#120;&#120;&#x78;&#x78;&#64;&#49;&#x32;&#54;&#x2e;&#99;&#111;&#109;">&#x78;&#120;&#120;&#120;&#x78;&#x78;&#64;&#49;&#x32;&#54;&#x2e;&#99;&#111;&#109;</a></p><h2 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h2><h2 id="6-1-无序列表"><a href="#6-1-无序列表" class="headerlink" title="6.1 无序列表"></a>6.1 无序列表</h2><p><strong>语法:</strong><br>无序列表用 - + * 任何一种都可以</p><ul><li><p>整理知识，学习笔记</p></li><li><p>发布日记，杂文，所见所想</p><ul><li>撰写发布技术文稿（无序列表内嵌列表空二个空格）</li><li>撰写发布学术论文</li></ul></li></ul><p>注意：- + *跟内容之间都要有一个空格;<strong>整篇文档无序列表符号必须一致</strong></p><h3 id="6-2-有序列表"><a href="#6-2-有序列表" class="headerlink" title="6.2 有序列表"></a>6.2 有序列表</h3><p><strong>语法：</strong><br>数字加点</p><ol><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ol><p>注意：序号跟内容之间要有空格</p><h3 id="6-3-列表嵌套"><a href="#6-3-列表嵌套" class="headerlink" title="6.3 列表嵌套"></a>6.3 列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><ol><li>Fruit<ol><li>Apple</li><li>Orange</li><li>Peach</li><li>Banana</li></ol></li><li>Vegetable</li></ol><h3 id="6-4-列表-引用"><a href="#6-4-列表-引用" class="headerlink" title="6.4 列表+引用"></a>6.4 列表+引用</h3><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><ul><li><p><input disabled="" type="checkbox">  支持以 PDF 格式导出文稿</p></li><li><p><input disabled="" type="checkbox">  改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</p></li><li><p><input checked="" disabled="" type="checkbox">  新增 Todo 列表功能</p></li><li><p><input checked="" disabled="" type="checkbox">  修复 LaTex 公式渲染问题</p></li><li><p><input checked="" disabled="" type="checkbox">  新增 LaTex 公式编号功能</p></li><li><p>段落一</p><blockquote><p>This module implements a number of iterator building blocks inspired by constructs from APL, Haskell, and SML. Each has been recast in a form suitable for Python.</p></blockquote></li><li><p>段落二</p><blockquote><p>区块标记二</p></blockquote></li></ul><h2 id="7-表格"><a href="#7-表格" class="headerlink" title="7. 表格"></a>7. 表格</h2><p><strong>语法：</strong></p><pre class="line-numbers language-text"><code class="language-text">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注：三个短横杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p><p>示例：</p><pre class="line-numbers language-text"><code class="language-text">姓名|技能|排行:--|:--|:--刘备|哭|大哥关羽|打|二哥张飞|骂|三弟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text"><code class="language-text">| 项目        | 价格   |  数量  || --------   | -----:  | :----:  || 计算机     | \$1600 |   5     || 手机        |   \$12   |   12   || 管线        |    \$1    |  234  |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 使用</title>
      <link href="2019/02/27/vscode-usage/"/>
      <url>2019/02/27/vscode-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="Tips-总结"><a href="#Tips-总结" class="headerlink" title="Tips 总结"></a>Tips 总结</h2><h3 id="1-VSCode显示空格和tab符号"><a href="#1-VSCode显示空格和tab符号" class="headerlink" title="1. VSCode显示空格和tab符号"></a>1. VSCode显示空格和tab符号</h3><p>1.打开setting,在搜索框中输入<code>renderControlCharacters</code>,选中勾选框,即可显示tab</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/renderControlCharacters.JPG" alt="picgo"></p><p>2.在搜索框中输入<code>renderWhitespace</code>,选择all,即可显示空格.</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/renderWhitespace.JPG"></p><h2 id="插件扩展"><a href="#插件扩展" class="headerlink" title="插件扩展"></a>插件扩展</h2><ul><li><a href="https://marketplace.visualstudio.com/VSCode">https://marketplace.visualstudio.com/VSCode</a></li></ul><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><pre class="line-numbers language-text"><code class="language-text">- Markdown Preview Enhanced    预览与展示，以pdf文档样式的效果来显示内容，默认配置- Markdown Toc    生成目录，需要配置参数- Markdown PDF    可以简单地将编写的.md文件转换成PDF等格式的文件，设置常用配置- Markdownlint    语法规整和风格检查- Markdown Preview Github Stying    使用Github样式来渲染Markdown，朴素简洁- Markdown All in One    功能组合包，包含了书写Markdown需要用到的常用功能和设置（键盘快捷方式，目录，自动预览等），默认配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h3><pre class="line-numbers language-text"><code class="language-text">- Chinese (Simplified) Language Pack for Visual Studio Code：中文界面- Git History    提供可视化的 Git 版本树管理，可通过命令面板或界面按钮激活- GitLens    增强内置Git 功能, 显示丰富的git日志，文件历史、行历史等- Visual Studio IntelliCode    微软官方提供的基于 AI 辅助的自动补全功能，支持 Python、TypeScript/JavaScript和Java语言- TabNine    强大的 AI 辅助智能补全，支持几乎所有编程语言- Code Spell Checker    代码拼写检查, 检查代码中的单词拼写错误并给出错误拼写单词的建议- Settings Sync   使用GitHub Gist同步多台计算机上的设置，代码段，主题，文件图标，启动，键绑定，工作区和扩展- Code Runner    万能语言运行环境, 不用搭建各种语言的开发环境，选中一段代码直接运行，非常适合学习或测试各种开发语言- Docker    管理本地容器- filesize    在状态栏中显示当前文件大小，点击后还可以看到详细创建、修改时间- vscode-icons    文件图标，实现对各种文件类型的文件前的图标进行优化显示，，可以直接通过文件的图标快速知道文件类型- Rainbow Brackets    为圆括号，方括号和大括号提供彩虹色- Bracket Pair Colonizer 2    彩虹括号，使用彩虹色区分标注不同的括号对- Indent-Rainbow    用四种不同颜色交替着色文本前面的缩进- Log File Highlighter    日志文件高亮，主要是针对 INFO、WARN、ERROR 高亮，方便查看日志文件- TODO Highlight    高亮显示代码中的 TODO、FIXME 及其他注解- Atuo Rename Tag    修改 html 标签，自动帮你完成头部和尾部闭合标签的同步修改- RegExp Preview and Editor    通过命令面板启动，在分栏页面中编辑正则表达式，并以数据流图可视化显示正则语法结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h3><pre class="line-numbers language-text"><code class="language-text">- PDF: vscode-pdf    直接打开浏览pdf格式的二进制文件Draw.io Integration绘制流程图、脑图和UML图，新建扩展名为 .drawio、.dio 、.drawio.svg 文件即可进入编辑- https://github.com/hediet/vscode-drawio- https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Remote-Development"><a href="#Remote-Development" class="headerlink" title="Remote Development"></a>Remote Development</h3><pre class="line-numbers language-text"><code class="language-text">- Remote Development  https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack- Remote - SSH：基于 SSH 的远程开发- Remote - Containers：基于 Docker 容器的远程开发- Remote - WSL：基于 Windows Subsystem for Linux(wsl) 的远程开发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><pre class="line-numbers language-text"><code class="language-text">- Beautify 代码格式化（Javascript, JSON, CSS, Sass, and HTML）- ESLint 代码检查，关注语法规则和代码风格，可以用来保证写出语法正确、风格统一的代码。- Prettier 严格基于规则的代码格式化程序, 解析代码并使用自定义规则重新打印代码，从而实现风格一致- SonarLint<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h3><pre class="line-numbers language-text"><code class="language-text">### JavaJava Extension Pack- Debugger for Java- Language Support for Java(TM) by Red Hat- Visual Studio IntelliCode- Maven for Java- Java Test Runner- Java Dependency ViewerSpring Boot Extension Pack- Spring Boot Tools- Spring Boot Dashboard- Spring Initializer Java SupportCheckStyle for JavaJava DecompilerLombok Annotations Support### Python- Python Extension Pack- python snippets- pylint### Bash- Bash IDE- shellman- Shell-format- Bash Debug### Jenkins- JenkinsFile Support- Groovy Lint, Format and Fix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用私有gitlab搭建gitbook持续集成</title>
      <link href="2019/01/27/gitbook-gitlab/"/>
      <url>2019/01/27/gitbook-gitlab/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在项目实践中，团队需要对用到的知识技术进行总结，即便于分享，也利于传承，而gitbook就是个不错的选择，使用gitbook-cli 对Markdown文档进行编译，生成静态文件，再通过web服务器（e.g. nginx）对外提供服务。</p><p>gitbook和gitlab搭建持续集成，可实现文档的即时更新，这也是我在DevOps实践的一部分。</p><ul><li><p><a href="https://www.gitbook.com/">https://www.gitbook.com</a></p></li><li><p><a href="https://github.com/GitbookIO/gitbook">https://github.com/GitbookIO/gitbook</a></p></li></ul><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/pics/20201016234543.png"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><p>gitbook 是一个基于 Node.js 的命令行工具，下载安装 <a href="https://nodejs.org/en/">Node.js</a>，安装完成之后，你可以使用下面的命令来检验是否安装成功。</p><p><code>$ node -v</code></p><h3 id="2-安装-gitbook"><a href="#2-安装-gitbook" class="headerlink" title="2. 安装 gitbook"></a>2. 安装 gitbook</h3><p>输入下面的命令来安装 gitbook</p><p><code>npm install gitbook-cli -g</code></p><p>安装完成之后，你可以使用下面的命令来检验是否安装成功</p><p><code>$ gitbook -V</code></p><p>更多详情请参照 <a href="https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md">gitbook 安装文档</a> 来安装 gitbook</p><h3 id="3-安装-Gitlab-Runner"><a href="#3-安装-Gitlab-Runner" class="headerlink" title="3. 安装 Gitlab Runner"></a>3. 安装 Gitlab Runner</h3><p>下载二进制包</p><p><code>sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</code></p><p>添加执行权限</p><p><code>sudo chmod +x /usr/local/bin/gitlab-runner</code></p><p>(可选)如果使用Docker，安装Docker</p><p><code>curl -sSL https://get.docker.com/ | sh</code></p><p>创建 GitLab CI 用户</p><p><code>sudo useradd --comment &#39;GitLab Runner&#39; --create-home gitlab-runner --shell /bin/bash</code></p><p>以Service方式安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> gitlab-runner <span class="token function">install</span> --user<span class="token operator">=</span>gitlab-runner --working-directory<span class="token operator">=</span>/home/gitlab-runner<span class="token function">sudo</span> gitlab-runner start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-注册Runner"><a href="#4-注册Runner" class="headerlink" title="4. 注册Runner"></a>4. 注册Runner</h3><ul><li><a href="https://docs.gitlab.com/runner/install/linux-manually.html">Runner安装</a>    </li><li><a href="https://docs.gitlab.com/runner/register/index.html">Runner注册</a></li></ul><p>运行以下命令</p><p><code>sudo gitlab-runner register</code></p><p>输入GitLab 实例 URL <code>Please enter the gitlab-ci coordinator URL</code></p><p>输入Gitlab注册的token (Gitlab admin权限才能看见)</p><p><code>Please enter the gitlab-ci token for this runner     xxx</code></p><p>输入Runner描述，后面可在Gitlab UI上更新</p><p><code>Please enter the gitlab-ci description for this runner</code></p><p>输入Runner Tag，后面可在Gitlab UI上更新</p><p><code>Please enter the gitlab-ci tags for this runner (comma separated):</code></p><p>选择Runner executor</p><p> <code>Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:     shell</code></p><h2 id="gitbook-配置"><a href="#gitbook-配置" class="headerlink" title="gitbook 配置"></a>gitbook 配置</h2><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h3><pre class="line-numbers language-text"><code class="language-text">        .        ├── book.json        ├── README.md        ├── SUMMARY.md        ├── chapter-1/        |   ├── README.md        |   └── something.md        └── chapter-2/            ├── README.md            └── something.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>README.md<br>gitbook第一页内容是从文件 README.md 中提取的。如果这个文件名没有出现在 SUMMARY 中，那么它会被添加为章节的第一个条目</p></li><li><p>book.json<br>该文件主要用来存放配置信息</p></li><li><p>.bookignore<br>将读取.gitignore，.bookignore以及.ignore文件以获得文件和文件夹跳过列表</p></li><li><p>Glossary.md<br>允许指定要显示为注释的术语及其各自的定义。根据这些条款，GitBook将自动构建一个索引并突出显示这些术语</p></li><li><p>SUMMARY.md<br>用于存放GitBook的文件目录信息，左侧的目录就是根据这个文件来生成的，默认对应的文件是 SUMMARY.md，可以在 book.json 重新定义该文件的对应值。它通过Markdown中的列表语法来表示文件的父子关系</p><p><strong>注意</strong> 不被SUMMARY.md包含的文件不会被gitbook处理</p><p><strong>SUMMARY.md示例：</strong></p><pre class="line-numbers language-text"><code class="language-text"># Summary* [Introduction](README.md)* [Part I](part1/README.md)    * [Writing is nice](part1/writing.md)    * [gitbook is nice](part1/gitbook.md)* [Part II](part2/README.md)    * [We love feedback](part2/feedback_please.md)    * [Better tools for authors](part2/better_tools.md)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  通过使用 标题 或者 水平分割线 将 gitbook 分为几个不同的部分，如下所示：</p><pre class="line-numbers language-text"><code class="language-text"># Summary### Part I* [Introduction](README.md)* [Writing is nice](part1/writing.md)* [gitbook is nice](part1/gitbook.md)### Part II* [We love feedback](part2/feedback_please.md)* [Better tools for authors](part2/better_tools.md)---* [Last part without title](part3/title.md)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  目录中的章节可以使用锚点指向文件的特定部分</p><pre class="line-numbers language-text"><code class="language-text"># Summary### Part I* [Part I](part1/README.md)    * [Writing is nice](part1/README.md#writing)    * [gitbook is nice](part1/README.md#gitbook)* [Part II](part2/README.md)    * [We love feedback](part2/README.md#feedback)    * [Better tools for authors](part2/README.md#tools)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2. 命令行"></a>2. 命令行</h3><ol><li><p>gitbook init</p><p> gitbook项目初始化,会自动生成两个必要的文件 README.md 和 SUMMARY.md</p></li><li><p>gitbook build [path]</p><p> 构建gitbook项目生成静态网页，会生成一个 _book 文件夹（包含了 .md 对应的.html文件）</p></li><li><p>gitbook serve</p><p>该命令实际上会首先调用 gitbook build 编译 .md，完成以后会打开一个web服务器，监听在本地的4000端口。</p><p>生产的静态文件可单独放到tomcat或者nginx供静态访问</p><pre class="line-numbers language-text"><code class="language-text">./├── _book│   ├── gitbook│   │   ├── fonts│   │   ├── gitbook.js│   │   ├── gitbook-plugin-fontsettings│   │   ├── gitbook-plugin-highlight│   │   ├── gitbook-plugin-livereload│   │   ├── gitbook-plugin-lunr│   │   ├── gitbook-plugin-search│   │   ├── gitbook-plugin-sharing│   │   ├── images│   ├── index.html│   └── search_index.json├── README.md└── SUMMARY.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>gitbook update #更新gitbook到最新版本</p></li><li><p>gitbook install    #安装依赖</p></li><li><p>gitbook builid –debug    #输出错误信息</p></li><li><p>gitbook build –log=debug  #指定log级别</p></li></ol><h3 id="3-插件"><a href="#3-插件" class="headerlink" title="3. 插件"></a>3. 插件</h3><p>gitbook 提供了丰富插件，默认带有 5 个插件，highlight、search、sharing、font-settings、livereload，如果要去除自带的插件， 可以在插件名称前面加 -，比如：</p><pre class="line-numbers language-bash"><code class="language-bash">        <span class="token string">"plugins"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token string">"-search"</span>        <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>插件使用参考</p><ul><li><a href="https://gitbook.zhangjikai.com/plugins.html">https://gitbook.zhangjikai.com/plugins.html</a></li></ul><h2 id="gitlab-与gitbook集成"><a href="#gitlab-与gitbook集成" class="headerlink" title="gitlab 与gitbook集成"></a>gitlab 与gitbook集成</h2><p><strong>.gitlab-ci.yml 示例：</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># requiring the environment of NodeJS 10</span><span class="token key atrule">image</span><span class="token punctuation">:</span> node<span class="token punctuation">:</span><span class="token number">10</span><span class="token comment" spellcheck="true"># add 'node_modules' to cache for speeding up builds</span><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">paths</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> node_modules/ <span class="token comment" spellcheck="true"># Node modules and dependencies</span><span class="token key atrule">before_script</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> npm install gitbook<span class="token punctuation">-</span>cli <span class="token punctuation">-</span>g <span class="token comment" spellcheck="true"># install gitbook</span>  <span class="token punctuation">-</span> gitbook fetch 3.2.3 <span class="token comment" spellcheck="true"># fetch final stable version</span>  <span class="token punctuation">-</span> gitbook install <span class="token comment" spellcheck="true"># add any requested plugins in book.json</span><span class="token key atrule">test</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> gitbook build . public <span class="token comment" spellcheck="true"># build to public path</span>  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> branches <span class="token comment" spellcheck="true"># this job will affect every branch except 'master'</span>  <span class="token key atrule">except</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> master<span class="token comment" spellcheck="true"># the 'pages' job will deploy and build your site to the 'public' path</span><span class="token key atrule">pages</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> gitbook build . public <span class="token comment" spellcheck="true"># build to public path</span>  <span class="token key atrule">artifacts</span><span class="token punctuation">:</span>    <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> public    <span class="token key atrule">expire_in</span><span class="token punctuation">:</span> 1 week  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> master <span class="token comment" spellcheck="true"># this job will affect only the 'master' branch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.chengweiyang.cn/gitbook/index.html">http://www.chengweiyang.cn/gitbook/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitbook, gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 后台运行进程</title>
      <link href="2018/02/27/linux-hou-tai-yun-xing-jin-cheng/"/>
      <url>2018/02/27/linux-hou-tai-yun-xing-jin-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用。</p></blockquote><h2 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h2><p><strong>比较下 &amp; 与 nohup：</strong></p><ul><li>&amp; ：后台运行，但用户终端退出时（断连），命令结束</li><li>nohup test.sh &amp; : 后台运行，用户终端退出时（断连）依然保持运行，可使用标准输入输出</li></ul><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。e.g. <code>sh test.sh &amp;</code></p><p>适合在后台运行的命令有f i n d、费时的排序及一些s h e l l脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：</p><p><code>command &gt; out.file 2&gt;&amp;1 &amp;</code><br>这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p><p>PS：当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。(ps -ef | grep 进程号 或者 kill -9 进程号）</p><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up / ignoring hangup signals) 即 忽略挂起信号一直在后台执行。</p><p><code>语法: nohup Command [ Arg … ] [&amp; ]</code></p><p><code>e.g. $nohup python manage.py runserver &amp;</code></p><p><strong>使用时注意:</strong></p><p>在当shell中提示了nohup成功后，还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；如果在nohup执行成功后直接点关闭程序按钮关闭终端的话，这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown，起不到关掉终端后调用程序继续后台运行的作用。</p><p><code>nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code></p><p>无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的nohup.out 文件中。如果当前目录的nohup.out文件不可写，输出重定向到$HOME/nohup.out文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p><p><strong>2&gt;&amp;1解析:</strong></p><p><code>command &gt;out.file 2&gt;&amp;1 &amp;</code></p><ul><li><p>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</p></li><li><p>2&gt;&amp;1 是将标准出错 重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</p></li></ul><p>试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</p><h2 id="查看后台运行的命令"><a href="#查看后台运行的命令" class="headerlink" title="查看后台运行的命令"></a>查看后台运行的命令</h2><p>有两个命令可以来查看，<code>ps</code> 和 <code>jobs</code>。区别在于 jobs 只能查看当前终端后台执行的任务，换了终端就看不见了。而ps命令适用于查看瞬时进程的动态，可以看到别的终端的任务</p><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看当前有多少在后台运行的命令</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/1603718157_20201026141913132_275681253.png"></p><p>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</p><p>“+”代表最近的一个任务（当前任务），“-”代表之前的任务。</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/1603718158_20201026143108907_1737208027.png"></p><p>只有在当前命令行中使用 nohup和&amp; 时，jobs命令才能将它显示出来。如果将他们写到 .sh 脚本中，然后执行脚本，是显示不出来的</p><p>比如执行下面这个脚本后，jobs 显示不出来：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashnohup java -Dfile.encoding=UTF-8 -Dname=Runtime-Name -server -Xms128M -Xmx512M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=256M -XX:+HeapDumpOnOutOfMemoryError -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -jar test.jar $1 $2 $3 &<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>nohup命令可以在你退出帐户/关闭终端之后继续运行相应的进程。关闭中断后，在另一个终端<code>jobs</code>已无法看到后台跑得程序了，此时利用ps（进程查看命令）</p><p><code>ps -aux | grep &quot;test.sh&quot;  #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分</code></p><h2 id="关闭当前后台运行的程序"><a href="#关闭当前后台运行的程序" class="headerlink" title="关闭当前后台运行的程序"></a>关闭当前后台运行的程序</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><ol><li><p>通过jobs命令查看job号（假设为num），然后执行kill %num</p></li><li><p>通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid</p></li></ol><p>前台进程的终止：ctrl+c</p><h2 id="前后台进程的切换与控制"><a href="#前后台进程的切换与控制" class="headerlink" title="前后台进程的切换与控制"></a>前后台进程的切换与控制</h2><h3 id="ctrl-z-命令"><a href="#ctrl-z-命令" class="headerlink" title="ctrl + z 命令"></a>ctrl + z 命令</h3><p>将一个正在前台执行的命令放到后台，并且处于暂停状态。</p><h3 id="fg-命令"><a href="#fg-命令" class="headerlink" title="fg 命令"></a>fg 命令</h3><p>将后台中的命令 <code>调至 前台继续运行</code>。如果后台中有多个命令，可以用 <code>fg %jobnumber</code>（是命令编号，不是进程号）将选中的命令调出</p><h3 id="bg-命令"><a href="#bg-命令" class="headerlink" title="bg 命令"></a>bg 命令</h3><p>将一个在后台暂停的命令，<code>变成在后台继续执行</code>。如果后台中有多个命令，可以用<code>bg %jobnumber</code>将选中的命令调出。</p><p><img src="https://gitee.com/owen2016/pic-hub/raw/master/1603718158_20201026142920042_1829517779.png"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="问题1-为什么ssh一关闭，程序就不再运行了"><a href="#问题1-为什么ssh一关闭，程序就不再运行了" class="headerlink" title="问题1-为什么ssh一关闭，程序就不再运行了"></a>问题1-为什么ssh一关闭，程序就不再运行了</h3><p>元凶：SIGHUP 信号</p><p>让我们来看看为什么关掉窗口/断开连接会使得正在运行的程序死掉。</p><p>在Linux/Unix中，有这样几个概念：</p><ul><li><p>进程组（process group）：<code>一个或多个进程的集合</code>，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。</p></li><li><p>会话期（session）：<code>一个或多个进程组的集合</code>，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。<br>会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。</p></li></ul><p>根据POSIX.1定义：</p><ul><li>挂断信号（SIGHUP）默认的动作是终止程序。</li><li>当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。</li><li>如果会话期首进程终止，则该信号发送到该会话期前台进程组。</li></ul><p>一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。（关于孤儿进程参照：<a href="http://blog.csdn.net/hmsiwtv/article/details/7901711">http://blog.csdn.net/hmsiwtv/article/details/7901711</a> ）</p><p>结论：因此当网络断开或终端窗口关闭后，也就是SSH断开以后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。</p><p>简而言之：就是ssh 打开以后，bash等都是他的子程序，一旦ssh关闭，系统将所有相关进程杀掉！！ 导致一旦ssh关闭，执行中的任务就取消了</p><p><strong>示例：</strong></p><p>打开两个SSH终端窗口，在其中一个运行top命令。</p><p><code>owen@swarm-manager-105:~$ top</code></p><p>在另一个终端窗口，找到top的进程ID为 38779，其父进程ID为38751，即登录shell。</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ ps -ef|grep topowen      24007  23571  0 16:58 tty2     00:00:01 nautilus-desktopowen      38779  38751  0 20:22 pts/1    00:00:00 top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用pstree命令可以更清楚地看到这个关系：</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ pstree -H 38779|grep top        |-sshd-+-sshd---sshd---bash---top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>ps -xj</code>命令可以看到，登录shell（PID 38751）和top在同一个会话期，shell为会话期首进程，所在进程组PGID为38751，top所在进程组PGID为38779，为前台进程组。</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ ps -xj|grep 38751 38750  38751  38751  38751 pts/1     38779 Ss    1000   0:00 -bash 38751  38779  38779  38751 pts/1     38779 S+    1000   0:03 top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关闭第一个SSH窗口，在另一个窗口中可以看到top也被杀掉了。</p><pre class="line-numbers language-shell"><code class="language-shell">owen@swarm-manager-105:~$ ps -ef|grep 38751owen      40412  38966  0 20:52 pts/4    00:00:00 grep --color=auto 38751<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="问题2-为什么守护程序就算ssh-打开的，就算关闭ssh也不会影响其运行？"><a href="#问题2-为什么守护程序就算ssh-打开的，就算关闭ssh也不会影响其运行？" class="headerlink" title="问题2- 为什么守护程序就算ssh 打开的，就算关闭ssh也不会影响其运行？"></a>问题2- 为什么守护程序就算ssh 打开的，就算关闭ssh也不会影响其运行？</h3><p>因为他们的程序特殊，比如httpd –k start运行这个以后，他不属于sshd这个进程组  而是单独的进程组，所以就算关闭了ssh，和他也没有任何关系！</p><pre class="line-numbers language-shell"><code class="language-shell">[owen@centos-1 ~]$ pstree |grep http        |-httpd---8*[httpd]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结论：守护进程的启动命令本身就是特殊的，和一般命令不同的，比如mysqld_safe 这样的命令 一旦使用了  就是守护进程运行。所以想把一般程序改造为守护程序是不可能，</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
